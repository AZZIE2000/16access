
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Vendor
 * 
 */
export type Vendor = $Result.DefaultSelection<Prisma.$VendorPayload>
/**
 * Model Zone
 * 
 */
export type Zone = $Result.DefaultSelection<Prisma.$ZonePayload>
/**
 * Model Gate
 * 
 */
export type Gate = $Result.DefaultSelection<Prisma.$GatePayload>
/**
 * Model Permission
 * 
 */
export type Permission = $Result.DefaultSelection<Prisma.$PermissionPayload>
/**
 * Model Employee
 * 
 */
export type Employee = $Result.DefaultSelection<Prisma.$EmployeePayload>
/**
 * Model WorkingHours
 * 
 */
export type WorkingHours = $Result.DefaultSelection<Prisma.$WorkingHoursPayload>
/**
 * Model Alert
 * 
 */
export type Alert = $Result.DefaultSelection<Prisma.$AlertPayload>
/**
 * Model Activity
 * 
 */
export type Activity = $Result.DefaultSelection<Prisma.$ActivityPayload>
/**
 * Model Attachment
 * 
 */
export type Attachment = $Result.DefaultSelection<Prisma.$AttachmentPayload>
/**
 * Model VendorAttachment
 * 
 */
export type VendorAttachment = $Result.DefaultSelection<Prisma.$VendorAttachmentPayload>
/**
 * Model EmployeeAttachment
 * 
 */
export type EmployeeAttachment = $Result.DefaultSelection<Prisma.$EmployeeAttachmentPayload>
/**
 * Model EmployeePermission
 * 
 */
export type EmployeePermission = $Result.DefaultSelection<Prisma.$EmployeePermissionPayload>
/**
 * Model VendorGate
 * 
 */
export type VendorGate = $Result.DefaultSelection<Prisma.$VendorGatePayload>
/**
 * Model VendorZone
 * 
 */
export type VendorZone = $Result.DefaultSelection<Prisma.$VendorZonePayload>
/**
 * Model EmployeeGate
 * 
 */
export type EmployeeGate = $Result.DefaultSelection<Prisma.$EmployeeGatePayload>
/**
 * Model EmployeeZone
 * 
 */
export type EmployeeZone = $Result.DefaultSelection<Prisma.$EmployeeZonePayload>
/**
 * Model EmployeeAllowedDate
 * 
 */
export type EmployeeAllowedDate = $Result.DefaultSelection<Prisma.$EmployeeAllowedDatePayload>

/**
 * Enums
 */
export namespace $Enums {
  export const Role: {
  admin: 'admin',
  usher: 'usher'
};

export type Role = (typeof Role)[keyof typeof Role]


export const EmployeeStatus: {
  PENDING: 'PENDING',
  ACTIVE: 'ACTIVE',
  SUSPENDED: 'SUSPENDED'
};

export type EmployeeStatus = (typeof EmployeeStatus)[keyof typeof EmployeeStatus]


export const DayOfWeek: {
  MONDAY: 'MONDAY',
  TUESDAY: 'TUESDAY',
  WEDNESDAY: 'WEDNESDAY',
  THURSDAY: 'THURSDAY',
  FRIDAY: 'FRIDAY',
  SATURDAY: 'SATURDAY',
  SUNDAY: 'SUNDAY'
};

export type DayOfWeek = (typeof DayOfWeek)[keyof typeof DayOfWeek]


export const ActivityType: {
  ENTRY: 'ENTRY',
  EXIT: 'EXIT',
  DENIED: 'DENIED'
};

export type ActivityType = (typeof ActivityType)[keyof typeof ActivityType]


export const AccessStatus: {
  GRANTED: 'GRANTED',
  DENIED: 'DENIED'
};

export type AccessStatus = (typeof AccessStatus)[keyof typeof AccessStatus]


export const EmployeeAttachmentType: {
  ID_CARD: 'ID_CARD',
  PROFILE_PHOTO: 'PROFILE_PHOTO',
  OTHER: 'OTHER'
};

export type EmployeeAttachmentType = (typeof EmployeeAttachmentType)[keyof typeof EmployeeAttachmentType]

}

export type Role = $Enums.Role

export const Role: typeof $Enums.Role

export type EmployeeStatus = $Enums.EmployeeStatus

export const EmployeeStatus: typeof $Enums.EmployeeStatus

export type DayOfWeek = $Enums.DayOfWeek

export const DayOfWeek: typeof $Enums.DayOfWeek

export type ActivityType = $Enums.ActivityType

export const ActivityType: typeof $Enums.ActivityType

export type AccessStatus = $Enums.AccessStatus

export const AccessStatus: typeof $Enums.AccessStatus

export type EmployeeAttachmentType = $Enums.EmployeeAttachmentType

export const EmployeeAttachmentType: typeof $Enums.EmployeeAttachmentType

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.vendor`: Exposes CRUD operations for the **Vendor** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Vendors
    * const vendors = await prisma.vendor.findMany()
    * ```
    */
  get vendor(): Prisma.VendorDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.zone`: Exposes CRUD operations for the **Zone** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Zones
    * const zones = await prisma.zone.findMany()
    * ```
    */
  get zone(): Prisma.ZoneDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.gate`: Exposes CRUD operations for the **Gate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Gates
    * const gates = await prisma.gate.findMany()
    * ```
    */
  get gate(): Prisma.GateDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.permission`: Exposes CRUD operations for the **Permission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Permissions
    * const permissions = await prisma.permission.findMany()
    * ```
    */
  get permission(): Prisma.PermissionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.employee`: Exposes CRUD operations for the **Employee** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Employees
    * const employees = await prisma.employee.findMany()
    * ```
    */
  get employee(): Prisma.EmployeeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.workingHours`: Exposes CRUD operations for the **WorkingHours** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WorkingHours
    * const workingHours = await prisma.workingHours.findMany()
    * ```
    */
  get workingHours(): Prisma.WorkingHoursDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.alert`: Exposes CRUD operations for the **Alert** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Alerts
    * const alerts = await prisma.alert.findMany()
    * ```
    */
  get alert(): Prisma.AlertDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.activity`: Exposes CRUD operations for the **Activity** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Activities
    * const activities = await prisma.activity.findMany()
    * ```
    */
  get activity(): Prisma.ActivityDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.attachment`: Exposes CRUD operations for the **Attachment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Attachments
    * const attachments = await prisma.attachment.findMany()
    * ```
    */
  get attachment(): Prisma.AttachmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.vendorAttachment`: Exposes CRUD operations for the **VendorAttachment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VendorAttachments
    * const vendorAttachments = await prisma.vendorAttachment.findMany()
    * ```
    */
  get vendorAttachment(): Prisma.VendorAttachmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.employeeAttachment`: Exposes CRUD operations for the **EmployeeAttachment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EmployeeAttachments
    * const employeeAttachments = await prisma.employeeAttachment.findMany()
    * ```
    */
  get employeeAttachment(): Prisma.EmployeeAttachmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.employeePermission`: Exposes CRUD operations for the **EmployeePermission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EmployeePermissions
    * const employeePermissions = await prisma.employeePermission.findMany()
    * ```
    */
  get employeePermission(): Prisma.EmployeePermissionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.vendorGate`: Exposes CRUD operations for the **VendorGate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VendorGates
    * const vendorGates = await prisma.vendorGate.findMany()
    * ```
    */
  get vendorGate(): Prisma.VendorGateDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.vendorZone`: Exposes CRUD operations for the **VendorZone** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VendorZones
    * const vendorZones = await prisma.vendorZone.findMany()
    * ```
    */
  get vendorZone(): Prisma.VendorZoneDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.employeeGate`: Exposes CRUD operations for the **EmployeeGate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EmployeeGates
    * const employeeGates = await prisma.employeeGate.findMany()
    * ```
    */
  get employeeGate(): Prisma.EmployeeGateDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.employeeZone`: Exposes CRUD operations for the **EmployeeZone** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EmployeeZones
    * const employeeZones = await prisma.employeeZone.findMany()
    * ```
    */
  get employeeZone(): Prisma.EmployeeZoneDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.employeeAllowedDate`: Exposes CRUD operations for the **EmployeeAllowedDate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EmployeeAllowedDates
    * const employeeAllowedDates = await prisma.employeeAllowedDate.findMany()
    * ```
    */
  get employeeAllowedDate(): Prisma.EmployeeAllowedDateDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.19.0
   * Query Engine version: 2ba551f319ab1df4bc874a89965d8b3641056773
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Vendor: 'Vendor',
    Zone: 'Zone',
    Gate: 'Gate',
    Permission: 'Permission',
    Employee: 'Employee',
    WorkingHours: 'WorkingHours',
    Alert: 'Alert',
    Activity: 'Activity',
    Attachment: 'Attachment',
    VendorAttachment: 'VendorAttachment',
    EmployeeAttachment: 'EmployeeAttachment',
    EmployeePermission: 'EmployeePermission',
    VendorGate: 'VendorGate',
    VendorZone: 'VendorZone',
    EmployeeGate: 'EmployeeGate',
    EmployeeZone: 'EmployeeZone',
    EmployeeAllowedDate: 'EmployeeAllowedDate'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "vendor" | "zone" | "gate" | "permission" | "employee" | "workingHours" | "alert" | "activity" | "attachment" | "vendorAttachment" | "employeeAttachment" | "employeePermission" | "vendorGate" | "vendorZone" | "employeeGate" | "employeeZone" | "employeeAllowedDate"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Vendor: {
        payload: Prisma.$VendorPayload<ExtArgs>
        fields: Prisma.VendorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VendorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VendorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload>
          }
          findFirst: {
            args: Prisma.VendorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VendorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload>
          }
          findMany: {
            args: Prisma.VendorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload>[]
          }
          create: {
            args: Prisma.VendorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload>
          }
          createMany: {
            args: Prisma.VendorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VendorCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload>[]
          }
          delete: {
            args: Prisma.VendorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload>
          }
          update: {
            args: Prisma.VendorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload>
          }
          deleteMany: {
            args: Prisma.VendorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VendorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VendorUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload>[]
          }
          upsert: {
            args: Prisma.VendorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload>
          }
          aggregate: {
            args: Prisma.VendorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVendor>
          }
          groupBy: {
            args: Prisma.VendorGroupByArgs<ExtArgs>
            result: $Utils.Optional<VendorGroupByOutputType>[]
          }
          count: {
            args: Prisma.VendorCountArgs<ExtArgs>
            result: $Utils.Optional<VendorCountAggregateOutputType> | number
          }
        }
      }
      Zone: {
        payload: Prisma.$ZonePayload<ExtArgs>
        fields: Prisma.ZoneFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ZoneFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZonePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ZoneFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZonePayload>
          }
          findFirst: {
            args: Prisma.ZoneFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZonePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ZoneFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZonePayload>
          }
          findMany: {
            args: Prisma.ZoneFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZonePayload>[]
          }
          create: {
            args: Prisma.ZoneCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZonePayload>
          }
          createMany: {
            args: Prisma.ZoneCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ZoneCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZonePayload>[]
          }
          delete: {
            args: Prisma.ZoneDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZonePayload>
          }
          update: {
            args: Prisma.ZoneUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZonePayload>
          }
          deleteMany: {
            args: Prisma.ZoneDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ZoneUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ZoneUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZonePayload>[]
          }
          upsert: {
            args: Prisma.ZoneUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZonePayload>
          }
          aggregate: {
            args: Prisma.ZoneAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateZone>
          }
          groupBy: {
            args: Prisma.ZoneGroupByArgs<ExtArgs>
            result: $Utils.Optional<ZoneGroupByOutputType>[]
          }
          count: {
            args: Prisma.ZoneCountArgs<ExtArgs>
            result: $Utils.Optional<ZoneCountAggregateOutputType> | number
          }
        }
      }
      Gate: {
        payload: Prisma.$GatePayload<ExtArgs>
        fields: Prisma.GateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GatePayload>
          }
          findFirst: {
            args: Prisma.GateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GatePayload>
          }
          findMany: {
            args: Prisma.GateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GatePayload>[]
          }
          create: {
            args: Prisma.GateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GatePayload>
          }
          createMany: {
            args: Prisma.GateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GateCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GatePayload>[]
          }
          delete: {
            args: Prisma.GateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GatePayload>
          }
          update: {
            args: Prisma.GateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GatePayload>
          }
          deleteMany: {
            args: Prisma.GateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GateUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GatePayload>[]
          }
          upsert: {
            args: Prisma.GateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GatePayload>
          }
          aggregate: {
            args: Prisma.GateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGate>
          }
          groupBy: {
            args: Prisma.GateGroupByArgs<ExtArgs>
            result: $Utils.Optional<GateGroupByOutputType>[]
          }
          count: {
            args: Prisma.GateCountArgs<ExtArgs>
            result: $Utils.Optional<GateCountAggregateOutputType> | number
          }
        }
      }
      Permission: {
        payload: Prisma.$PermissionPayload<ExtArgs>
        fields: Prisma.PermissionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PermissionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PermissionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          findFirst: {
            args: Prisma.PermissionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PermissionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          findMany: {
            args: Prisma.PermissionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>[]
          }
          create: {
            args: Prisma.PermissionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          createMany: {
            args: Prisma.PermissionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PermissionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>[]
          }
          delete: {
            args: Prisma.PermissionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          update: {
            args: Prisma.PermissionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          deleteMany: {
            args: Prisma.PermissionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PermissionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PermissionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>[]
          }
          upsert: {
            args: Prisma.PermissionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          aggregate: {
            args: Prisma.PermissionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePermission>
          }
          groupBy: {
            args: Prisma.PermissionGroupByArgs<ExtArgs>
            result: $Utils.Optional<PermissionGroupByOutputType>[]
          }
          count: {
            args: Prisma.PermissionCountArgs<ExtArgs>
            result: $Utils.Optional<PermissionCountAggregateOutputType> | number
          }
        }
      }
      Employee: {
        payload: Prisma.$EmployeePayload<ExtArgs>
        fields: Prisma.EmployeeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmployeeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmployeeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          findFirst: {
            args: Prisma.EmployeeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmployeeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          findMany: {
            args: Prisma.EmployeeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>[]
          }
          create: {
            args: Prisma.EmployeeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          createMany: {
            args: Prisma.EmployeeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EmployeeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>[]
          }
          delete: {
            args: Prisma.EmployeeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          update: {
            args: Prisma.EmployeeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          deleteMany: {
            args: Prisma.EmployeeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmployeeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EmployeeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>[]
          }
          upsert: {
            args: Prisma.EmployeeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          aggregate: {
            args: Prisma.EmployeeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmployee>
          }
          groupBy: {
            args: Prisma.EmployeeGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmployeeGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmployeeCountArgs<ExtArgs>
            result: $Utils.Optional<EmployeeCountAggregateOutputType> | number
          }
        }
      }
      WorkingHours: {
        payload: Prisma.$WorkingHoursPayload<ExtArgs>
        fields: Prisma.WorkingHoursFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WorkingHoursFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkingHoursPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WorkingHoursFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkingHoursPayload>
          }
          findFirst: {
            args: Prisma.WorkingHoursFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkingHoursPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WorkingHoursFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkingHoursPayload>
          }
          findMany: {
            args: Prisma.WorkingHoursFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkingHoursPayload>[]
          }
          create: {
            args: Prisma.WorkingHoursCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkingHoursPayload>
          }
          createMany: {
            args: Prisma.WorkingHoursCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WorkingHoursCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkingHoursPayload>[]
          }
          delete: {
            args: Prisma.WorkingHoursDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkingHoursPayload>
          }
          update: {
            args: Prisma.WorkingHoursUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkingHoursPayload>
          }
          deleteMany: {
            args: Prisma.WorkingHoursDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WorkingHoursUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WorkingHoursUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkingHoursPayload>[]
          }
          upsert: {
            args: Prisma.WorkingHoursUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkingHoursPayload>
          }
          aggregate: {
            args: Prisma.WorkingHoursAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWorkingHours>
          }
          groupBy: {
            args: Prisma.WorkingHoursGroupByArgs<ExtArgs>
            result: $Utils.Optional<WorkingHoursGroupByOutputType>[]
          }
          count: {
            args: Prisma.WorkingHoursCountArgs<ExtArgs>
            result: $Utils.Optional<WorkingHoursCountAggregateOutputType> | number
          }
        }
      }
      Alert: {
        payload: Prisma.$AlertPayload<ExtArgs>
        fields: Prisma.AlertFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AlertFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AlertFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertPayload>
          }
          findFirst: {
            args: Prisma.AlertFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AlertFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertPayload>
          }
          findMany: {
            args: Prisma.AlertFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertPayload>[]
          }
          create: {
            args: Prisma.AlertCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertPayload>
          }
          createMany: {
            args: Prisma.AlertCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AlertCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertPayload>[]
          }
          delete: {
            args: Prisma.AlertDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertPayload>
          }
          update: {
            args: Prisma.AlertUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertPayload>
          }
          deleteMany: {
            args: Prisma.AlertDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AlertUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AlertUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertPayload>[]
          }
          upsert: {
            args: Prisma.AlertUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertPayload>
          }
          aggregate: {
            args: Prisma.AlertAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAlert>
          }
          groupBy: {
            args: Prisma.AlertGroupByArgs<ExtArgs>
            result: $Utils.Optional<AlertGroupByOutputType>[]
          }
          count: {
            args: Prisma.AlertCountArgs<ExtArgs>
            result: $Utils.Optional<AlertCountAggregateOutputType> | number
          }
        }
      }
      Activity: {
        payload: Prisma.$ActivityPayload<ExtArgs>
        fields: Prisma.ActivityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ActivityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ActivityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>
          }
          findFirst: {
            args: Prisma.ActivityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ActivityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>
          }
          findMany: {
            args: Prisma.ActivityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>[]
          }
          create: {
            args: Prisma.ActivityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>
          }
          createMany: {
            args: Prisma.ActivityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ActivityCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>[]
          }
          delete: {
            args: Prisma.ActivityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>
          }
          update: {
            args: Prisma.ActivityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>
          }
          deleteMany: {
            args: Prisma.ActivityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ActivityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ActivityUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>[]
          }
          upsert: {
            args: Prisma.ActivityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>
          }
          aggregate: {
            args: Prisma.ActivityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateActivity>
          }
          groupBy: {
            args: Prisma.ActivityGroupByArgs<ExtArgs>
            result: $Utils.Optional<ActivityGroupByOutputType>[]
          }
          count: {
            args: Prisma.ActivityCountArgs<ExtArgs>
            result: $Utils.Optional<ActivityCountAggregateOutputType> | number
          }
        }
      }
      Attachment: {
        payload: Prisma.$AttachmentPayload<ExtArgs>
        fields: Prisma.AttachmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AttachmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttachmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AttachmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttachmentPayload>
          }
          findFirst: {
            args: Prisma.AttachmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttachmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AttachmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttachmentPayload>
          }
          findMany: {
            args: Prisma.AttachmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttachmentPayload>[]
          }
          create: {
            args: Prisma.AttachmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttachmentPayload>
          }
          createMany: {
            args: Prisma.AttachmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AttachmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttachmentPayload>[]
          }
          delete: {
            args: Prisma.AttachmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttachmentPayload>
          }
          update: {
            args: Prisma.AttachmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttachmentPayload>
          }
          deleteMany: {
            args: Prisma.AttachmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AttachmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AttachmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttachmentPayload>[]
          }
          upsert: {
            args: Prisma.AttachmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttachmentPayload>
          }
          aggregate: {
            args: Prisma.AttachmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAttachment>
          }
          groupBy: {
            args: Prisma.AttachmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<AttachmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.AttachmentCountArgs<ExtArgs>
            result: $Utils.Optional<AttachmentCountAggregateOutputType> | number
          }
        }
      }
      VendorAttachment: {
        payload: Prisma.$VendorAttachmentPayload<ExtArgs>
        fields: Prisma.VendorAttachmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VendorAttachmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorAttachmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VendorAttachmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorAttachmentPayload>
          }
          findFirst: {
            args: Prisma.VendorAttachmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorAttachmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VendorAttachmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorAttachmentPayload>
          }
          findMany: {
            args: Prisma.VendorAttachmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorAttachmentPayload>[]
          }
          create: {
            args: Prisma.VendorAttachmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorAttachmentPayload>
          }
          createMany: {
            args: Prisma.VendorAttachmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VendorAttachmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorAttachmentPayload>[]
          }
          delete: {
            args: Prisma.VendorAttachmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorAttachmentPayload>
          }
          update: {
            args: Prisma.VendorAttachmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorAttachmentPayload>
          }
          deleteMany: {
            args: Prisma.VendorAttachmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VendorAttachmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VendorAttachmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorAttachmentPayload>[]
          }
          upsert: {
            args: Prisma.VendorAttachmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorAttachmentPayload>
          }
          aggregate: {
            args: Prisma.VendorAttachmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVendorAttachment>
          }
          groupBy: {
            args: Prisma.VendorAttachmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<VendorAttachmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.VendorAttachmentCountArgs<ExtArgs>
            result: $Utils.Optional<VendorAttachmentCountAggregateOutputType> | number
          }
        }
      }
      EmployeeAttachment: {
        payload: Prisma.$EmployeeAttachmentPayload<ExtArgs>
        fields: Prisma.EmployeeAttachmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmployeeAttachmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeAttachmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmployeeAttachmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeAttachmentPayload>
          }
          findFirst: {
            args: Prisma.EmployeeAttachmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeAttachmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmployeeAttachmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeAttachmentPayload>
          }
          findMany: {
            args: Prisma.EmployeeAttachmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeAttachmentPayload>[]
          }
          create: {
            args: Prisma.EmployeeAttachmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeAttachmentPayload>
          }
          createMany: {
            args: Prisma.EmployeeAttachmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EmployeeAttachmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeAttachmentPayload>[]
          }
          delete: {
            args: Prisma.EmployeeAttachmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeAttachmentPayload>
          }
          update: {
            args: Prisma.EmployeeAttachmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeAttachmentPayload>
          }
          deleteMany: {
            args: Prisma.EmployeeAttachmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmployeeAttachmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EmployeeAttachmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeAttachmentPayload>[]
          }
          upsert: {
            args: Prisma.EmployeeAttachmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeAttachmentPayload>
          }
          aggregate: {
            args: Prisma.EmployeeAttachmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmployeeAttachment>
          }
          groupBy: {
            args: Prisma.EmployeeAttachmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmployeeAttachmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmployeeAttachmentCountArgs<ExtArgs>
            result: $Utils.Optional<EmployeeAttachmentCountAggregateOutputType> | number
          }
        }
      }
      EmployeePermission: {
        payload: Prisma.$EmployeePermissionPayload<ExtArgs>
        fields: Prisma.EmployeePermissionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmployeePermissionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePermissionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmployeePermissionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePermissionPayload>
          }
          findFirst: {
            args: Prisma.EmployeePermissionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePermissionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmployeePermissionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePermissionPayload>
          }
          findMany: {
            args: Prisma.EmployeePermissionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePermissionPayload>[]
          }
          create: {
            args: Prisma.EmployeePermissionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePermissionPayload>
          }
          createMany: {
            args: Prisma.EmployeePermissionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EmployeePermissionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePermissionPayload>[]
          }
          delete: {
            args: Prisma.EmployeePermissionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePermissionPayload>
          }
          update: {
            args: Prisma.EmployeePermissionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePermissionPayload>
          }
          deleteMany: {
            args: Prisma.EmployeePermissionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmployeePermissionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EmployeePermissionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePermissionPayload>[]
          }
          upsert: {
            args: Prisma.EmployeePermissionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePermissionPayload>
          }
          aggregate: {
            args: Prisma.EmployeePermissionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmployeePermission>
          }
          groupBy: {
            args: Prisma.EmployeePermissionGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmployeePermissionGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmployeePermissionCountArgs<ExtArgs>
            result: $Utils.Optional<EmployeePermissionCountAggregateOutputType> | number
          }
        }
      }
      VendorGate: {
        payload: Prisma.$VendorGatePayload<ExtArgs>
        fields: Prisma.VendorGateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VendorGateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorGatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VendorGateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorGatePayload>
          }
          findFirst: {
            args: Prisma.VendorGateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorGatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VendorGateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorGatePayload>
          }
          findMany: {
            args: Prisma.VendorGateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorGatePayload>[]
          }
          create: {
            args: Prisma.VendorGateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorGatePayload>
          }
          createMany: {
            args: Prisma.VendorGateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VendorGateCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorGatePayload>[]
          }
          delete: {
            args: Prisma.VendorGateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorGatePayload>
          }
          update: {
            args: Prisma.VendorGateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorGatePayload>
          }
          deleteMany: {
            args: Prisma.VendorGateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VendorGateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VendorGateUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorGatePayload>[]
          }
          upsert: {
            args: Prisma.VendorGateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorGatePayload>
          }
          aggregate: {
            args: Prisma.VendorGateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVendorGate>
          }
          groupBy: {
            args: Prisma.VendorGateGroupByArgs<ExtArgs>
            result: $Utils.Optional<VendorGateGroupByOutputType>[]
          }
          count: {
            args: Prisma.VendorGateCountArgs<ExtArgs>
            result: $Utils.Optional<VendorGateCountAggregateOutputType> | number
          }
        }
      }
      VendorZone: {
        payload: Prisma.$VendorZonePayload<ExtArgs>
        fields: Prisma.VendorZoneFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VendorZoneFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorZonePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VendorZoneFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorZonePayload>
          }
          findFirst: {
            args: Prisma.VendorZoneFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorZonePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VendorZoneFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorZonePayload>
          }
          findMany: {
            args: Prisma.VendorZoneFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorZonePayload>[]
          }
          create: {
            args: Prisma.VendorZoneCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorZonePayload>
          }
          createMany: {
            args: Prisma.VendorZoneCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VendorZoneCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorZonePayload>[]
          }
          delete: {
            args: Prisma.VendorZoneDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorZonePayload>
          }
          update: {
            args: Prisma.VendorZoneUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorZonePayload>
          }
          deleteMany: {
            args: Prisma.VendorZoneDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VendorZoneUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VendorZoneUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorZonePayload>[]
          }
          upsert: {
            args: Prisma.VendorZoneUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorZonePayload>
          }
          aggregate: {
            args: Prisma.VendorZoneAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVendorZone>
          }
          groupBy: {
            args: Prisma.VendorZoneGroupByArgs<ExtArgs>
            result: $Utils.Optional<VendorZoneGroupByOutputType>[]
          }
          count: {
            args: Prisma.VendorZoneCountArgs<ExtArgs>
            result: $Utils.Optional<VendorZoneCountAggregateOutputType> | number
          }
        }
      }
      EmployeeGate: {
        payload: Prisma.$EmployeeGatePayload<ExtArgs>
        fields: Prisma.EmployeeGateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmployeeGateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeGatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmployeeGateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeGatePayload>
          }
          findFirst: {
            args: Prisma.EmployeeGateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeGatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmployeeGateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeGatePayload>
          }
          findMany: {
            args: Prisma.EmployeeGateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeGatePayload>[]
          }
          create: {
            args: Prisma.EmployeeGateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeGatePayload>
          }
          createMany: {
            args: Prisma.EmployeeGateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EmployeeGateCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeGatePayload>[]
          }
          delete: {
            args: Prisma.EmployeeGateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeGatePayload>
          }
          update: {
            args: Prisma.EmployeeGateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeGatePayload>
          }
          deleteMany: {
            args: Prisma.EmployeeGateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmployeeGateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EmployeeGateUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeGatePayload>[]
          }
          upsert: {
            args: Prisma.EmployeeGateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeGatePayload>
          }
          aggregate: {
            args: Prisma.EmployeeGateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmployeeGate>
          }
          groupBy: {
            args: Prisma.EmployeeGateGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmployeeGateGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmployeeGateCountArgs<ExtArgs>
            result: $Utils.Optional<EmployeeGateCountAggregateOutputType> | number
          }
        }
      }
      EmployeeZone: {
        payload: Prisma.$EmployeeZonePayload<ExtArgs>
        fields: Prisma.EmployeeZoneFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmployeeZoneFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeZonePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmployeeZoneFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeZonePayload>
          }
          findFirst: {
            args: Prisma.EmployeeZoneFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeZonePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmployeeZoneFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeZonePayload>
          }
          findMany: {
            args: Prisma.EmployeeZoneFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeZonePayload>[]
          }
          create: {
            args: Prisma.EmployeeZoneCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeZonePayload>
          }
          createMany: {
            args: Prisma.EmployeeZoneCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EmployeeZoneCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeZonePayload>[]
          }
          delete: {
            args: Prisma.EmployeeZoneDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeZonePayload>
          }
          update: {
            args: Prisma.EmployeeZoneUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeZonePayload>
          }
          deleteMany: {
            args: Prisma.EmployeeZoneDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmployeeZoneUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EmployeeZoneUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeZonePayload>[]
          }
          upsert: {
            args: Prisma.EmployeeZoneUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeZonePayload>
          }
          aggregate: {
            args: Prisma.EmployeeZoneAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmployeeZone>
          }
          groupBy: {
            args: Prisma.EmployeeZoneGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmployeeZoneGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmployeeZoneCountArgs<ExtArgs>
            result: $Utils.Optional<EmployeeZoneCountAggregateOutputType> | number
          }
        }
      }
      EmployeeAllowedDate: {
        payload: Prisma.$EmployeeAllowedDatePayload<ExtArgs>
        fields: Prisma.EmployeeAllowedDateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmployeeAllowedDateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeAllowedDatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmployeeAllowedDateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeAllowedDatePayload>
          }
          findFirst: {
            args: Prisma.EmployeeAllowedDateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeAllowedDatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmployeeAllowedDateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeAllowedDatePayload>
          }
          findMany: {
            args: Prisma.EmployeeAllowedDateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeAllowedDatePayload>[]
          }
          create: {
            args: Prisma.EmployeeAllowedDateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeAllowedDatePayload>
          }
          createMany: {
            args: Prisma.EmployeeAllowedDateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EmployeeAllowedDateCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeAllowedDatePayload>[]
          }
          delete: {
            args: Prisma.EmployeeAllowedDateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeAllowedDatePayload>
          }
          update: {
            args: Prisma.EmployeeAllowedDateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeAllowedDatePayload>
          }
          deleteMany: {
            args: Prisma.EmployeeAllowedDateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmployeeAllowedDateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EmployeeAllowedDateUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeAllowedDatePayload>[]
          }
          upsert: {
            args: Prisma.EmployeeAllowedDateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeAllowedDatePayload>
          }
          aggregate: {
            args: Prisma.EmployeeAllowedDateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmployeeAllowedDate>
          }
          groupBy: {
            args: Prisma.EmployeeAllowedDateGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmployeeAllowedDateGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmployeeAllowedDateCountArgs<ExtArgs>
            result: $Utils.Optional<EmployeeAllowedDateCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    vendor?: VendorOmit
    zone?: ZoneOmit
    gate?: GateOmit
    permission?: PermissionOmit
    employee?: EmployeeOmit
    workingHours?: WorkingHoursOmit
    alert?: AlertOmit
    activity?: ActivityOmit
    attachment?: AttachmentOmit
    vendorAttachment?: VendorAttachmentOmit
    employeeAttachment?: EmployeeAttachmentOmit
    employeePermission?: EmployeePermissionOmit
    vendorGate?: VendorGateOmit
    vendorZone?: VendorZoneOmit
    employeeGate?: EmployeeGateOmit
    employeeZone?: EmployeeZoneOmit
    employeeAllowedDate?: EmployeeAllowedDateOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    activities: number
    alerts: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    activities?: boolean | UserCountOutputTypeCountActivitiesArgs
    alerts?: boolean | UserCountOutputTypeCountAlertsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountActivitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAlertsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AlertWhereInput
  }


  /**
   * Count Type VendorCountOutputType
   */

  export type VendorCountOutputType = {
    employees: number
    vendorAttachments: number
    gates: number
    zones: number
  }

  export type VendorCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employees?: boolean | VendorCountOutputTypeCountEmployeesArgs
    vendorAttachments?: boolean | VendorCountOutputTypeCountVendorAttachmentsArgs
    gates?: boolean | VendorCountOutputTypeCountGatesArgs
    zones?: boolean | VendorCountOutputTypeCountZonesArgs
  }

  // Custom InputTypes
  /**
   * VendorCountOutputType without action
   */
  export type VendorCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorCountOutputType
     */
    select?: VendorCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * VendorCountOutputType without action
   */
  export type VendorCountOutputTypeCountEmployeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeWhereInput
  }

  /**
   * VendorCountOutputType without action
   */
  export type VendorCountOutputTypeCountVendorAttachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VendorAttachmentWhereInput
  }

  /**
   * VendorCountOutputType without action
   */
  export type VendorCountOutputTypeCountGatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VendorGateWhereInput
  }

  /**
   * VendorCountOutputType without action
   */
  export type VendorCountOutputTypeCountZonesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VendorZoneWhereInput
  }


  /**
   * Count Type ZoneCountOutputType
   */

  export type ZoneCountOutputType = {
    vendors: number
    employees: number
  }

  export type ZoneCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vendors?: boolean | ZoneCountOutputTypeCountVendorsArgs
    employees?: boolean | ZoneCountOutputTypeCountEmployeesArgs
  }

  // Custom InputTypes
  /**
   * ZoneCountOutputType without action
   */
  export type ZoneCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZoneCountOutputType
     */
    select?: ZoneCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ZoneCountOutputType without action
   */
  export type ZoneCountOutputTypeCountVendorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VendorZoneWhereInput
  }

  /**
   * ZoneCountOutputType without action
   */
  export type ZoneCountOutputTypeCountEmployeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeZoneWhereInput
  }


  /**
   * Count Type GateCountOutputType
   */

  export type GateCountOutputType = {
    vendors: number
    employees: number
    activities: number
  }

  export type GateCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vendors?: boolean | GateCountOutputTypeCountVendorsArgs
    employees?: boolean | GateCountOutputTypeCountEmployeesArgs
    activities?: boolean | GateCountOutputTypeCountActivitiesArgs
  }

  // Custom InputTypes
  /**
   * GateCountOutputType without action
   */
  export type GateCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GateCountOutputType
     */
    select?: GateCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * GateCountOutputType without action
   */
  export type GateCountOutputTypeCountVendorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VendorGateWhereInput
  }

  /**
   * GateCountOutputType without action
   */
  export type GateCountOutputTypeCountEmployeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeGateWhereInput
  }

  /**
   * GateCountOutputType without action
   */
  export type GateCountOutputTypeCountActivitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityWhereInput
  }


  /**
   * Count Type PermissionCountOutputType
   */

  export type PermissionCountOutputType = {
    employeePermissions: number
  }

  export type PermissionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employeePermissions?: boolean | PermissionCountOutputTypeCountEmployeePermissionsArgs
  }

  // Custom InputTypes
  /**
   * PermissionCountOutputType without action
   */
  export type PermissionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PermissionCountOutputType
     */
    select?: PermissionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PermissionCountOutputType without action
   */
  export type PermissionCountOutputTypeCountEmployeePermissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeePermissionWhereInput
  }


  /**
   * Count Type EmployeeCountOutputType
   */

  export type EmployeeCountOutputType = {
    gates: number
    zones: number
    activities: number
    workingHours: number
    employeeAttachments: number
    employeePermissions: number
    alerts: number
    allowedDates: number
  }

  export type EmployeeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    gates?: boolean | EmployeeCountOutputTypeCountGatesArgs
    zones?: boolean | EmployeeCountOutputTypeCountZonesArgs
    activities?: boolean | EmployeeCountOutputTypeCountActivitiesArgs
    workingHours?: boolean | EmployeeCountOutputTypeCountWorkingHoursArgs
    employeeAttachments?: boolean | EmployeeCountOutputTypeCountEmployeeAttachmentsArgs
    employeePermissions?: boolean | EmployeeCountOutputTypeCountEmployeePermissionsArgs
    alerts?: boolean | EmployeeCountOutputTypeCountAlertsArgs
    allowedDates?: boolean | EmployeeCountOutputTypeCountAllowedDatesArgs
  }

  // Custom InputTypes
  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeCountOutputType
     */
    select?: EmployeeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeCountGatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeGateWhereInput
  }

  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeCountZonesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeZoneWhereInput
  }

  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeCountActivitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityWhereInput
  }

  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeCountWorkingHoursArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkingHoursWhereInput
  }

  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeCountEmployeeAttachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeAttachmentWhereInput
  }

  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeCountEmployeePermissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeePermissionWhereInput
  }

  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeCountAlertsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AlertWhereInput
  }

  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeCountAllowedDatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeAllowedDateWhereInput
  }


  /**
   * Count Type ActivityCountOutputType
   */

  export type ActivityCountOutputType = {
    alerts: number
  }

  export type ActivityCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    alerts?: boolean | ActivityCountOutputTypeCountAlertsArgs
  }

  // Custom InputTypes
  /**
   * ActivityCountOutputType without action
   */
  export type ActivityCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityCountOutputType
     */
    select?: ActivityCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ActivityCountOutputType without action
   */
  export type ActivityCountOutputTypeCountAlertsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AlertWhereInput
  }


  /**
   * Count Type AttachmentCountOutputType
   */

  export type AttachmentCountOutputType = {
    vendorAttachments: number
    employeeAttachments: number
  }

  export type AttachmentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vendorAttachments?: boolean | AttachmentCountOutputTypeCountVendorAttachmentsArgs
    employeeAttachments?: boolean | AttachmentCountOutputTypeCountEmployeeAttachmentsArgs
  }

  // Custom InputTypes
  /**
   * AttachmentCountOutputType without action
   */
  export type AttachmentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttachmentCountOutputType
     */
    select?: AttachmentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AttachmentCountOutputType without action
   */
  export type AttachmentCountOutputTypeCountVendorAttachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VendorAttachmentWhereInput
  }

  /**
   * AttachmentCountOutputType without action
   */
  export type AttachmentCountOutputTypeCountEmployeeAttachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeAttachmentWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    name: string | null
    username: string | null
    email: string | null
    role: $Enums.Role | null
    password: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    name: string | null
    username: string | null
    email: string | null
    role: $Enums.Role | null
    password: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    name: number
    username: number
    email: number
    role: number
    password: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    name?: true
    username?: true
    email?: true
    role?: true
    password?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    name?: true
    username?: true
    email?: true
    role?: true
    password?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    name?: true
    username?: true
    email?: true
    role?: true
    password?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    name: string | null
    username: string | null
    email: string | null
    role: $Enums.Role
    password: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    username?: boolean
    email?: boolean
    role?: boolean
    password?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    activities?: boolean | User$activitiesArgs<ExtArgs>
    alerts?: boolean | User$alertsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    username?: boolean
    email?: boolean
    role?: boolean
    password?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    username?: boolean
    email?: boolean
    role?: boolean
    password?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    name?: boolean
    username?: boolean
    email?: boolean
    role?: boolean
    password?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "username" | "email" | "role" | "password" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    activities?: boolean | User$activitiesArgs<ExtArgs>
    alerts?: boolean | User$alertsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      activities: Prisma.$ActivityPayload<ExtArgs>[]
      alerts: Prisma.$AlertPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string | null
      username: string | null
      email: string | null
      role: $Enums.Role
      password: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    activities<T extends User$activitiesArgs<ExtArgs> = {}>(args?: Subset<T, User$activitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    alerts<T extends User$alertsArgs<ExtArgs> = {}>(args?: Subset<T, User$alertsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly username: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'Role'>
    readonly password: FieldRef<"User", 'String'>
    readonly isActive: FieldRef<"User", 'Boolean'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.activities
   */
  export type User$activitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    where?: ActivityWhereInput
    orderBy?: ActivityOrderByWithRelationInput | ActivityOrderByWithRelationInput[]
    cursor?: ActivityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ActivityScalarFieldEnum | ActivityScalarFieldEnum[]
  }

  /**
   * User.alerts
   */
  export type User$alertsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Alert
     */
    omit?: AlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertInclude<ExtArgs> | null
    where?: AlertWhereInput
    orderBy?: AlertOrderByWithRelationInput | AlertOrderByWithRelationInput[]
    cursor?: AlertWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AlertScalarFieldEnum | AlertScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Vendor
   */

  export type AggregateVendor = {
    _count: VendorCountAggregateOutputType | null
    _avg: VendorAvgAggregateOutputType | null
    _sum: VendorSumAggregateOutputType | null
    _min: VendorMinAggregateOutputType | null
    _max: VendorMaxAggregateOutputType | null
  }

  export type VendorAvgAggregateOutputType = {
    allowedStaffCount: number | null
  }

  export type VendorSumAggregateOutputType = {
    allowedStaffCount: number | null
  }

  export type VendorMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    phoneNumber: string | null
    allowedStaffCount: number | null
    accessToken: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type VendorMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    phoneNumber: string | null
    allowedStaffCount: number | null
    accessToken: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type VendorCountAggregateOutputType = {
    id: number
    name: number
    description: number
    phoneNumber: number
    allowedStaffCount: number
    accessToken: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type VendorAvgAggregateInputType = {
    allowedStaffCount?: true
  }

  export type VendorSumAggregateInputType = {
    allowedStaffCount?: true
  }

  export type VendorMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    phoneNumber?: true
    allowedStaffCount?: true
    accessToken?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type VendorMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    phoneNumber?: true
    allowedStaffCount?: true
    accessToken?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type VendorCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    phoneNumber?: true
    allowedStaffCount?: true
    accessToken?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type VendorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Vendor to aggregate.
     */
    where?: VendorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vendors to fetch.
     */
    orderBy?: VendorOrderByWithRelationInput | VendorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VendorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vendors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vendors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Vendors
    **/
    _count?: true | VendorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VendorAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VendorSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VendorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VendorMaxAggregateInputType
  }

  export type GetVendorAggregateType<T extends VendorAggregateArgs> = {
        [P in keyof T & keyof AggregateVendor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVendor[P]>
      : GetScalarType<T[P], AggregateVendor[P]>
  }




  export type VendorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VendorWhereInput
    orderBy?: VendorOrderByWithAggregationInput | VendorOrderByWithAggregationInput[]
    by: VendorScalarFieldEnum[] | VendorScalarFieldEnum
    having?: VendorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VendorCountAggregateInputType | true
    _avg?: VendorAvgAggregateInputType
    _sum?: VendorSumAggregateInputType
    _min?: VendorMinAggregateInputType
    _max?: VendorMaxAggregateInputType
  }

  export type VendorGroupByOutputType = {
    id: string
    name: string
    description: string | null
    phoneNumber: string | null
    allowedStaffCount: number
    accessToken: string
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: VendorCountAggregateOutputType | null
    _avg: VendorAvgAggregateOutputType | null
    _sum: VendorSumAggregateOutputType | null
    _min: VendorMinAggregateOutputType | null
    _max: VendorMaxAggregateOutputType | null
  }

  type GetVendorGroupByPayload<T extends VendorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VendorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VendorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VendorGroupByOutputType[P]>
            : GetScalarType<T[P], VendorGroupByOutputType[P]>
        }
      >
    >


  export type VendorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    phoneNumber?: boolean
    allowedStaffCount?: boolean
    accessToken?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    employees?: boolean | Vendor$employeesArgs<ExtArgs>
    vendorAttachments?: boolean | Vendor$vendorAttachmentsArgs<ExtArgs>
    gates?: boolean | Vendor$gatesArgs<ExtArgs>
    zones?: boolean | Vendor$zonesArgs<ExtArgs>
    _count?: boolean | VendorCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vendor"]>

  export type VendorSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    phoneNumber?: boolean
    allowedStaffCount?: boolean
    accessToken?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }, ExtArgs["result"]["vendor"]>

  export type VendorSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    phoneNumber?: boolean
    allowedStaffCount?: boolean
    accessToken?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }, ExtArgs["result"]["vendor"]>

  export type VendorSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    phoneNumber?: boolean
    allowedStaffCount?: boolean
    accessToken?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type VendorOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "phoneNumber" | "allowedStaffCount" | "accessToken" | "createdAt" | "updatedAt" | "deletedAt", ExtArgs["result"]["vendor"]>
  export type VendorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employees?: boolean | Vendor$employeesArgs<ExtArgs>
    vendorAttachments?: boolean | Vendor$vendorAttachmentsArgs<ExtArgs>
    gates?: boolean | Vendor$gatesArgs<ExtArgs>
    zones?: boolean | Vendor$zonesArgs<ExtArgs>
    _count?: boolean | VendorCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type VendorIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type VendorIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $VendorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Vendor"
    objects: {
      employees: Prisma.$EmployeePayload<ExtArgs>[]
      vendorAttachments: Prisma.$VendorAttachmentPayload<ExtArgs>[]
      gates: Prisma.$VendorGatePayload<ExtArgs>[]
      zones: Prisma.$VendorZonePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      phoneNumber: string | null
      allowedStaffCount: number
      accessToken: string
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["vendor"]>
    composites: {}
  }

  type VendorGetPayload<S extends boolean | null | undefined | VendorDefaultArgs> = $Result.GetResult<Prisma.$VendorPayload, S>

  type VendorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VendorFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VendorCountAggregateInputType | true
    }

  export interface VendorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Vendor'], meta: { name: 'Vendor' } }
    /**
     * Find zero or one Vendor that matches the filter.
     * @param {VendorFindUniqueArgs} args - Arguments to find a Vendor
     * @example
     * // Get one Vendor
     * const vendor = await prisma.vendor.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VendorFindUniqueArgs>(args: SelectSubset<T, VendorFindUniqueArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Vendor that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VendorFindUniqueOrThrowArgs} args - Arguments to find a Vendor
     * @example
     * // Get one Vendor
     * const vendor = await prisma.vendor.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VendorFindUniqueOrThrowArgs>(args: SelectSubset<T, VendorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Vendor that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorFindFirstArgs} args - Arguments to find a Vendor
     * @example
     * // Get one Vendor
     * const vendor = await prisma.vendor.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VendorFindFirstArgs>(args?: SelectSubset<T, VendorFindFirstArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Vendor that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorFindFirstOrThrowArgs} args - Arguments to find a Vendor
     * @example
     * // Get one Vendor
     * const vendor = await prisma.vendor.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VendorFindFirstOrThrowArgs>(args?: SelectSubset<T, VendorFindFirstOrThrowArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Vendors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Vendors
     * const vendors = await prisma.vendor.findMany()
     * 
     * // Get first 10 Vendors
     * const vendors = await prisma.vendor.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const vendorWithIdOnly = await prisma.vendor.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VendorFindManyArgs>(args?: SelectSubset<T, VendorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Vendor.
     * @param {VendorCreateArgs} args - Arguments to create a Vendor.
     * @example
     * // Create one Vendor
     * const Vendor = await prisma.vendor.create({
     *   data: {
     *     // ... data to create a Vendor
     *   }
     * })
     * 
     */
    create<T extends VendorCreateArgs>(args: SelectSubset<T, VendorCreateArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Vendors.
     * @param {VendorCreateManyArgs} args - Arguments to create many Vendors.
     * @example
     * // Create many Vendors
     * const vendor = await prisma.vendor.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VendorCreateManyArgs>(args?: SelectSubset<T, VendorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Vendors and returns the data saved in the database.
     * @param {VendorCreateManyAndReturnArgs} args - Arguments to create many Vendors.
     * @example
     * // Create many Vendors
     * const vendor = await prisma.vendor.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Vendors and only return the `id`
     * const vendorWithIdOnly = await prisma.vendor.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VendorCreateManyAndReturnArgs>(args?: SelectSubset<T, VendorCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Vendor.
     * @param {VendorDeleteArgs} args - Arguments to delete one Vendor.
     * @example
     * // Delete one Vendor
     * const Vendor = await prisma.vendor.delete({
     *   where: {
     *     // ... filter to delete one Vendor
     *   }
     * })
     * 
     */
    delete<T extends VendorDeleteArgs>(args: SelectSubset<T, VendorDeleteArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Vendor.
     * @param {VendorUpdateArgs} args - Arguments to update one Vendor.
     * @example
     * // Update one Vendor
     * const vendor = await prisma.vendor.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VendorUpdateArgs>(args: SelectSubset<T, VendorUpdateArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Vendors.
     * @param {VendorDeleteManyArgs} args - Arguments to filter Vendors to delete.
     * @example
     * // Delete a few Vendors
     * const { count } = await prisma.vendor.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VendorDeleteManyArgs>(args?: SelectSubset<T, VendorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Vendors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Vendors
     * const vendor = await prisma.vendor.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VendorUpdateManyArgs>(args: SelectSubset<T, VendorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Vendors and returns the data updated in the database.
     * @param {VendorUpdateManyAndReturnArgs} args - Arguments to update many Vendors.
     * @example
     * // Update many Vendors
     * const vendor = await prisma.vendor.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Vendors and only return the `id`
     * const vendorWithIdOnly = await prisma.vendor.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VendorUpdateManyAndReturnArgs>(args: SelectSubset<T, VendorUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Vendor.
     * @param {VendorUpsertArgs} args - Arguments to update or create a Vendor.
     * @example
     * // Update or create a Vendor
     * const vendor = await prisma.vendor.upsert({
     *   create: {
     *     // ... data to create a Vendor
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Vendor we want to update
     *   }
     * })
     */
    upsert<T extends VendorUpsertArgs>(args: SelectSubset<T, VendorUpsertArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Vendors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorCountArgs} args - Arguments to filter Vendors to count.
     * @example
     * // Count the number of Vendors
     * const count = await prisma.vendor.count({
     *   where: {
     *     // ... the filter for the Vendors we want to count
     *   }
     * })
    **/
    count<T extends VendorCountArgs>(
      args?: Subset<T, VendorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VendorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Vendor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VendorAggregateArgs>(args: Subset<T, VendorAggregateArgs>): Prisma.PrismaPromise<GetVendorAggregateType<T>>

    /**
     * Group by Vendor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VendorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VendorGroupByArgs['orderBy'] }
        : { orderBy?: VendorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VendorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVendorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Vendor model
   */
  readonly fields: VendorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Vendor.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VendorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    employees<T extends Vendor$employeesArgs<ExtArgs> = {}>(args?: Subset<T, Vendor$employeesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    vendorAttachments<T extends Vendor$vendorAttachmentsArgs<ExtArgs> = {}>(args?: Subset<T, Vendor$vendorAttachmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VendorAttachmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    gates<T extends Vendor$gatesArgs<ExtArgs> = {}>(args?: Subset<T, Vendor$gatesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VendorGatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    zones<T extends Vendor$zonesArgs<ExtArgs> = {}>(args?: Subset<T, Vendor$zonesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VendorZonePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Vendor model
   */
  interface VendorFieldRefs {
    readonly id: FieldRef<"Vendor", 'String'>
    readonly name: FieldRef<"Vendor", 'String'>
    readonly description: FieldRef<"Vendor", 'String'>
    readonly phoneNumber: FieldRef<"Vendor", 'String'>
    readonly allowedStaffCount: FieldRef<"Vendor", 'Int'>
    readonly accessToken: FieldRef<"Vendor", 'String'>
    readonly createdAt: FieldRef<"Vendor", 'DateTime'>
    readonly updatedAt: FieldRef<"Vendor", 'DateTime'>
    readonly deletedAt: FieldRef<"Vendor", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Vendor findUnique
   */
  export type VendorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vendor
     */
    omit?: VendorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    /**
     * Filter, which Vendor to fetch.
     */
    where: VendorWhereUniqueInput
  }

  /**
   * Vendor findUniqueOrThrow
   */
  export type VendorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vendor
     */
    omit?: VendorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    /**
     * Filter, which Vendor to fetch.
     */
    where: VendorWhereUniqueInput
  }

  /**
   * Vendor findFirst
   */
  export type VendorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vendor
     */
    omit?: VendorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    /**
     * Filter, which Vendor to fetch.
     */
    where?: VendorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vendors to fetch.
     */
    orderBy?: VendorOrderByWithRelationInput | VendorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Vendors.
     */
    cursor?: VendorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vendors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vendors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Vendors.
     */
    distinct?: VendorScalarFieldEnum | VendorScalarFieldEnum[]
  }

  /**
   * Vendor findFirstOrThrow
   */
  export type VendorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vendor
     */
    omit?: VendorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    /**
     * Filter, which Vendor to fetch.
     */
    where?: VendorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vendors to fetch.
     */
    orderBy?: VendorOrderByWithRelationInput | VendorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Vendors.
     */
    cursor?: VendorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vendors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vendors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Vendors.
     */
    distinct?: VendorScalarFieldEnum | VendorScalarFieldEnum[]
  }

  /**
   * Vendor findMany
   */
  export type VendorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vendor
     */
    omit?: VendorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    /**
     * Filter, which Vendors to fetch.
     */
    where?: VendorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vendors to fetch.
     */
    orderBy?: VendorOrderByWithRelationInput | VendorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Vendors.
     */
    cursor?: VendorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vendors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vendors.
     */
    skip?: number
    distinct?: VendorScalarFieldEnum | VendorScalarFieldEnum[]
  }

  /**
   * Vendor create
   */
  export type VendorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vendor
     */
    omit?: VendorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    /**
     * The data needed to create a Vendor.
     */
    data: XOR<VendorCreateInput, VendorUncheckedCreateInput>
  }

  /**
   * Vendor createMany
   */
  export type VendorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Vendors.
     */
    data: VendorCreateManyInput | VendorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Vendor createManyAndReturn
   */
  export type VendorCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Vendor
     */
    omit?: VendorOmit<ExtArgs> | null
    /**
     * The data used to create many Vendors.
     */
    data: VendorCreateManyInput | VendorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Vendor update
   */
  export type VendorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vendor
     */
    omit?: VendorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    /**
     * The data needed to update a Vendor.
     */
    data: XOR<VendorUpdateInput, VendorUncheckedUpdateInput>
    /**
     * Choose, which Vendor to update.
     */
    where: VendorWhereUniqueInput
  }

  /**
   * Vendor updateMany
   */
  export type VendorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Vendors.
     */
    data: XOR<VendorUpdateManyMutationInput, VendorUncheckedUpdateManyInput>
    /**
     * Filter which Vendors to update
     */
    where?: VendorWhereInput
    /**
     * Limit how many Vendors to update.
     */
    limit?: number
  }

  /**
   * Vendor updateManyAndReturn
   */
  export type VendorUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Vendor
     */
    omit?: VendorOmit<ExtArgs> | null
    /**
     * The data used to update Vendors.
     */
    data: XOR<VendorUpdateManyMutationInput, VendorUncheckedUpdateManyInput>
    /**
     * Filter which Vendors to update
     */
    where?: VendorWhereInput
    /**
     * Limit how many Vendors to update.
     */
    limit?: number
  }

  /**
   * Vendor upsert
   */
  export type VendorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vendor
     */
    omit?: VendorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    /**
     * The filter to search for the Vendor to update in case it exists.
     */
    where: VendorWhereUniqueInput
    /**
     * In case the Vendor found by the `where` argument doesn't exist, create a new Vendor with this data.
     */
    create: XOR<VendorCreateInput, VendorUncheckedCreateInput>
    /**
     * In case the Vendor was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VendorUpdateInput, VendorUncheckedUpdateInput>
  }

  /**
   * Vendor delete
   */
  export type VendorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vendor
     */
    omit?: VendorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    /**
     * Filter which Vendor to delete.
     */
    where: VendorWhereUniqueInput
  }

  /**
   * Vendor deleteMany
   */
  export type VendorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Vendors to delete
     */
    where?: VendorWhereInput
    /**
     * Limit how many Vendors to delete.
     */
    limit?: number
  }

  /**
   * Vendor.employees
   */
  export type Vendor$employeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    where?: EmployeeWhereInput
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    cursor?: EmployeeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmployeeScalarFieldEnum | EmployeeScalarFieldEnum[]
  }

  /**
   * Vendor.vendorAttachments
   */
  export type Vendor$vendorAttachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorAttachment
     */
    select?: VendorAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorAttachment
     */
    omit?: VendorAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorAttachmentInclude<ExtArgs> | null
    where?: VendorAttachmentWhereInput
    orderBy?: VendorAttachmentOrderByWithRelationInput | VendorAttachmentOrderByWithRelationInput[]
    cursor?: VendorAttachmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VendorAttachmentScalarFieldEnum | VendorAttachmentScalarFieldEnum[]
  }

  /**
   * Vendor.gates
   */
  export type Vendor$gatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorGate
     */
    select?: VendorGateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorGate
     */
    omit?: VendorGateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorGateInclude<ExtArgs> | null
    where?: VendorGateWhereInput
    orderBy?: VendorGateOrderByWithRelationInput | VendorGateOrderByWithRelationInput[]
    cursor?: VendorGateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VendorGateScalarFieldEnum | VendorGateScalarFieldEnum[]
  }

  /**
   * Vendor.zones
   */
  export type Vendor$zonesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorZone
     */
    select?: VendorZoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorZone
     */
    omit?: VendorZoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorZoneInclude<ExtArgs> | null
    where?: VendorZoneWhereInput
    orderBy?: VendorZoneOrderByWithRelationInput | VendorZoneOrderByWithRelationInput[]
    cursor?: VendorZoneWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VendorZoneScalarFieldEnum | VendorZoneScalarFieldEnum[]
  }

  /**
   * Vendor without action
   */
  export type VendorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vendor
     */
    omit?: VendorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
  }


  /**
   * Model Zone
   */

  export type AggregateZone = {
    _count: ZoneCountAggregateOutputType | null
    _min: ZoneMinAggregateOutputType | null
    _max: ZoneMaxAggregateOutputType | null
  }

  export type ZoneMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type ZoneMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type ZoneCountAggregateOutputType = {
    id: number
    name: number
    description: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type ZoneMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type ZoneMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type ZoneCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type ZoneAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Zone to aggregate.
     */
    where?: ZoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Zones to fetch.
     */
    orderBy?: ZoneOrderByWithRelationInput | ZoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ZoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Zones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Zones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Zones
    **/
    _count?: true | ZoneCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ZoneMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ZoneMaxAggregateInputType
  }

  export type GetZoneAggregateType<T extends ZoneAggregateArgs> = {
        [P in keyof T & keyof AggregateZone]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateZone[P]>
      : GetScalarType<T[P], AggregateZone[P]>
  }




  export type ZoneGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ZoneWhereInput
    orderBy?: ZoneOrderByWithAggregationInput | ZoneOrderByWithAggregationInput[]
    by: ZoneScalarFieldEnum[] | ZoneScalarFieldEnum
    having?: ZoneScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ZoneCountAggregateInputType | true
    _min?: ZoneMinAggregateInputType
    _max?: ZoneMaxAggregateInputType
  }

  export type ZoneGroupByOutputType = {
    id: string
    name: string
    description: string | null
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: ZoneCountAggregateOutputType | null
    _min: ZoneMinAggregateOutputType | null
    _max: ZoneMaxAggregateOutputType | null
  }

  type GetZoneGroupByPayload<T extends ZoneGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ZoneGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ZoneGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ZoneGroupByOutputType[P]>
            : GetScalarType<T[P], ZoneGroupByOutputType[P]>
        }
      >
    >


  export type ZoneSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    vendors?: boolean | Zone$vendorsArgs<ExtArgs>
    employees?: boolean | Zone$employeesArgs<ExtArgs>
    _count?: boolean | ZoneCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["zone"]>

  export type ZoneSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }, ExtArgs["result"]["zone"]>

  export type ZoneSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }, ExtArgs["result"]["zone"]>

  export type ZoneSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type ZoneOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "createdAt" | "updatedAt" | "deletedAt", ExtArgs["result"]["zone"]>
  export type ZoneInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vendors?: boolean | Zone$vendorsArgs<ExtArgs>
    employees?: boolean | Zone$employeesArgs<ExtArgs>
    _count?: boolean | ZoneCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ZoneIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ZoneIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ZonePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Zone"
    objects: {
      vendors: Prisma.$VendorZonePayload<ExtArgs>[]
      employees: Prisma.$EmployeeZonePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["zone"]>
    composites: {}
  }

  type ZoneGetPayload<S extends boolean | null | undefined | ZoneDefaultArgs> = $Result.GetResult<Prisma.$ZonePayload, S>

  type ZoneCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ZoneFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ZoneCountAggregateInputType | true
    }

  export interface ZoneDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Zone'], meta: { name: 'Zone' } }
    /**
     * Find zero or one Zone that matches the filter.
     * @param {ZoneFindUniqueArgs} args - Arguments to find a Zone
     * @example
     * // Get one Zone
     * const zone = await prisma.zone.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ZoneFindUniqueArgs>(args: SelectSubset<T, ZoneFindUniqueArgs<ExtArgs>>): Prisma__ZoneClient<$Result.GetResult<Prisma.$ZonePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Zone that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ZoneFindUniqueOrThrowArgs} args - Arguments to find a Zone
     * @example
     * // Get one Zone
     * const zone = await prisma.zone.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ZoneFindUniqueOrThrowArgs>(args: SelectSubset<T, ZoneFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ZoneClient<$Result.GetResult<Prisma.$ZonePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Zone that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZoneFindFirstArgs} args - Arguments to find a Zone
     * @example
     * // Get one Zone
     * const zone = await prisma.zone.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ZoneFindFirstArgs>(args?: SelectSubset<T, ZoneFindFirstArgs<ExtArgs>>): Prisma__ZoneClient<$Result.GetResult<Prisma.$ZonePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Zone that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZoneFindFirstOrThrowArgs} args - Arguments to find a Zone
     * @example
     * // Get one Zone
     * const zone = await prisma.zone.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ZoneFindFirstOrThrowArgs>(args?: SelectSubset<T, ZoneFindFirstOrThrowArgs<ExtArgs>>): Prisma__ZoneClient<$Result.GetResult<Prisma.$ZonePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Zones that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZoneFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Zones
     * const zones = await prisma.zone.findMany()
     * 
     * // Get first 10 Zones
     * const zones = await prisma.zone.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const zoneWithIdOnly = await prisma.zone.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ZoneFindManyArgs>(args?: SelectSubset<T, ZoneFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ZonePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Zone.
     * @param {ZoneCreateArgs} args - Arguments to create a Zone.
     * @example
     * // Create one Zone
     * const Zone = await prisma.zone.create({
     *   data: {
     *     // ... data to create a Zone
     *   }
     * })
     * 
     */
    create<T extends ZoneCreateArgs>(args: SelectSubset<T, ZoneCreateArgs<ExtArgs>>): Prisma__ZoneClient<$Result.GetResult<Prisma.$ZonePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Zones.
     * @param {ZoneCreateManyArgs} args - Arguments to create many Zones.
     * @example
     * // Create many Zones
     * const zone = await prisma.zone.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ZoneCreateManyArgs>(args?: SelectSubset<T, ZoneCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Zones and returns the data saved in the database.
     * @param {ZoneCreateManyAndReturnArgs} args - Arguments to create many Zones.
     * @example
     * // Create many Zones
     * const zone = await prisma.zone.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Zones and only return the `id`
     * const zoneWithIdOnly = await prisma.zone.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ZoneCreateManyAndReturnArgs>(args?: SelectSubset<T, ZoneCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ZonePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Zone.
     * @param {ZoneDeleteArgs} args - Arguments to delete one Zone.
     * @example
     * // Delete one Zone
     * const Zone = await prisma.zone.delete({
     *   where: {
     *     // ... filter to delete one Zone
     *   }
     * })
     * 
     */
    delete<T extends ZoneDeleteArgs>(args: SelectSubset<T, ZoneDeleteArgs<ExtArgs>>): Prisma__ZoneClient<$Result.GetResult<Prisma.$ZonePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Zone.
     * @param {ZoneUpdateArgs} args - Arguments to update one Zone.
     * @example
     * // Update one Zone
     * const zone = await prisma.zone.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ZoneUpdateArgs>(args: SelectSubset<T, ZoneUpdateArgs<ExtArgs>>): Prisma__ZoneClient<$Result.GetResult<Prisma.$ZonePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Zones.
     * @param {ZoneDeleteManyArgs} args - Arguments to filter Zones to delete.
     * @example
     * // Delete a few Zones
     * const { count } = await prisma.zone.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ZoneDeleteManyArgs>(args?: SelectSubset<T, ZoneDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Zones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZoneUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Zones
     * const zone = await prisma.zone.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ZoneUpdateManyArgs>(args: SelectSubset<T, ZoneUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Zones and returns the data updated in the database.
     * @param {ZoneUpdateManyAndReturnArgs} args - Arguments to update many Zones.
     * @example
     * // Update many Zones
     * const zone = await prisma.zone.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Zones and only return the `id`
     * const zoneWithIdOnly = await prisma.zone.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ZoneUpdateManyAndReturnArgs>(args: SelectSubset<T, ZoneUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ZonePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Zone.
     * @param {ZoneUpsertArgs} args - Arguments to update or create a Zone.
     * @example
     * // Update or create a Zone
     * const zone = await prisma.zone.upsert({
     *   create: {
     *     // ... data to create a Zone
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Zone we want to update
     *   }
     * })
     */
    upsert<T extends ZoneUpsertArgs>(args: SelectSubset<T, ZoneUpsertArgs<ExtArgs>>): Prisma__ZoneClient<$Result.GetResult<Prisma.$ZonePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Zones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZoneCountArgs} args - Arguments to filter Zones to count.
     * @example
     * // Count the number of Zones
     * const count = await prisma.zone.count({
     *   where: {
     *     // ... the filter for the Zones we want to count
     *   }
     * })
    **/
    count<T extends ZoneCountArgs>(
      args?: Subset<T, ZoneCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ZoneCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Zone.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZoneAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ZoneAggregateArgs>(args: Subset<T, ZoneAggregateArgs>): Prisma.PrismaPromise<GetZoneAggregateType<T>>

    /**
     * Group by Zone.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZoneGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ZoneGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ZoneGroupByArgs['orderBy'] }
        : { orderBy?: ZoneGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ZoneGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetZoneGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Zone model
   */
  readonly fields: ZoneFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Zone.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ZoneClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    vendors<T extends Zone$vendorsArgs<ExtArgs> = {}>(args?: Subset<T, Zone$vendorsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VendorZonePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    employees<T extends Zone$employeesArgs<ExtArgs> = {}>(args?: Subset<T, Zone$employeesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeeZonePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Zone model
   */
  interface ZoneFieldRefs {
    readonly id: FieldRef<"Zone", 'String'>
    readonly name: FieldRef<"Zone", 'String'>
    readonly description: FieldRef<"Zone", 'String'>
    readonly createdAt: FieldRef<"Zone", 'DateTime'>
    readonly updatedAt: FieldRef<"Zone", 'DateTime'>
    readonly deletedAt: FieldRef<"Zone", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Zone findUnique
   */
  export type ZoneFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Zone
     */
    select?: ZoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Zone
     */
    omit?: ZoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoneInclude<ExtArgs> | null
    /**
     * Filter, which Zone to fetch.
     */
    where: ZoneWhereUniqueInput
  }

  /**
   * Zone findUniqueOrThrow
   */
  export type ZoneFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Zone
     */
    select?: ZoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Zone
     */
    omit?: ZoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoneInclude<ExtArgs> | null
    /**
     * Filter, which Zone to fetch.
     */
    where: ZoneWhereUniqueInput
  }

  /**
   * Zone findFirst
   */
  export type ZoneFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Zone
     */
    select?: ZoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Zone
     */
    omit?: ZoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoneInclude<ExtArgs> | null
    /**
     * Filter, which Zone to fetch.
     */
    where?: ZoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Zones to fetch.
     */
    orderBy?: ZoneOrderByWithRelationInput | ZoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Zones.
     */
    cursor?: ZoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Zones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Zones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Zones.
     */
    distinct?: ZoneScalarFieldEnum | ZoneScalarFieldEnum[]
  }

  /**
   * Zone findFirstOrThrow
   */
  export type ZoneFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Zone
     */
    select?: ZoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Zone
     */
    omit?: ZoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoneInclude<ExtArgs> | null
    /**
     * Filter, which Zone to fetch.
     */
    where?: ZoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Zones to fetch.
     */
    orderBy?: ZoneOrderByWithRelationInput | ZoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Zones.
     */
    cursor?: ZoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Zones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Zones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Zones.
     */
    distinct?: ZoneScalarFieldEnum | ZoneScalarFieldEnum[]
  }

  /**
   * Zone findMany
   */
  export type ZoneFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Zone
     */
    select?: ZoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Zone
     */
    omit?: ZoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoneInclude<ExtArgs> | null
    /**
     * Filter, which Zones to fetch.
     */
    where?: ZoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Zones to fetch.
     */
    orderBy?: ZoneOrderByWithRelationInput | ZoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Zones.
     */
    cursor?: ZoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Zones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Zones.
     */
    skip?: number
    distinct?: ZoneScalarFieldEnum | ZoneScalarFieldEnum[]
  }

  /**
   * Zone create
   */
  export type ZoneCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Zone
     */
    select?: ZoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Zone
     */
    omit?: ZoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoneInclude<ExtArgs> | null
    /**
     * The data needed to create a Zone.
     */
    data: XOR<ZoneCreateInput, ZoneUncheckedCreateInput>
  }

  /**
   * Zone createMany
   */
  export type ZoneCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Zones.
     */
    data: ZoneCreateManyInput | ZoneCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Zone createManyAndReturn
   */
  export type ZoneCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Zone
     */
    select?: ZoneSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Zone
     */
    omit?: ZoneOmit<ExtArgs> | null
    /**
     * The data used to create many Zones.
     */
    data: ZoneCreateManyInput | ZoneCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Zone update
   */
  export type ZoneUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Zone
     */
    select?: ZoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Zone
     */
    omit?: ZoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoneInclude<ExtArgs> | null
    /**
     * The data needed to update a Zone.
     */
    data: XOR<ZoneUpdateInput, ZoneUncheckedUpdateInput>
    /**
     * Choose, which Zone to update.
     */
    where: ZoneWhereUniqueInput
  }

  /**
   * Zone updateMany
   */
  export type ZoneUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Zones.
     */
    data: XOR<ZoneUpdateManyMutationInput, ZoneUncheckedUpdateManyInput>
    /**
     * Filter which Zones to update
     */
    where?: ZoneWhereInput
    /**
     * Limit how many Zones to update.
     */
    limit?: number
  }

  /**
   * Zone updateManyAndReturn
   */
  export type ZoneUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Zone
     */
    select?: ZoneSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Zone
     */
    omit?: ZoneOmit<ExtArgs> | null
    /**
     * The data used to update Zones.
     */
    data: XOR<ZoneUpdateManyMutationInput, ZoneUncheckedUpdateManyInput>
    /**
     * Filter which Zones to update
     */
    where?: ZoneWhereInput
    /**
     * Limit how many Zones to update.
     */
    limit?: number
  }

  /**
   * Zone upsert
   */
  export type ZoneUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Zone
     */
    select?: ZoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Zone
     */
    omit?: ZoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoneInclude<ExtArgs> | null
    /**
     * The filter to search for the Zone to update in case it exists.
     */
    where: ZoneWhereUniqueInput
    /**
     * In case the Zone found by the `where` argument doesn't exist, create a new Zone with this data.
     */
    create: XOR<ZoneCreateInput, ZoneUncheckedCreateInput>
    /**
     * In case the Zone was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ZoneUpdateInput, ZoneUncheckedUpdateInput>
  }

  /**
   * Zone delete
   */
  export type ZoneDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Zone
     */
    select?: ZoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Zone
     */
    omit?: ZoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoneInclude<ExtArgs> | null
    /**
     * Filter which Zone to delete.
     */
    where: ZoneWhereUniqueInput
  }

  /**
   * Zone deleteMany
   */
  export type ZoneDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Zones to delete
     */
    where?: ZoneWhereInput
    /**
     * Limit how many Zones to delete.
     */
    limit?: number
  }

  /**
   * Zone.vendors
   */
  export type Zone$vendorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorZone
     */
    select?: VendorZoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorZone
     */
    omit?: VendorZoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorZoneInclude<ExtArgs> | null
    where?: VendorZoneWhereInput
    orderBy?: VendorZoneOrderByWithRelationInput | VendorZoneOrderByWithRelationInput[]
    cursor?: VendorZoneWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VendorZoneScalarFieldEnum | VendorZoneScalarFieldEnum[]
  }

  /**
   * Zone.employees
   */
  export type Zone$employeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeZone
     */
    select?: EmployeeZoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeZone
     */
    omit?: EmployeeZoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeZoneInclude<ExtArgs> | null
    where?: EmployeeZoneWhereInput
    orderBy?: EmployeeZoneOrderByWithRelationInput | EmployeeZoneOrderByWithRelationInput[]
    cursor?: EmployeeZoneWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmployeeZoneScalarFieldEnum | EmployeeZoneScalarFieldEnum[]
  }

  /**
   * Zone without action
   */
  export type ZoneDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Zone
     */
    select?: ZoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Zone
     */
    omit?: ZoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoneInclude<ExtArgs> | null
  }


  /**
   * Model Gate
   */

  export type AggregateGate = {
    _count: GateCountAggregateOutputType | null
    _min: GateMinAggregateOutputType | null
    _max: GateMaxAggregateOutputType | null
  }

  export type GateMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type GateMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type GateCountAggregateOutputType = {
    id: number
    name: number
    description: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type GateMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type GateMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type GateCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type GateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Gate to aggregate.
     */
    where?: GateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Gates to fetch.
     */
    orderBy?: GateOrderByWithRelationInput | GateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Gates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Gates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Gates
    **/
    _count?: true | GateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GateMaxAggregateInputType
  }

  export type GetGateAggregateType<T extends GateAggregateArgs> = {
        [P in keyof T & keyof AggregateGate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGate[P]>
      : GetScalarType<T[P], AggregateGate[P]>
  }




  export type GateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GateWhereInput
    orderBy?: GateOrderByWithAggregationInput | GateOrderByWithAggregationInput[]
    by: GateScalarFieldEnum[] | GateScalarFieldEnum
    having?: GateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GateCountAggregateInputType | true
    _min?: GateMinAggregateInputType
    _max?: GateMaxAggregateInputType
  }

  export type GateGroupByOutputType = {
    id: string
    name: string
    description: string | null
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: GateCountAggregateOutputType | null
    _min: GateMinAggregateOutputType | null
    _max: GateMaxAggregateOutputType | null
  }

  type GetGateGroupByPayload<T extends GateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GateGroupByOutputType[P]>
            : GetScalarType<T[P], GateGroupByOutputType[P]>
        }
      >
    >


  export type GateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    vendors?: boolean | Gate$vendorsArgs<ExtArgs>
    employees?: boolean | Gate$employeesArgs<ExtArgs>
    activities?: boolean | Gate$activitiesArgs<ExtArgs>
    _count?: boolean | GateCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gate"]>

  export type GateSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }, ExtArgs["result"]["gate"]>

  export type GateSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }, ExtArgs["result"]["gate"]>

  export type GateSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type GateOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "createdAt" | "updatedAt" | "deletedAt", ExtArgs["result"]["gate"]>
  export type GateInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vendors?: boolean | Gate$vendorsArgs<ExtArgs>
    employees?: boolean | Gate$employeesArgs<ExtArgs>
    activities?: boolean | Gate$activitiesArgs<ExtArgs>
    _count?: boolean | GateCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type GateIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type GateIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $GatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Gate"
    objects: {
      vendors: Prisma.$VendorGatePayload<ExtArgs>[]
      employees: Prisma.$EmployeeGatePayload<ExtArgs>[]
      activities: Prisma.$ActivityPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["gate"]>
    composites: {}
  }

  type GateGetPayload<S extends boolean | null | undefined | GateDefaultArgs> = $Result.GetResult<Prisma.$GatePayload, S>

  type GateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GateFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GateCountAggregateInputType | true
    }

  export interface GateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Gate'], meta: { name: 'Gate' } }
    /**
     * Find zero or one Gate that matches the filter.
     * @param {GateFindUniqueArgs} args - Arguments to find a Gate
     * @example
     * // Get one Gate
     * const gate = await prisma.gate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GateFindUniqueArgs>(args: SelectSubset<T, GateFindUniqueArgs<ExtArgs>>): Prisma__GateClient<$Result.GetResult<Prisma.$GatePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Gate that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GateFindUniqueOrThrowArgs} args - Arguments to find a Gate
     * @example
     * // Get one Gate
     * const gate = await prisma.gate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GateFindUniqueOrThrowArgs>(args: SelectSubset<T, GateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GateClient<$Result.GetResult<Prisma.$GatePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Gate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GateFindFirstArgs} args - Arguments to find a Gate
     * @example
     * // Get one Gate
     * const gate = await prisma.gate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GateFindFirstArgs>(args?: SelectSubset<T, GateFindFirstArgs<ExtArgs>>): Prisma__GateClient<$Result.GetResult<Prisma.$GatePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Gate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GateFindFirstOrThrowArgs} args - Arguments to find a Gate
     * @example
     * // Get one Gate
     * const gate = await prisma.gate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GateFindFirstOrThrowArgs>(args?: SelectSubset<T, GateFindFirstOrThrowArgs<ExtArgs>>): Prisma__GateClient<$Result.GetResult<Prisma.$GatePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Gates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Gates
     * const gates = await prisma.gate.findMany()
     * 
     * // Get first 10 Gates
     * const gates = await prisma.gate.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const gateWithIdOnly = await prisma.gate.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GateFindManyArgs>(args?: SelectSubset<T, GateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Gate.
     * @param {GateCreateArgs} args - Arguments to create a Gate.
     * @example
     * // Create one Gate
     * const Gate = await prisma.gate.create({
     *   data: {
     *     // ... data to create a Gate
     *   }
     * })
     * 
     */
    create<T extends GateCreateArgs>(args: SelectSubset<T, GateCreateArgs<ExtArgs>>): Prisma__GateClient<$Result.GetResult<Prisma.$GatePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Gates.
     * @param {GateCreateManyArgs} args - Arguments to create many Gates.
     * @example
     * // Create many Gates
     * const gate = await prisma.gate.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GateCreateManyArgs>(args?: SelectSubset<T, GateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Gates and returns the data saved in the database.
     * @param {GateCreateManyAndReturnArgs} args - Arguments to create many Gates.
     * @example
     * // Create many Gates
     * const gate = await prisma.gate.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Gates and only return the `id`
     * const gateWithIdOnly = await prisma.gate.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GateCreateManyAndReturnArgs>(args?: SelectSubset<T, GateCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GatePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Gate.
     * @param {GateDeleteArgs} args - Arguments to delete one Gate.
     * @example
     * // Delete one Gate
     * const Gate = await prisma.gate.delete({
     *   where: {
     *     // ... filter to delete one Gate
     *   }
     * })
     * 
     */
    delete<T extends GateDeleteArgs>(args: SelectSubset<T, GateDeleteArgs<ExtArgs>>): Prisma__GateClient<$Result.GetResult<Prisma.$GatePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Gate.
     * @param {GateUpdateArgs} args - Arguments to update one Gate.
     * @example
     * // Update one Gate
     * const gate = await prisma.gate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GateUpdateArgs>(args: SelectSubset<T, GateUpdateArgs<ExtArgs>>): Prisma__GateClient<$Result.GetResult<Prisma.$GatePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Gates.
     * @param {GateDeleteManyArgs} args - Arguments to filter Gates to delete.
     * @example
     * // Delete a few Gates
     * const { count } = await prisma.gate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GateDeleteManyArgs>(args?: SelectSubset<T, GateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Gates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Gates
     * const gate = await prisma.gate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GateUpdateManyArgs>(args: SelectSubset<T, GateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Gates and returns the data updated in the database.
     * @param {GateUpdateManyAndReturnArgs} args - Arguments to update many Gates.
     * @example
     * // Update many Gates
     * const gate = await prisma.gate.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Gates and only return the `id`
     * const gateWithIdOnly = await prisma.gate.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GateUpdateManyAndReturnArgs>(args: SelectSubset<T, GateUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GatePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Gate.
     * @param {GateUpsertArgs} args - Arguments to update or create a Gate.
     * @example
     * // Update or create a Gate
     * const gate = await prisma.gate.upsert({
     *   create: {
     *     // ... data to create a Gate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Gate we want to update
     *   }
     * })
     */
    upsert<T extends GateUpsertArgs>(args: SelectSubset<T, GateUpsertArgs<ExtArgs>>): Prisma__GateClient<$Result.GetResult<Prisma.$GatePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Gates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GateCountArgs} args - Arguments to filter Gates to count.
     * @example
     * // Count the number of Gates
     * const count = await prisma.gate.count({
     *   where: {
     *     // ... the filter for the Gates we want to count
     *   }
     * })
    **/
    count<T extends GateCountArgs>(
      args?: Subset<T, GateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Gate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GateAggregateArgs>(args: Subset<T, GateAggregateArgs>): Prisma.PrismaPromise<GetGateAggregateType<T>>

    /**
     * Group by Gate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GateGroupByArgs['orderBy'] }
        : { orderBy?: GateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Gate model
   */
  readonly fields: GateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Gate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    vendors<T extends Gate$vendorsArgs<ExtArgs> = {}>(args?: Subset<T, Gate$vendorsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VendorGatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    employees<T extends Gate$employeesArgs<ExtArgs> = {}>(args?: Subset<T, Gate$employeesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeeGatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    activities<T extends Gate$activitiesArgs<ExtArgs> = {}>(args?: Subset<T, Gate$activitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Gate model
   */
  interface GateFieldRefs {
    readonly id: FieldRef<"Gate", 'String'>
    readonly name: FieldRef<"Gate", 'String'>
    readonly description: FieldRef<"Gate", 'String'>
    readonly createdAt: FieldRef<"Gate", 'DateTime'>
    readonly updatedAt: FieldRef<"Gate", 'DateTime'>
    readonly deletedAt: FieldRef<"Gate", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Gate findUnique
   */
  export type GateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gate
     */
    select?: GateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Gate
     */
    omit?: GateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GateInclude<ExtArgs> | null
    /**
     * Filter, which Gate to fetch.
     */
    where: GateWhereUniqueInput
  }

  /**
   * Gate findUniqueOrThrow
   */
  export type GateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gate
     */
    select?: GateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Gate
     */
    omit?: GateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GateInclude<ExtArgs> | null
    /**
     * Filter, which Gate to fetch.
     */
    where: GateWhereUniqueInput
  }

  /**
   * Gate findFirst
   */
  export type GateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gate
     */
    select?: GateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Gate
     */
    omit?: GateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GateInclude<ExtArgs> | null
    /**
     * Filter, which Gate to fetch.
     */
    where?: GateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Gates to fetch.
     */
    orderBy?: GateOrderByWithRelationInput | GateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Gates.
     */
    cursor?: GateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Gates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Gates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Gates.
     */
    distinct?: GateScalarFieldEnum | GateScalarFieldEnum[]
  }

  /**
   * Gate findFirstOrThrow
   */
  export type GateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gate
     */
    select?: GateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Gate
     */
    omit?: GateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GateInclude<ExtArgs> | null
    /**
     * Filter, which Gate to fetch.
     */
    where?: GateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Gates to fetch.
     */
    orderBy?: GateOrderByWithRelationInput | GateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Gates.
     */
    cursor?: GateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Gates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Gates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Gates.
     */
    distinct?: GateScalarFieldEnum | GateScalarFieldEnum[]
  }

  /**
   * Gate findMany
   */
  export type GateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gate
     */
    select?: GateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Gate
     */
    omit?: GateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GateInclude<ExtArgs> | null
    /**
     * Filter, which Gates to fetch.
     */
    where?: GateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Gates to fetch.
     */
    orderBy?: GateOrderByWithRelationInput | GateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Gates.
     */
    cursor?: GateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Gates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Gates.
     */
    skip?: number
    distinct?: GateScalarFieldEnum | GateScalarFieldEnum[]
  }

  /**
   * Gate create
   */
  export type GateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gate
     */
    select?: GateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Gate
     */
    omit?: GateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GateInclude<ExtArgs> | null
    /**
     * The data needed to create a Gate.
     */
    data: XOR<GateCreateInput, GateUncheckedCreateInput>
  }

  /**
   * Gate createMany
   */
  export type GateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Gates.
     */
    data: GateCreateManyInput | GateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Gate createManyAndReturn
   */
  export type GateCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gate
     */
    select?: GateSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Gate
     */
    omit?: GateOmit<ExtArgs> | null
    /**
     * The data used to create many Gates.
     */
    data: GateCreateManyInput | GateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Gate update
   */
  export type GateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gate
     */
    select?: GateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Gate
     */
    omit?: GateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GateInclude<ExtArgs> | null
    /**
     * The data needed to update a Gate.
     */
    data: XOR<GateUpdateInput, GateUncheckedUpdateInput>
    /**
     * Choose, which Gate to update.
     */
    where: GateWhereUniqueInput
  }

  /**
   * Gate updateMany
   */
  export type GateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Gates.
     */
    data: XOR<GateUpdateManyMutationInput, GateUncheckedUpdateManyInput>
    /**
     * Filter which Gates to update
     */
    where?: GateWhereInput
    /**
     * Limit how many Gates to update.
     */
    limit?: number
  }

  /**
   * Gate updateManyAndReturn
   */
  export type GateUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gate
     */
    select?: GateSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Gate
     */
    omit?: GateOmit<ExtArgs> | null
    /**
     * The data used to update Gates.
     */
    data: XOR<GateUpdateManyMutationInput, GateUncheckedUpdateManyInput>
    /**
     * Filter which Gates to update
     */
    where?: GateWhereInput
    /**
     * Limit how many Gates to update.
     */
    limit?: number
  }

  /**
   * Gate upsert
   */
  export type GateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gate
     */
    select?: GateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Gate
     */
    omit?: GateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GateInclude<ExtArgs> | null
    /**
     * The filter to search for the Gate to update in case it exists.
     */
    where: GateWhereUniqueInput
    /**
     * In case the Gate found by the `where` argument doesn't exist, create a new Gate with this data.
     */
    create: XOR<GateCreateInput, GateUncheckedCreateInput>
    /**
     * In case the Gate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GateUpdateInput, GateUncheckedUpdateInput>
  }

  /**
   * Gate delete
   */
  export type GateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gate
     */
    select?: GateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Gate
     */
    omit?: GateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GateInclude<ExtArgs> | null
    /**
     * Filter which Gate to delete.
     */
    where: GateWhereUniqueInput
  }

  /**
   * Gate deleteMany
   */
  export type GateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Gates to delete
     */
    where?: GateWhereInput
    /**
     * Limit how many Gates to delete.
     */
    limit?: number
  }

  /**
   * Gate.vendors
   */
  export type Gate$vendorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorGate
     */
    select?: VendorGateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorGate
     */
    omit?: VendorGateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorGateInclude<ExtArgs> | null
    where?: VendorGateWhereInput
    orderBy?: VendorGateOrderByWithRelationInput | VendorGateOrderByWithRelationInput[]
    cursor?: VendorGateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VendorGateScalarFieldEnum | VendorGateScalarFieldEnum[]
  }

  /**
   * Gate.employees
   */
  export type Gate$employeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeGate
     */
    select?: EmployeeGateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeGate
     */
    omit?: EmployeeGateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeGateInclude<ExtArgs> | null
    where?: EmployeeGateWhereInput
    orderBy?: EmployeeGateOrderByWithRelationInput | EmployeeGateOrderByWithRelationInput[]
    cursor?: EmployeeGateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmployeeGateScalarFieldEnum | EmployeeGateScalarFieldEnum[]
  }

  /**
   * Gate.activities
   */
  export type Gate$activitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    where?: ActivityWhereInput
    orderBy?: ActivityOrderByWithRelationInput | ActivityOrderByWithRelationInput[]
    cursor?: ActivityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ActivityScalarFieldEnum | ActivityScalarFieldEnum[]
  }

  /**
   * Gate without action
   */
  export type GateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gate
     */
    select?: GateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Gate
     */
    omit?: GateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GateInclude<ExtArgs> | null
  }


  /**
   * Model Permission
   */

  export type AggregatePermission = {
    _count: PermissionCountAggregateOutputType | null
    _min: PermissionMinAggregateOutputType | null
    _max: PermissionMaxAggregateOutputType | null
  }

  export type PermissionMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type PermissionMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type PermissionCountAggregateOutputType = {
    id: number
    name: number
    description: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type PermissionMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type PermissionMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type PermissionCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type PermissionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Permission to aggregate.
     */
    where?: PermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     */
    orderBy?: PermissionOrderByWithRelationInput | PermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Permissions
    **/
    _count?: true | PermissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PermissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PermissionMaxAggregateInputType
  }

  export type GetPermissionAggregateType<T extends PermissionAggregateArgs> = {
        [P in keyof T & keyof AggregatePermission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePermission[P]>
      : GetScalarType<T[P], AggregatePermission[P]>
  }




  export type PermissionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PermissionWhereInput
    orderBy?: PermissionOrderByWithAggregationInput | PermissionOrderByWithAggregationInput[]
    by: PermissionScalarFieldEnum[] | PermissionScalarFieldEnum
    having?: PermissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PermissionCountAggregateInputType | true
    _min?: PermissionMinAggregateInputType
    _max?: PermissionMaxAggregateInputType
  }

  export type PermissionGroupByOutputType = {
    id: string
    name: string
    description: string | null
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: PermissionCountAggregateOutputType | null
    _min: PermissionMinAggregateOutputType | null
    _max: PermissionMaxAggregateOutputType | null
  }

  type GetPermissionGroupByPayload<T extends PermissionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PermissionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PermissionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PermissionGroupByOutputType[P]>
            : GetScalarType<T[P], PermissionGroupByOutputType[P]>
        }
      >
    >


  export type PermissionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    employeePermissions?: boolean | Permission$employeePermissionsArgs<ExtArgs>
    _count?: boolean | PermissionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["permission"]>

  export type PermissionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }, ExtArgs["result"]["permission"]>

  export type PermissionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }, ExtArgs["result"]["permission"]>

  export type PermissionSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type PermissionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "createdAt" | "updatedAt" | "deletedAt", ExtArgs["result"]["permission"]>
  export type PermissionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employeePermissions?: boolean | Permission$employeePermissionsArgs<ExtArgs>
    _count?: boolean | PermissionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PermissionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type PermissionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $PermissionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Permission"
    objects: {
      employeePermissions: Prisma.$EmployeePermissionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["permission"]>
    composites: {}
  }

  type PermissionGetPayload<S extends boolean | null | undefined | PermissionDefaultArgs> = $Result.GetResult<Prisma.$PermissionPayload, S>

  type PermissionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PermissionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PermissionCountAggregateInputType | true
    }

  export interface PermissionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Permission'], meta: { name: 'Permission' } }
    /**
     * Find zero or one Permission that matches the filter.
     * @param {PermissionFindUniqueArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PermissionFindUniqueArgs>(args: SelectSubset<T, PermissionFindUniqueArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Permission that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PermissionFindUniqueOrThrowArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PermissionFindUniqueOrThrowArgs>(args: SelectSubset<T, PermissionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Permission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionFindFirstArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PermissionFindFirstArgs>(args?: SelectSubset<T, PermissionFindFirstArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Permission that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionFindFirstOrThrowArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PermissionFindFirstOrThrowArgs>(args?: SelectSubset<T, PermissionFindFirstOrThrowArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Permissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Permissions
     * const permissions = await prisma.permission.findMany()
     * 
     * // Get first 10 Permissions
     * const permissions = await prisma.permission.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const permissionWithIdOnly = await prisma.permission.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PermissionFindManyArgs>(args?: SelectSubset<T, PermissionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Permission.
     * @param {PermissionCreateArgs} args - Arguments to create a Permission.
     * @example
     * // Create one Permission
     * const Permission = await prisma.permission.create({
     *   data: {
     *     // ... data to create a Permission
     *   }
     * })
     * 
     */
    create<T extends PermissionCreateArgs>(args: SelectSubset<T, PermissionCreateArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Permissions.
     * @param {PermissionCreateManyArgs} args - Arguments to create many Permissions.
     * @example
     * // Create many Permissions
     * const permission = await prisma.permission.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PermissionCreateManyArgs>(args?: SelectSubset<T, PermissionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Permissions and returns the data saved in the database.
     * @param {PermissionCreateManyAndReturnArgs} args - Arguments to create many Permissions.
     * @example
     * // Create many Permissions
     * const permission = await prisma.permission.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Permissions and only return the `id`
     * const permissionWithIdOnly = await prisma.permission.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PermissionCreateManyAndReturnArgs>(args?: SelectSubset<T, PermissionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Permission.
     * @param {PermissionDeleteArgs} args - Arguments to delete one Permission.
     * @example
     * // Delete one Permission
     * const Permission = await prisma.permission.delete({
     *   where: {
     *     // ... filter to delete one Permission
     *   }
     * })
     * 
     */
    delete<T extends PermissionDeleteArgs>(args: SelectSubset<T, PermissionDeleteArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Permission.
     * @param {PermissionUpdateArgs} args - Arguments to update one Permission.
     * @example
     * // Update one Permission
     * const permission = await prisma.permission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PermissionUpdateArgs>(args: SelectSubset<T, PermissionUpdateArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Permissions.
     * @param {PermissionDeleteManyArgs} args - Arguments to filter Permissions to delete.
     * @example
     * // Delete a few Permissions
     * const { count } = await prisma.permission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PermissionDeleteManyArgs>(args?: SelectSubset<T, PermissionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Permissions
     * const permission = await prisma.permission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PermissionUpdateManyArgs>(args: SelectSubset<T, PermissionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Permissions and returns the data updated in the database.
     * @param {PermissionUpdateManyAndReturnArgs} args - Arguments to update many Permissions.
     * @example
     * // Update many Permissions
     * const permission = await prisma.permission.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Permissions and only return the `id`
     * const permissionWithIdOnly = await prisma.permission.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PermissionUpdateManyAndReturnArgs>(args: SelectSubset<T, PermissionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Permission.
     * @param {PermissionUpsertArgs} args - Arguments to update or create a Permission.
     * @example
     * // Update or create a Permission
     * const permission = await prisma.permission.upsert({
     *   create: {
     *     // ... data to create a Permission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Permission we want to update
     *   }
     * })
     */
    upsert<T extends PermissionUpsertArgs>(args: SelectSubset<T, PermissionUpsertArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionCountArgs} args - Arguments to filter Permissions to count.
     * @example
     * // Count the number of Permissions
     * const count = await prisma.permission.count({
     *   where: {
     *     // ... the filter for the Permissions we want to count
     *   }
     * })
    **/
    count<T extends PermissionCountArgs>(
      args?: Subset<T, PermissionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PermissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Permission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PermissionAggregateArgs>(args: Subset<T, PermissionAggregateArgs>): Prisma.PrismaPromise<GetPermissionAggregateType<T>>

    /**
     * Group by Permission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PermissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PermissionGroupByArgs['orderBy'] }
        : { orderBy?: PermissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PermissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPermissionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Permission model
   */
  readonly fields: PermissionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Permission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PermissionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    employeePermissions<T extends Permission$employeePermissionsArgs<ExtArgs> = {}>(args?: Subset<T, Permission$employeePermissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeePermissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Permission model
   */
  interface PermissionFieldRefs {
    readonly id: FieldRef<"Permission", 'String'>
    readonly name: FieldRef<"Permission", 'String'>
    readonly description: FieldRef<"Permission", 'String'>
    readonly createdAt: FieldRef<"Permission", 'DateTime'>
    readonly updatedAt: FieldRef<"Permission", 'DateTime'>
    readonly deletedAt: FieldRef<"Permission", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Permission findUnique
   */
  export type PermissionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permission to fetch.
     */
    where: PermissionWhereUniqueInput
  }

  /**
   * Permission findUniqueOrThrow
   */
  export type PermissionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permission to fetch.
     */
    where: PermissionWhereUniqueInput
  }

  /**
   * Permission findFirst
   */
  export type PermissionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permission to fetch.
     */
    where?: PermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     */
    orderBy?: PermissionOrderByWithRelationInput | PermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Permissions.
     */
    cursor?: PermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Permissions.
     */
    distinct?: PermissionScalarFieldEnum | PermissionScalarFieldEnum[]
  }

  /**
   * Permission findFirstOrThrow
   */
  export type PermissionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permission to fetch.
     */
    where?: PermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     */
    orderBy?: PermissionOrderByWithRelationInput | PermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Permissions.
     */
    cursor?: PermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Permissions.
     */
    distinct?: PermissionScalarFieldEnum | PermissionScalarFieldEnum[]
  }

  /**
   * Permission findMany
   */
  export type PermissionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permissions to fetch.
     */
    where?: PermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     */
    orderBy?: PermissionOrderByWithRelationInput | PermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Permissions.
     */
    cursor?: PermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     */
    skip?: number
    distinct?: PermissionScalarFieldEnum | PermissionScalarFieldEnum[]
  }

  /**
   * Permission create
   */
  export type PermissionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * The data needed to create a Permission.
     */
    data: XOR<PermissionCreateInput, PermissionUncheckedCreateInput>
  }

  /**
   * Permission createMany
   */
  export type PermissionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Permissions.
     */
    data: PermissionCreateManyInput | PermissionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Permission createManyAndReturn
   */
  export type PermissionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * The data used to create many Permissions.
     */
    data: PermissionCreateManyInput | PermissionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Permission update
   */
  export type PermissionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * The data needed to update a Permission.
     */
    data: XOR<PermissionUpdateInput, PermissionUncheckedUpdateInput>
    /**
     * Choose, which Permission to update.
     */
    where: PermissionWhereUniqueInput
  }

  /**
   * Permission updateMany
   */
  export type PermissionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Permissions.
     */
    data: XOR<PermissionUpdateManyMutationInput, PermissionUncheckedUpdateManyInput>
    /**
     * Filter which Permissions to update
     */
    where?: PermissionWhereInput
    /**
     * Limit how many Permissions to update.
     */
    limit?: number
  }

  /**
   * Permission updateManyAndReturn
   */
  export type PermissionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * The data used to update Permissions.
     */
    data: XOR<PermissionUpdateManyMutationInput, PermissionUncheckedUpdateManyInput>
    /**
     * Filter which Permissions to update
     */
    where?: PermissionWhereInput
    /**
     * Limit how many Permissions to update.
     */
    limit?: number
  }

  /**
   * Permission upsert
   */
  export type PermissionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * The filter to search for the Permission to update in case it exists.
     */
    where: PermissionWhereUniqueInput
    /**
     * In case the Permission found by the `where` argument doesn't exist, create a new Permission with this data.
     */
    create: XOR<PermissionCreateInput, PermissionUncheckedCreateInput>
    /**
     * In case the Permission was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PermissionUpdateInput, PermissionUncheckedUpdateInput>
  }

  /**
   * Permission delete
   */
  export type PermissionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter which Permission to delete.
     */
    where: PermissionWhereUniqueInput
  }

  /**
   * Permission deleteMany
   */
  export type PermissionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Permissions to delete
     */
    where?: PermissionWhereInput
    /**
     * Limit how many Permissions to delete.
     */
    limit?: number
  }

  /**
   * Permission.employeePermissions
   */
  export type Permission$employeePermissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeePermission
     */
    select?: EmployeePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeePermission
     */
    omit?: EmployeePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeePermissionInclude<ExtArgs> | null
    where?: EmployeePermissionWhereInput
    orderBy?: EmployeePermissionOrderByWithRelationInput | EmployeePermissionOrderByWithRelationInput[]
    cursor?: EmployeePermissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmployeePermissionScalarFieldEnum | EmployeePermissionScalarFieldEnum[]
  }

  /**
   * Permission without action
   */
  export type PermissionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
  }


  /**
   * Model Employee
   */

  export type AggregateEmployee = {
    _count: EmployeeCountAggregateOutputType | null
    _avg: EmployeeAvgAggregateOutputType | null
    _sum: EmployeeSumAggregateOutputType | null
    _min: EmployeeMinAggregateOutputType | null
    _max: EmployeeMaxAggregateOutputType | null
  }

  export type EmployeeAvgAggregateOutputType = {
    version: number | null
  }

  export type EmployeeSumAggregateOutputType = {
    version: number | null
  }

  export type EmployeeMinAggregateOutputType = {
    id: string | null
    identifier: string | null
    name: string | null
    job: string | null
    nationalId: string | null
    version: number | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
    status: $Enums.EmployeeStatus | null
    vendorId: string | null
  }

  export type EmployeeMaxAggregateOutputType = {
    id: string | null
    identifier: string | null
    name: string | null
    job: string | null
    nationalId: string | null
    version: number | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
    status: $Enums.EmployeeStatus | null
    vendorId: string | null
  }

  export type EmployeeCountAggregateOutputType = {
    id: number
    identifier: number
    name: number
    job: number
    nationalId: number
    version: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    status: number
    vendorId: number
    _all: number
  }


  export type EmployeeAvgAggregateInputType = {
    version?: true
  }

  export type EmployeeSumAggregateInputType = {
    version?: true
  }

  export type EmployeeMinAggregateInputType = {
    id?: true
    identifier?: true
    name?: true
    job?: true
    nationalId?: true
    version?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    status?: true
    vendorId?: true
  }

  export type EmployeeMaxAggregateInputType = {
    id?: true
    identifier?: true
    name?: true
    job?: true
    nationalId?: true
    version?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    status?: true
    vendorId?: true
  }

  export type EmployeeCountAggregateInputType = {
    id?: true
    identifier?: true
    name?: true
    job?: true
    nationalId?: true
    version?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    status?: true
    vendorId?: true
    _all?: true
  }

  export type EmployeeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Employee to aggregate.
     */
    where?: EmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Employees to fetch.
     */
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Employees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Employees
    **/
    _count?: true | EmployeeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EmployeeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EmployeeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmployeeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmployeeMaxAggregateInputType
  }

  export type GetEmployeeAggregateType<T extends EmployeeAggregateArgs> = {
        [P in keyof T & keyof AggregateEmployee]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmployee[P]>
      : GetScalarType<T[P], AggregateEmployee[P]>
  }




  export type EmployeeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeWhereInput
    orderBy?: EmployeeOrderByWithAggregationInput | EmployeeOrderByWithAggregationInput[]
    by: EmployeeScalarFieldEnum[] | EmployeeScalarFieldEnum
    having?: EmployeeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmployeeCountAggregateInputType | true
    _avg?: EmployeeAvgAggregateInputType
    _sum?: EmployeeSumAggregateInputType
    _min?: EmployeeMinAggregateInputType
    _max?: EmployeeMaxAggregateInputType
  }

  export type EmployeeGroupByOutputType = {
    id: string
    identifier: string
    name: string
    job: string
    nationalId: string
    version: number
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    status: $Enums.EmployeeStatus
    vendorId: string
    _count: EmployeeCountAggregateOutputType | null
    _avg: EmployeeAvgAggregateOutputType | null
    _sum: EmployeeSumAggregateOutputType | null
    _min: EmployeeMinAggregateOutputType | null
    _max: EmployeeMaxAggregateOutputType | null
  }

  type GetEmployeeGroupByPayload<T extends EmployeeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmployeeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmployeeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmployeeGroupByOutputType[P]>
            : GetScalarType<T[P], EmployeeGroupByOutputType[P]>
        }
      >
    >


  export type EmployeeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    identifier?: boolean
    name?: boolean
    job?: boolean
    nationalId?: boolean
    version?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    status?: boolean
    vendorId?: boolean
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
    gates?: boolean | Employee$gatesArgs<ExtArgs>
    zones?: boolean | Employee$zonesArgs<ExtArgs>
    activities?: boolean | Employee$activitiesArgs<ExtArgs>
    workingHours?: boolean | Employee$workingHoursArgs<ExtArgs>
    employeeAttachments?: boolean | Employee$employeeAttachmentsArgs<ExtArgs>
    employeePermissions?: boolean | Employee$employeePermissionsArgs<ExtArgs>
    alerts?: boolean | Employee$alertsArgs<ExtArgs>
    allowedDates?: boolean | Employee$allowedDatesArgs<ExtArgs>
    _count?: boolean | EmployeeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employee"]>

  export type EmployeeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    identifier?: boolean
    name?: boolean
    job?: boolean
    nationalId?: boolean
    version?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    status?: boolean
    vendorId?: boolean
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employee"]>

  export type EmployeeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    identifier?: boolean
    name?: boolean
    job?: boolean
    nationalId?: boolean
    version?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    status?: boolean
    vendorId?: boolean
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employee"]>

  export type EmployeeSelectScalar = {
    id?: boolean
    identifier?: boolean
    name?: boolean
    job?: boolean
    nationalId?: boolean
    version?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    status?: boolean
    vendorId?: boolean
  }

  export type EmployeeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "identifier" | "name" | "job" | "nationalId" | "version" | "createdAt" | "updatedAt" | "deletedAt" | "status" | "vendorId", ExtArgs["result"]["employee"]>
  export type EmployeeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
    gates?: boolean | Employee$gatesArgs<ExtArgs>
    zones?: boolean | Employee$zonesArgs<ExtArgs>
    activities?: boolean | Employee$activitiesArgs<ExtArgs>
    workingHours?: boolean | Employee$workingHoursArgs<ExtArgs>
    employeeAttachments?: boolean | Employee$employeeAttachmentsArgs<ExtArgs>
    employeePermissions?: boolean | Employee$employeePermissionsArgs<ExtArgs>
    alerts?: boolean | Employee$alertsArgs<ExtArgs>
    allowedDates?: boolean | Employee$allowedDatesArgs<ExtArgs>
    _count?: boolean | EmployeeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type EmployeeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
  }
  export type EmployeeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
  }

  export type $EmployeePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Employee"
    objects: {
      vendor: Prisma.$VendorPayload<ExtArgs>
      gates: Prisma.$EmployeeGatePayload<ExtArgs>[]
      zones: Prisma.$EmployeeZonePayload<ExtArgs>[]
      activities: Prisma.$ActivityPayload<ExtArgs>[]
      workingHours: Prisma.$WorkingHoursPayload<ExtArgs>[]
      employeeAttachments: Prisma.$EmployeeAttachmentPayload<ExtArgs>[]
      employeePermissions: Prisma.$EmployeePermissionPayload<ExtArgs>[]
      alerts: Prisma.$AlertPayload<ExtArgs>[]
      allowedDates: Prisma.$EmployeeAllowedDatePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      identifier: string
      name: string
      job: string
      nationalId: string
      version: number
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
      status: $Enums.EmployeeStatus
      vendorId: string
    }, ExtArgs["result"]["employee"]>
    composites: {}
  }

  type EmployeeGetPayload<S extends boolean | null | undefined | EmployeeDefaultArgs> = $Result.GetResult<Prisma.$EmployeePayload, S>

  type EmployeeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EmployeeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EmployeeCountAggregateInputType | true
    }

  export interface EmployeeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Employee'], meta: { name: 'Employee' } }
    /**
     * Find zero or one Employee that matches the filter.
     * @param {EmployeeFindUniqueArgs} args - Arguments to find a Employee
     * @example
     * // Get one Employee
     * const employee = await prisma.employee.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmployeeFindUniqueArgs>(args: SelectSubset<T, EmployeeFindUniqueArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Employee that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EmployeeFindUniqueOrThrowArgs} args - Arguments to find a Employee
     * @example
     * // Get one Employee
     * const employee = await prisma.employee.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmployeeFindUniqueOrThrowArgs>(args: SelectSubset<T, EmployeeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Employee that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeFindFirstArgs} args - Arguments to find a Employee
     * @example
     * // Get one Employee
     * const employee = await prisma.employee.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmployeeFindFirstArgs>(args?: SelectSubset<T, EmployeeFindFirstArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Employee that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeFindFirstOrThrowArgs} args - Arguments to find a Employee
     * @example
     * // Get one Employee
     * const employee = await prisma.employee.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmployeeFindFirstOrThrowArgs>(args?: SelectSubset<T, EmployeeFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Employees that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Employees
     * const employees = await prisma.employee.findMany()
     * 
     * // Get first 10 Employees
     * const employees = await prisma.employee.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const employeeWithIdOnly = await prisma.employee.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EmployeeFindManyArgs>(args?: SelectSubset<T, EmployeeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Employee.
     * @param {EmployeeCreateArgs} args - Arguments to create a Employee.
     * @example
     * // Create one Employee
     * const Employee = await prisma.employee.create({
     *   data: {
     *     // ... data to create a Employee
     *   }
     * })
     * 
     */
    create<T extends EmployeeCreateArgs>(args: SelectSubset<T, EmployeeCreateArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Employees.
     * @param {EmployeeCreateManyArgs} args - Arguments to create many Employees.
     * @example
     * // Create many Employees
     * const employee = await prisma.employee.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmployeeCreateManyArgs>(args?: SelectSubset<T, EmployeeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Employees and returns the data saved in the database.
     * @param {EmployeeCreateManyAndReturnArgs} args - Arguments to create many Employees.
     * @example
     * // Create many Employees
     * const employee = await prisma.employee.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Employees and only return the `id`
     * const employeeWithIdOnly = await prisma.employee.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EmployeeCreateManyAndReturnArgs>(args?: SelectSubset<T, EmployeeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Employee.
     * @param {EmployeeDeleteArgs} args - Arguments to delete one Employee.
     * @example
     * // Delete one Employee
     * const Employee = await prisma.employee.delete({
     *   where: {
     *     // ... filter to delete one Employee
     *   }
     * })
     * 
     */
    delete<T extends EmployeeDeleteArgs>(args: SelectSubset<T, EmployeeDeleteArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Employee.
     * @param {EmployeeUpdateArgs} args - Arguments to update one Employee.
     * @example
     * // Update one Employee
     * const employee = await prisma.employee.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmployeeUpdateArgs>(args: SelectSubset<T, EmployeeUpdateArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Employees.
     * @param {EmployeeDeleteManyArgs} args - Arguments to filter Employees to delete.
     * @example
     * // Delete a few Employees
     * const { count } = await prisma.employee.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmployeeDeleteManyArgs>(args?: SelectSubset<T, EmployeeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Employees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Employees
     * const employee = await prisma.employee.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmployeeUpdateManyArgs>(args: SelectSubset<T, EmployeeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Employees and returns the data updated in the database.
     * @param {EmployeeUpdateManyAndReturnArgs} args - Arguments to update many Employees.
     * @example
     * // Update many Employees
     * const employee = await prisma.employee.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Employees and only return the `id`
     * const employeeWithIdOnly = await prisma.employee.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EmployeeUpdateManyAndReturnArgs>(args: SelectSubset<T, EmployeeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Employee.
     * @param {EmployeeUpsertArgs} args - Arguments to update or create a Employee.
     * @example
     * // Update or create a Employee
     * const employee = await prisma.employee.upsert({
     *   create: {
     *     // ... data to create a Employee
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Employee we want to update
     *   }
     * })
     */
    upsert<T extends EmployeeUpsertArgs>(args: SelectSubset<T, EmployeeUpsertArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Employees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeCountArgs} args - Arguments to filter Employees to count.
     * @example
     * // Count the number of Employees
     * const count = await prisma.employee.count({
     *   where: {
     *     // ... the filter for the Employees we want to count
     *   }
     * })
    **/
    count<T extends EmployeeCountArgs>(
      args?: Subset<T, EmployeeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmployeeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Employee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmployeeAggregateArgs>(args: Subset<T, EmployeeAggregateArgs>): Prisma.PrismaPromise<GetEmployeeAggregateType<T>>

    /**
     * Group by Employee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmployeeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmployeeGroupByArgs['orderBy'] }
        : { orderBy?: EmployeeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmployeeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmployeeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Employee model
   */
  readonly fields: EmployeeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Employee.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmployeeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    vendor<T extends VendorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VendorDefaultArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    gates<T extends Employee$gatesArgs<ExtArgs> = {}>(args?: Subset<T, Employee$gatesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeeGatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    zones<T extends Employee$zonesArgs<ExtArgs> = {}>(args?: Subset<T, Employee$zonesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeeZonePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    activities<T extends Employee$activitiesArgs<ExtArgs> = {}>(args?: Subset<T, Employee$activitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    workingHours<T extends Employee$workingHoursArgs<ExtArgs> = {}>(args?: Subset<T, Employee$workingHoursArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkingHoursPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    employeeAttachments<T extends Employee$employeeAttachmentsArgs<ExtArgs> = {}>(args?: Subset<T, Employee$employeeAttachmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeeAttachmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    employeePermissions<T extends Employee$employeePermissionsArgs<ExtArgs> = {}>(args?: Subset<T, Employee$employeePermissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeePermissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    alerts<T extends Employee$alertsArgs<ExtArgs> = {}>(args?: Subset<T, Employee$alertsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    allowedDates<T extends Employee$allowedDatesArgs<ExtArgs> = {}>(args?: Subset<T, Employee$allowedDatesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeeAllowedDatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Employee model
   */
  interface EmployeeFieldRefs {
    readonly id: FieldRef<"Employee", 'String'>
    readonly identifier: FieldRef<"Employee", 'String'>
    readonly name: FieldRef<"Employee", 'String'>
    readonly job: FieldRef<"Employee", 'String'>
    readonly nationalId: FieldRef<"Employee", 'String'>
    readonly version: FieldRef<"Employee", 'Int'>
    readonly createdAt: FieldRef<"Employee", 'DateTime'>
    readonly updatedAt: FieldRef<"Employee", 'DateTime'>
    readonly deletedAt: FieldRef<"Employee", 'DateTime'>
    readonly status: FieldRef<"Employee", 'EmployeeStatus'>
    readonly vendorId: FieldRef<"Employee", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Employee findUnique
   */
  export type EmployeeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter, which Employee to fetch.
     */
    where: EmployeeWhereUniqueInput
  }

  /**
   * Employee findUniqueOrThrow
   */
  export type EmployeeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter, which Employee to fetch.
     */
    where: EmployeeWhereUniqueInput
  }

  /**
   * Employee findFirst
   */
  export type EmployeeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter, which Employee to fetch.
     */
    where?: EmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Employees to fetch.
     */
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Employees.
     */
    cursor?: EmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Employees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Employees.
     */
    distinct?: EmployeeScalarFieldEnum | EmployeeScalarFieldEnum[]
  }

  /**
   * Employee findFirstOrThrow
   */
  export type EmployeeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter, which Employee to fetch.
     */
    where?: EmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Employees to fetch.
     */
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Employees.
     */
    cursor?: EmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Employees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Employees.
     */
    distinct?: EmployeeScalarFieldEnum | EmployeeScalarFieldEnum[]
  }

  /**
   * Employee findMany
   */
  export type EmployeeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter, which Employees to fetch.
     */
    where?: EmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Employees to fetch.
     */
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Employees.
     */
    cursor?: EmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Employees.
     */
    skip?: number
    distinct?: EmployeeScalarFieldEnum | EmployeeScalarFieldEnum[]
  }

  /**
   * Employee create
   */
  export type EmployeeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * The data needed to create a Employee.
     */
    data: XOR<EmployeeCreateInput, EmployeeUncheckedCreateInput>
  }

  /**
   * Employee createMany
   */
  export type EmployeeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Employees.
     */
    data: EmployeeCreateManyInput | EmployeeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Employee createManyAndReturn
   */
  export type EmployeeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * The data used to create many Employees.
     */
    data: EmployeeCreateManyInput | EmployeeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Employee update
   */
  export type EmployeeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * The data needed to update a Employee.
     */
    data: XOR<EmployeeUpdateInput, EmployeeUncheckedUpdateInput>
    /**
     * Choose, which Employee to update.
     */
    where: EmployeeWhereUniqueInput
  }

  /**
   * Employee updateMany
   */
  export type EmployeeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Employees.
     */
    data: XOR<EmployeeUpdateManyMutationInput, EmployeeUncheckedUpdateManyInput>
    /**
     * Filter which Employees to update
     */
    where?: EmployeeWhereInput
    /**
     * Limit how many Employees to update.
     */
    limit?: number
  }

  /**
   * Employee updateManyAndReturn
   */
  export type EmployeeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * The data used to update Employees.
     */
    data: XOR<EmployeeUpdateManyMutationInput, EmployeeUncheckedUpdateManyInput>
    /**
     * Filter which Employees to update
     */
    where?: EmployeeWhereInput
    /**
     * Limit how many Employees to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Employee upsert
   */
  export type EmployeeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * The filter to search for the Employee to update in case it exists.
     */
    where: EmployeeWhereUniqueInput
    /**
     * In case the Employee found by the `where` argument doesn't exist, create a new Employee with this data.
     */
    create: XOR<EmployeeCreateInput, EmployeeUncheckedCreateInput>
    /**
     * In case the Employee was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmployeeUpdateInput, EmployeeUncheckedUpdateInput>
  }

  /**
   * Employee delete
   */
  export type EmployeeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter which Employee to delete.
     */
    where: EmployeeWhereUniqueInput
  }

  /**
   * Employee deleteMany
   */
  export type EmployeeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Employees to delete
     */
    where?: EmployeeWhereInput
    /**
     * Limit how many Employees to delete.
     */
    limit?: number
  }

  /**
   * Employee.gates
   */
  export type Employee$gatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeGate
     */
    select?: EmployeeGateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeGate
     */
    omit?: EmployeeGateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeGateInclude<ExtArgs> | null
    where?: EmployeeGateWhereInput
    orderBy?: EmployeeGateOrderByWithRelationInput | EmployeeGateOrderByWithRelationInput[]
    cursor?: EmployeeGateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmployeeGateScalarFieldEnum | EmployeeGateScalarFieldEnum[]
  }

  /**
   * Employee.zones
   */
  export type Employee$zonesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeZone
     */
    select?: EmployeeZoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeZone
     */
    omit?: EmployeeZoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeZoneInclude<ExtArgs> | null
    where?: EmployeeZoneWhereInput
    orderBy?: EmployeeZoneOrderByWithRelationInput | EmployeeZoneOrderByWithRelationInput[]
    cursor?: EmployeeZoneWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmployeeZoneScalarFieldEnum | EmployeeZoneScalarFieldEnum[]
  }

  /**
   * Employee.activities
   */
  export type Employee$activitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    where?: ActivityWhereInput
    orderBy?: ActivityOrderByWithRelationInput | ActivityOrderByWithRelationInput[]
    cursor?: ActivityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ActivityScalarFieldEnum | ActivityScalarFieldEnum[]
  }

  /**
   * Employee.workingHours
   */
  export type Employee$workingHoursArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkingHours
     */
    select?: WorkingHoursSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkingHours
     */
    omit?: WorkingHoursOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkingHoursInclude<ExtArgs> | null
    where?: WorkingHoursWhereInput
    orderBy?: WorkingHoursOrderByWithRelationInput | WorkingHoursOrderByWithRelationInput[]
    cursor?: WorkingHoursWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkingHoursScalarFieldEnum | WorkingHoursScalarFieldEnum[]
  }

  /**
   * Employee.employeeAttachments
   */
  export type Employee$employeeAttachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeAttachment
     */
    select?: EmployeeAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeAttachment
     */
    omit?: EmployeeAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeAttachmentInclude<ExtArgs> | null
    where?: EmployeeAttachmentWhereInput
    orderBy?: EmployeeAttachmentOrderByWithRelationInput | EmployeeAttachmentOrderByWithRelationInput[]
    cursor?: EmployeeAttachmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmployeeAttachmentScalarFieldEnum | EmployeeAttachmentScalarFieldEnum[]
  }

  /**
   * Employee.employeePermissions
   */
  export type Employee$employeePermissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeePermission
     */
    select?: EmployeePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeePermission
     */
    omit?: EmployeePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeePermissionInclude<ExtArgs> | null
    where?: EmployeePermissionWhereInput
    orderBy?: EmployeePermissionOrderByWithRelationInput | EmployeePermissionOrderByWithRelationInput[]
    cursor?: EmployeePermissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmployeePermissionScalarFieldEnum | EmployeePermissionScalarFieldEnum[]
  }

  /**
   * Employee.alerts
   */
  export type Employee$alertsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Alert
     */
    omit?: AlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertInclude<ExtArgs> | null
    where?: AlertWhereInput
    orderBy?: AlertOrderByWithRelationInput | AlertOrderByWithRelationInput[]
    cursor?: AlertWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AlertScalarFieldEnum | AlertScalarFieldEnum[]
  }

  /**
   * Employee.allowedDates
   */
  export type Employee$allowedDatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeAllowedDate
     */
    select?: EmployeeAllowedDateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeAllowedDate
     */
    omit?: EmployeeAllowedDateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeAllowedDateInclude<ExtArgs> | null
    where?: EmployeeAllowedDateWhereInput
    orderBy?: EmployeeAllowedDateOrderByWithRelationInput | EmployeeAllowedDateOrderByWithRelationInput[]
    cursor?: EmployeeAllowedDateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmployeeAllowedDateScalarFieldEnum | EmployeeAllowedDateScalarFieldEnum[]
  }

  /**
   * Employee without action
   */
  export type EmployeeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
  }


  /**
   * Model WorkingHours
   */

  export type AggregateWorkingHours = {
    _count: WorkingHoursCountAggregateOutputType | null
    _min: WorkingHoursMinAggregateOutputType | null
    _max: WorkingHoursMaxAggregateOutputType | null
  }

  export type WorkingHoursMinAggregateOutputType = {
    id: string | null
    dayOfWeek: $Enums.DayOfWeek | null
    startTime: string | null
    endTime: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    employeeId: string | null
  }

  export type WorkingHoursMaxAggregateOutputType = {
    id: string | null
    dayOfWeek: $Enums.DayOfWeek | null
    startTime: string | null
    endTime: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    employeeId: string | null
  }

  export type WorkingHoursCountAggregateOutputType = {
    id: number
    dayOfWeek: number
    startTime: number
    endTime: number
    isActive: number
    createdAt: number
    updatedAt: number
    employeeId: number
    _all: number
  }


  export type WorkingHoursMinAggregateInputType = {
    id?: true
    dayOfWeek?: true
    startTime?: true
    endTime?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    employeeId?: true
  }

  export type WorkingHoursMaxAggregateInputType = {
    id?: true
    dayOfWeek?: true
    startTime?: true
    endTime?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    employeeId?: true
  }

  export type WorkingHoursCountAggregateInputType = {
    id?: true
    dayOfWeek?: true
    startTime?: true
    endTime?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    employeeId?: true
    _all?: true
  }

  export type WorkingHoursAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkingHours to aggregate.
     */
    where?: WorkingHoursWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkingHours to fetch.
     */
    orderBy?: WorkingHoursOrderByWithRelationInput | WorkingHoursOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WorkingHoursWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkingHours from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkingHours.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WorkingHours
    **/
    _count?: true | WorkingHoursCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WorkingHoursMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WorkingHoursMaxAggregateInputType
  }

  export type GetWorkingHoursAggregateType<T extends WorkingHoursAggregateArgs> = {
        [P in keyof T & keyof AggregateWorkingHours]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWorkingHours[P]>
      : GetScalarType<T[P], AggregateWorkingHours[P]>
  }




  export type WorkingHoursGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkingHoursWhereInput
    orderBy?: WorkingHoursOrderByWithAggregationInput | WorkingHoursOrderByWithAggregationInput[]
    by: WorkingHoursScalarFieldEnum[] | WorkingHoursScalarFieldEnum
    having?: WorkingHoursScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WorkingHoursCountAggregateInputType | true
    _min?: WorkingHoursMinAggregateInputType
    _max?: WorkingHoursMaxAggregateInputType
  }

  export type WorkingHoursGroupByOutputType = {
    id: string
    dayOfWeek: $Enums.DayOfWeek
    startTime: string
    endTime: string
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    employeeId: string
    _count: WorkingHoursCountAggregateOutputType | null
    _min: WorkingHoursMinAggregateOutputType | null
    _max: WorkingHoursMaxAggregateOutputType | null
  }

  type GetWorkingHoursGroupByPayload<T extends WorkingHoursGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WorkingHoursGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WorkingHoursGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WorkingHoursGroupByOutputType[P]>
            : GetScalarType<T[P], WorkingHoursGroupByOutputType[P]>
        }
      >
    >


  export type WorkingHoursSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    dayOfWeek?: boolean
    startTime?: boolean
    endTime?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employeeId?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workingHours"]>

  export type WorkingHoursSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    dayOfWeek?: boolean
    startTime?: boolean
    endTime?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employeeId?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workingHours"]>

  export type WorkingHoursSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    dayOfWeek?: boolean
    startTime?: boolean
    endTime?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employeeId?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workingHours"]>

  export type WorkingHoursSelectScalar = {
    id?: boolean
    dayOfWeek?: boolean
    startTime?: boolean
    endTime?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employeeId?: boolean
  }

  export type WorkingHoursOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "dayOfWeek" | "startTime" | "endTime" | "isActive" | "createdAt" | "updatedAt" | "employeeId", ExtArgs["result"]["workingHours"]>
  export type WorkingHoursInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }
  export type WorkingHoursIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }
  export type WorkingHoursIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }

  export type $WorkingHoursPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WorkingHours"
    objects: {
      employee: Prisma.$EmployeePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      dayOfWeek: $Enums.DayOfWeek
      startTime: string
      endTime: string
      isActive: boolean
      createdAt: Date
      updatedAt: Date
      employeeId: string
    }, ExtArgs["result"]["workingHours"]>
    composites: {}
  }

  type WorkingHoursGetPayload<S extends boolean | null | undefined | WorkingHoursDefaultArgs> = $Result.GetResult<Prisma.$WorkingHoursPayload, S>

  type WorkingHoursCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WorkingHoursFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WorkingHoursCountAggregateInputType | true
    }

  export interface WorkingHoursDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WorkingHours'], meta: { name: 'WorkingHours' } }
    /**
     * Find zero or one WorkingHours that matches the filter.
     * @param {WorkingHoursFindUniqueArgs} args - Arguments to find a WorkingHours
     * @example
     * // Get one WorkingHours
     * const workingHours = await prisma.workingHours.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WorkingHoursFindUniqueArgs>(args: SelectSubset<T, WorkingHoursFindUniqueArgs<ExtArgs>>): Prisma__WorkingHoursClient<$Result.GetResult<Prisma.$WorkingHoursPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one WorkingHours that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WorkingHoursFindUniqueOrThrowArgs} args - Arguments to find a WorkingHours
     * @example
     * // Get one WorkingHours
     * const workingHours = await prisma.workingHours.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WorkingHoursFindUniqueOrThrowArgs>(args: SelectSubset<T, WorkingHoursFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WorkingHoursClient<$Result.GetResult<Prisma.$WorkingHoursPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WorkingHours that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkingHoursFindFirstArgs} args - Arguments to find a WorkingHours
     * @example
     * // Get one WorkingHours
     * const workingHours = await prisma.workingHours.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WorkingHoursFindFirstArgs>(args?: SelectSubset<T, WorkingHoursFindFirstArgs<ExtArgs>>): Prisma__WorkingHoursClient<$Result.GetResult<Prisma.$WorkingHoursPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WorkingHours that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkingHoursFindFirstOrThrowArgs} args - Arguments to find a WorkingHours
     * @example
     * // Get one WorkingHours
     * const workingHours = await prisma.workingHours.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WorkingHoursFindFirstOrThrowArgs>(args?: SelectSubset<T, WorkingHoursFindFirstOrThrowArgs<ExtArgs>>): Prisma__WorkingHoursClient<$Result.GetResult<Prisma.$WorkingHoursPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more WorkingHours that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkingHoursFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WorkingHours
     * const workingHours = await prisma.workingHours.findMany()
     * 
     * // Get first 10 WorkingHours
     * const workingHours = await prisma.workingHours.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const workingHoursWithIdOnly = await prisma.workingHours.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WorkingHoursFindManyArgs>(args?: SelectSubset<T, WorkingHoursFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkingHoursPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a WorkingHours.
     * @param {WorkingHoursCreateArgs} args - Arguments to create a WorkingHours.
     * @example
     * // Create one WorkingHours
     * const WorkingHours = await prisma.workingHours.create({
     *   data: {
     *     // ... data to create a WorkingHours
     *   }
     * })
     * 
     */
    create<T extends WorkingHoursCreateArgs>(args: SelectSubset<T, WorkingHoursCreateArgs<ExtArgs>>): Prisma__WorkingHoursClient<$Result.GetResult<Prisma.$WorkingHoursPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many WorkingHours.
     * @param {WorkingHoursCreateManyArgs} args - Arguments to create many WorkingHours.
     * @example
     * // Create many WorkingHours
     * const workingHours = await prisma.workingHours.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WorkingHoursCreateManyArgs>(args?: SelectSubset<T, WorkingHoursCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WorkingHours and returns the data saved in the database.
     * @param {WorkingHoursCreateManyAndReturnArgs} args - Arguments to create many WorkingHours.
     * @example
     * // Create many WorkingHours
     * const workingHours = await prisma.workingHours.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WorkingHours and only return the `id`
     * const workingHoursWithIdOnly = await prisma.workingHours.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WorkingHoursCreateManyAndReturnArgs>(args?: SelectSubset<T, WorkingHoursCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkingHoursPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a WorkingHours.
     * @param {WorkingHoursDeleteArgs} args - Arguments to delete one WorkingHours.
     * @example
     * // Delete one WorkingHours
     * const WorkingHours = await prisma.workingHours.delete({
     *   where: {
     *     // ... filter to delete one WorkingHours
     *   }
     * })
     * 
     */
    delete<T extends WorkingHoursDeleteArgs>(args: SelectSubset<T, WorkingHoursDeleteArgs<ExtArgs>>): Prisma__WorkingHoursClient<$Result.GetResult<Prisma.$WorkingHoursPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one WorkingHours.
     * @param {WorkingHoursUpdateArgs} args - Arguments to update one WorkingHours.
     * @example
     * // Update one WorkingHours
     * const workingHours = await prisma.workingHours.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WorkingHoursUpdateArgs>(args: SelectSubset<T, WorkingHoursUpdateArgs<ExtArgs>>): Prisma__WorkingHoursClient<$Result.GetResult<Prisma.$WorkingHoursPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more WorkingHours.
     * @param {WorkingHoursDeleteManyArgs} args - Arguments to filter WorkingHours to delete.
     * @example
     * // Delete a few WorkingHours
     * const { count } = await prisma.workingHours.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WorkingHoursDeleteManyArgs>(args?: SelectSubset<T, WorkingHoursDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorkingHours.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkingHoursUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WorkingHours
     * const workingHours = await prisma.workingHours.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WorkingHoursUpdateManyArgs>(args: SelectSubset<T, WorkingHoursUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorkingHours and returns the data updated in the database.
     * @param {WorkingHoursUpdateManyAndReturnArgs} args - Arguments to update many WorkingHours.
     * @example
     * // Update many WorkingHours
     * const workingHours = await prisma.workingHours.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more WorkingHours and only return the `id`
     * const workingHoursWithIdOnly = await prisma.workingHours.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WorkingHoursUpdateManyAndReturnArgs>(args: SelectSubset<T, WorkingHoursUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkingHoursPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one WorkingHours.
     * @param {WorkingHoursUpsertArgs} args - Arguments to update or create a WorkingHours.
     * @example
     * // Update or create a WorkingHours
     * const workingHours = await prisma.workingHours.upsert({
     *   create: {
     *     // ... data to create a WorkingHours
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WorkingHours we want to update
     *   }
     * })
     */
    upsert<T extends WorkingHoursUpsertArgs>(args: SelectSubset<T, WorkingHoursUpsertArgs<ExtArgs>>): Prisma__WorkingHoursClient<$Result.GetResult<Prisma.$WorkingHoursPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of WorkingHours.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkingHoursCountArgs} args - Arguments to filter WorkingHours to count.
     * @example
     * // Count the number of WorkingHours
     * const count = await prisma.workingHours.count({
     *   where: {
     *     // ... the filter for the WorkingHours we want to count
     *   }
     * })
    **/
    count<T extends WorkingHoursCountArgs>(
      args?: Subset<T, WorkingHoursCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WorkingHoursCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WorkingHours.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkingHoursAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WorkingHoursAggregateArgs>(args: Subset<T, WorkingHoursAggregateArgs>): Prisma.PrismaPromise<GetWorkingHoursAggregateType<T>>

    /**
     * Group by WorkingHours.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkingHoursGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WorkingHoursGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WorkingHoursGroupByArgs['orderBy'] }
        : { orderBy?: WorkingHoursGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WorkingHoursGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWorkingHoursGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WorkingHours model
   */
  readonly fields: WorkingHoursFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WorkingHours.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WorkingHoursClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    employee<T extends EmployeeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmployeeDefaultArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WorkingHours model
   */
  interface WorkingHoursFieldRefs {
    readonly id: FieldRef<"WorkingHours", 'String'>
    readonly dayOfWeek: FieldRef<"WorkingHours", 'DayOfWeek'>
    readonly startTime: FieldRef<"WorkingHours", 'String'>
    readonly endTime: FieldRef<"WorkingHours", 'String'>
    readonly isActive: FieldRef<"WorkingHours", 'Boolean'>
    readonly createdAt: FieldRef<"WorkingHours", 'DateTime'>
    readonly updatedAt: FieldRef<"WorkingHours", 'DateTime'>
    readonly employeeId: FieldRef<"WorkingHours", 'String'>
  }
    

  // Custom InputTypes
  /**
   * WorkingHours findUnique
   */
  export type WorkingHoursFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkingHours
     */
    select?: WorkingHoursSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkingHours
     */
    omit?: WorkingHoursOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkingHoursInclude<ExtArgs> | null
    /**
     * Filter, which WorkingHours to fetch.
     */
    where: WorkingHoursWhereUniqueInput
  }

  /**
   * WorkingHours findUniqueOrThrow
   */
  export type WorkingHoursFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkingHours
     */
    select?: WorkingHoursSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkingHours
     */
    omit?: WorkingHoursOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkingHoursInclude<ExtArgs> | null
    /**
     * Filter, which WorkingHours to fetch.
     */
    where: WorkingHoursWhereUniqueInput
  }

  /**
   * WorkingHours findFirst
   */
  export type WorkingHoursFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkingHours
     */
    select?: WorkingHoursSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkingHours
     */
    omit?: WorkingHoursOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkingHoursInclude<ExtArgs> | null
    /**
     * Filter, which WorkingHours to fetch.
     */
    where?: WorkingHoursWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkingHours to fetch.
     */
    orderBy?: WorkingHoursOrderByWithRelationInput | WorkingHoursOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkingHours.
     */
    cursor?: WorkingHoursWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkingHours from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkingHours.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkingHours.
     */
    distinct?: WorkingHoursScalarFieldEnum | WorkingHoursScalarFieldEnum[]
  }

  /**
   * WorkingHours findFirstOrThrow
   */
  export type WorkingHoursFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkingHours
     */
    select?: WorkingHoursSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkingHours
     */
    omit?: WorkingHoursOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkingHoursInclude<ExtArgs> | null
    /**
     * Filter, which WorkingHours to fetch.
     */
    where?: WorkingHoursWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkingHours to fetch.
     */
    orderBy?: WorkingHoursOrderByWithRelationInput | WorkingHoursOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkingHours.
     */
    cursor?: WorkingHoursWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkingHours from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkingHours.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkingHours.
     */
    distinct?: WorkingHoursScalarFieldEnum | WorkingHoursScalarFieldEnum[]
  }

  /**
   * WorkingHours findMany
   */
  export type WorkingHoursFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkingHours
     */
    select?: WorkingHoursSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkingHours
     */
    omit?: WorkingHoursOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkingHoursInclude<ExtArgs> | null
    /**
     * Filter, which WorkingHours to fetch.
     */
    where?: WorkingHoursWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkingHours to fetch.
     */
    orderBy?: WorkingHoursOrderByWithRelationInput | WorkingHoursOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WorkingHours.
     */
    cursor?: WorkingHoursWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkingHours from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkingHours.
     */
    skip?: number
    distinct?: WorkingHoursScalarFieldEnum | WorkingHoursScalarFieldEnum[]
  }

  /**
   * WorkingHours create
   */
  export type WorkingHoursCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkingHours
     */
    select?: WorkingHoursSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkingHours
     */
    omit?: WorkingHoursOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkingHoursInclude<ExtArgs> | null
    /**
     * The data needed to create a WorkingHours.
     */
    data: XOR<WorkingHoursCreateInput, WorkingHoursUncheckedCreateInput>
  }

  /**
   * WorkingHours createMany
   */
  export type WorkingHoursCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WorkingHours.
     */
    data: WorkingHoursCreateManyInput | WorkingHoursCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WorkingHours createManyAndReturn
   */
  export type WorkingHoursCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkingHours
     */
    select?: WorkingHoursSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WorkingHours
     */
    omit?: WorkingHoursOmit<ExtArgs> | null
    /**
     * The data used to create many WorkingHours.
     */
    data: WorkingHoursCreateManyInput | WorkingHoursCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkingHoursIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WorkingHours update
   */
  export type WorkingHoursUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkingHours
     */
    select?: WorkingHoursSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkingHours
     */
    omit?: WorkingHoursOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkingHoursInclude<ExtArgs> | null
    /**
     * The data needed to update a WorkingHours.
     */
    data: XOR<WorkingHoursUpdateInput, WorkingHoursUncheckedUpdateInput>
    /**
     * Choose, which WorkingHours to update.
     */
    where: WorkingHoursWhereUniqueInput
  }

  /**
   * WorkingHours updateMany
   */
  export type WorkingHoursUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WorkingHours.
     */
    data: XOR<WorkingHoursUpdateManyMutationInput, WorkingHoursUncheckedUpdateManyInput>
    /**
     * Filter which WorkingHours to update
     */
    where?: WorkingHoursWhereInput
    /**
     * Limit how many WorkingHours to update.
     */
    limit?: number
  }

  /**
   * WorkingHours updateManyAndReturn
   */
  export type WorkingHoursUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkingHours
     */
    select?: WorkingHoursSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WorkingHours
     */
    omit?: WorkingHoursOmit<ExtArgs> | null
    /**
     * The data used to update WorkingHours.
     */
    data: XOR<WorkingHoursUpdateManyMutationInput, WorkingHoursUncheckedUpdateManyInput>
    /**
     * Filter which WorkingHours to update
     */
    where?: WorkingHoursWhereInput
    /**
     * Limit how many WorkingHours to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkingHoursIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * WorkingHours upsert
   */
  export type WorkingHoursUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkingHours
     */
    select?: WorkingHoursSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkingHours
     */
    omit?: WorkingHoursOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkingHoursInclude<ExtArgs> | null
    /**
     * The filter to search for the WorkingHours to update in case it exists.
     */
    where: WorkingHoursWhereUniqueInput
    /**
     * In case the WorkingHours found by the `where` argument doesn't exist, create a new WorkingHours with this data.
     */
    create: XOR<WorkingHoursCreateInput, WorkingHoursUncheckedCreateInput>
    /**
     * In case the WorkingHours was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WorkingHoursUpdateInput, WorkingHoursUncheckedUpdateInput>
  }

  /**
   * WorkingHours delete
   */
  export type WorkingHoursDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkingHours
     */
    select?: WorkingHoursSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkingHours
     */
    omit?: WorkingHoursOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkingHoursInclude<ExtArgs> | null
    /**
     * Filter which WorkingHours to delete.
     */
    where: WorkingHoursWhereUniqueInput
  }

  /**
   * WorkingHours deleteMany
   */
  export type WorkingHoursDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkingHours to delete
     */
    where?: WorkingHoursWhereInput
    /**
     * Limit how many WorkingHours to delete.
     */
    limit?: number
  }

  /**
   * WorkingHours without action
   */
  export type WorkingHoursDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkingHours
     */
    select?: WorkingHoursSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkingHours
     */
    omit?: WorkingHoursOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkingHoursInclude<ExtArgs> | null
  }


  /**
   * Model Alert
   */

  export type AggregateAlert = {
    _count: AlertCountAggregateOutputType | null
    _min: AlertMinAggregateOutputType | null
    _max: AlertMaxAggregateOutputType | null
  }

  export type AlertMinAggregateOutputType = {
    id: string | null
    text: string | null
    severity: string | null
    isResolved: boolean | null
    resolvedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    employeeId: string | null
    userId: string | null
    activityId: string | null
  }

  export type AlertMaxAggregateOutputType = {
    id: string | null
    text: string | null
    severity: string | null
    isResolved: boolean | null
    resolvedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    employeeId: string | null
    userId: string | null
    activityId: string | null
  }

  export type AlertCountAggregateOutputType = {
    id: number
    text: number
    severity: number
    isResolved: number
    resolvedAt: number
    createdAt: number
    updatedAt: number
    employeeId: number
    userId: number
    activityId: number
    _all: number
  }


  export type AlertMinAggregateInputType = {
    id?: true
    text?: true
    severity?: true
    isResolved?: true
    resolvedAt?: true
    createdAt?: true
    updatedAt?: true
    employeeId?: true
    userId?: true
    activityId?: true
  }

  export type AlertMaxAggregateInputType = {
    id?: true
    text?: true
    severity?: true
    isResolved?: true
    resolvedAt?: true
    createdAt?: true
    updatedAt?: true
    employeeId?: true
    userId?: true
    activityId?: true
  }

  export type AlertCountAggregateInputType = {
    id?: true
    text?: true
    severity?: true
    isResolved?: true
    resolvedAt?: true
    createdAt?: true
    updatedAt?: true
    employeeId?: true
    userId?: true
    activityId?: true
    _all?: true
  }

  export type AlertAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Alert to aggregate.
     */
    where?: AlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Alerts to fetch.
     */
    orderBy?: AlertOrderByWithRelationInput | AlertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Alerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Alerts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Alerts
    **/
    _count?: true | AlertCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AlertMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AlertMaxAggregateInputType
  }

  export type GetAlertAggregateType<T extends AlertAggregateArgs> = {
        [P in keyof T & keyof AggregateAlert]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAlert[P]>
      : GetScalarType<T[P], AggregateAlert[P]>
  }




  export type AlertGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AlertWhereInput
    orderBy?: AlertOrderByWithAggregationInput | AlertOrderByWithAggregationInput[]
    by: AlertScalarFieldEnum[] | AlertScalarFieldEnum
    having?: AlertScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AlertCountAggregateInputType | true
    _min?: AlertMinAggregateInputType
    _max?: AlertMaxAggregateInputType
  }

  export type AlertGroupByOutputType = {
    id: string
    text: string
    severity: string
    isResolved: boolean
    resolvedAt: Date | null
    createdAt: Date
    updatedAt: Date
    employeeId: string | null
    userId: string | null
    activityId: string | null
    _count: AlertCountAggregateOutputType | null
    _min: AlertMinAggregateOutputType | null
    _max: AlertMaxAggregateOutputType | null
  }

  type GetAlertGroupByPayload<T extends AlertGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AlertGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AlertGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AlertGroupByOutputType[P]>
            : GetScalarType<T[P], AlertGroupByOutputType[P]>
        }
      >
    >


  export type AlertSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    text?: boolean
    severity?: boolean
    isResolved?: boolean
    resolvedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employeeId?: boolean
    userId?: boolean
    activityId?: boolean
    employee?: boolean | Alert$employeeArgs<ExtArgs>
    user?: boolean | Alert$userArgs<ExtArgs>
    activity?: boolean | Alert$activityArgs<ExtArgs>
  }, ExtArgs["result"]["alert"]>

  export type AlertSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    text?: boolean
    severity?: boolean
    isResolved?: boolean
    resolvedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employeeId?: boolean
    userId?: boolean
    activityId?: boolean
    employee?: boolean | Alert$employeeArgs<ExtArgs>
    user?: boolean | Alert$userArgs<ExtArgs>
    activity?: boolean | Alert$activityArgs<ExtArgs>
  }, ExtArgs["result"]["alert"]>

  export type AlertSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    text?: boolean
    severity?: boolean
    isResolved?: boolean
    resolvedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employeeId?: boolean
    userId?: boolean
    activityId?: boolean
    employee?: boolean | Alert$employeeArgs<ExtArgs>
    user?: boolean | Alert$userArgs<ExtArgs>
    activity?: boolean | Alert$activityArgs<ExtArgs>
  }, ExtArgs["result"]["alert"]>

  export type AlertSelectScalar = {
    id?: boolean
    text?: boolean
    severity?: boolean
    isResolved?: boolean
    resolvedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employeeId?: boolean
    userId?: boolean
    activityId?: boolean
  }

  export type AlertOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "text" | "severity" | "isResolved" | "resolvedAt" | "createdAt" | "updatedAt" | "employeeId" | "userId" | "activityId", ExtArgs["result"]["alert"]>
  export type AlertInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | Alert$employeeArgs<ExtArgs>
    user?: boolean | Alert$userArgs<ExtArgs>
    activity?: boolean | Alert$activityArgs<ExtArgs>
  }
  export type AlertIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | Alert$employeeArgs<ExtArgs>
    user?: boolean | Alert$userArgs<ExtArgs>
    activity?: boolean | Alert$activityArgs<ExtArgs>
  }
  export type AlertIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | Alert$employeeArgs<ExtArgs>
    user?: boolean | Alert$userArgs<ExtArgs>
    activity?: boolean | Alert$activityArgs<ExtArgs>
  }

  export type $AlertPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Alert"
    objects: {
      employee: Prisma.$EmployeePayload<ExtArgs> | null
      user: Prisma.$UserPayload<ExtArgs> | null
      activity: Prisma.$ActivityPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      text: string
      severity: string
      isResolved: boolean
      resolvedAt: Date | null
      createdAt: Date
      updatedAt: Date
      employeeId: string | null
      userId: string | null
      activityId: string | null
    }, ExtArgs["result"]["alert"]>
    composites: {}
  }

  type AlertGetPayload<S extends boolean | null | undefined | AlertDefaultArgs> = $Result.GetResult<Prisma.$AlertPayload, S>

  type AlertCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AlertFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AlertCountAggregateInputType | true
    }

  export interface AlertDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Alert'], meta: { name: 'Alert' } }
    /**
     * Find zero or one Alert that matches the filter.
     * @param {AlertFindUniqueArgs} args - Arguments to find a Alert
     * @example
     * // Get one Alert
     * const alert = await prisma.alert.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AlertFindUniqueArgs>(args: SelectSubset<T, AlertFindUniqueArgs<ExtArgs>>): Prisma__AlertClient<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Alert that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AlertFindUniqueOrThrowArgs} args - Arguments to find a Alert
     * @example
     * // Get one Alert
     * const alert = await prisma.alert.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AlertFindUniqueOrThrowArgs>(args: SelectSubset<T, AlertFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AlertClient<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Alert that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertFindFirstArgs} args - Arguments to find a Alert
     * @example
     * // Get one Alert
     * const alert = await prisma.alert.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AlertFindFirstArgs>(args?: SelectSubset<T, AlertFindFirstArgs<ExtArgs>>): Prisma__AlertClient<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Alert that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertFindFirstOrThrowArgs} args - Arguments to find a Alert
     * @example
     * // Get one Alert
     * const alert = await prisma.alert.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AlertFindFirstOrThrowArgs>(args?: SelectSubset<T, AlertFindFirstOrThrowArgs<ExtArgs>>): Prisma__AlertClient<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Alerts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Alerts
     * const alerts = await prisma.alert.findMany()
     * 
     * // Get first 10 Alerts
     * const alerts = await prisma.alert.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const alertWithIdOnly = await prisma.alert.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AlertFindManyArgs>(args?: SelectSubset<T, AlertFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Alert.
     * @param {AlertCreateArgs} args - Arguments to create a Alert.
     * @example
     * // Create one Alert
     * const Alert = await prisma.alert.create({
     *   data: {
     *     // ... data to create a Alert
     *   }
     * })
     * 
     */
    create<T extends AlertCreateArgs>(args: SelectSubset<T, AlertCreateArgs<ExtArgs>>): Prisma__AlertClient<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Alerts.
     * @param {AlertCreateManyArgs} args - Arguments to create many Alerts.
     * @example
     * // Create many Alerts
     * const alert = await prisma.alert.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AlertCreateManyArgs>(args?: SelectSubset<T, AlertCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Alerts and returns the data saved in the database.
     * @param {AlertCreateManyAndReturnArgs} args - Arguments to create many Alerts.
     * @example
     * // Create many Alerts
     * const alert = await prisma.alert.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Alerts and only return the `id`
     * const alertWithIdOnly = await prisma.alert.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AlertCreateManyAndReturnArgs>(args?: SelectSubset<T, AlertCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Alert.
     * @param {AlertDeleteArgs} args - Arguments to delete one Alert.
     * @example
     * // Delete one Alert
     * const Alert = await prisma.alert.delete({
     *   where: {
     *     // ... filter to delete one Alert
     *   }
     * })
     * 
     */
    delete<T extends AlertDeleteArgs>(args: SelectSubset<T, AlertDeleteArgs<ExtArgs>>): Prisma__AlertClient<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Alert.
     * @param {AlertUpdateArgs} args - Arguments to update one Alert.
     * @example
     * // Update one Alert
     * const alert = await prisma.alert.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AlertUpdateArgs>(args: SelectSubset<T, AlertUpdateArgs<ExtArgs>>): Prisma__AlertClient<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Alerts.
     * @param {AlertDeleteManyArgs} args - Arguments to filter Alerts to delete.
     * @example
     * // Delete a few Alerts
     * const { count } = await prisma.alert.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AlertDeleteManyArgs>(args?: SelectSubset<T, AlertDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Alerts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Alerts
     * const alert = await prisma.alert.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AlertUpdateManyArgs>(args: SelectSubset<T, AlertUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Alerts and returns the data updated in the database.
     * @param {AlertUpdateManyAndReturnArgs} args - Arguments to update many Alerts.
     * @example
     * // Update many Alerts
     * const alert = await prisma.alert.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Alerts and only return the `id`
     * const alertWithIdOnly = await prisma.alert.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AlertUpdateManyAndReturnArgs>(args: SelectSubset<T, AlertUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Alert.
     * @param {AlertUpsertArgs} args - Arguments to update or create a Alert.
     * @example
     * // Update or create a Alert
     * const alert = await prisma.alert.upsert({
     *   create: {
     *     // ... data to create a Alert
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Alert we want to update
     *   }
     * })
     */
    upsert<T extends AlertUpsertArgs>(args: SelectSubset<T, AlertUpsertArgs<ExtArgs>>): Prisma__AlertClient<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Alerts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertCountArgs} args - Arguments to filter Alerts to count.
     * @example
     * // Count the number of Alerts
     * const count = await prisma.alert.count({
     *   where: {
     *     // ... the filter for the Alerts we want to count
     *   }
     * })
    **/
    count<T extends AlertCountArgs>(
      args?: Subset<T, AlertCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AlertCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Alert.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AlertAggregateArgs>(args: Subset<T, AlertAggregateArgs>): Prisma.PrismaPromise<GetAlertAggregateType<T>>

    /**
     * Group by Alert.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AlertGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AlertGroupByArgs['orderBy'] }
        : { orderBy?: AlertGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AlertGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAlertGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Alert model
   */
  readonly fields: AlertFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Alert.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AlertClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    employee<T extends Alert$employeeArgs<ExtArgs> = {}>(args?: Subset<T, Alert$employeeArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    user<T extends Alert$userArgs<ExtArgs> = {}>(args?: Subset<T, Alert$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    activity<T extends Alert$activityArgs<ExtArgs> = {}>(args?: Subset<T, Alert$activityArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Alert model
   */
  interface AlertFieldRefs {
    readonly id: FieldRef<"Alert", 'String'>
    readonly text: FieldRef<"Alert", 'String'>
    readonly severity: FieldRef<"Alert", 'String'>
    readonly isResolved: FieldRef<"Alert", 'Boolean'>
    readonly resolvedAt: FieldRef<"Alert", 'DateTime'>
    readonly createdAt: FieldRef<"Alert", 'DateTime'>
    readonly updatedAt: FieldRef<"Alert", 'DateTime'>
    readonly employeeId: FieldRef<"Alert", 'String'>
    readonly userId: FieldRef<"Alert", 'String'>
    readonly activityId: FieldRef<"Alert", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Alert findUnique
   */
  export type AlertFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Alert
     */
    omit?: AlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertInclude<ExtArgs> | null
    /**
     * Filter, which Alert to fetch.
     */
    where: AlertWhereUniqueInput
  }

  /**
   * Alert findUniqueOrThrow
   */
  export type AlertFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Alert
     */
    omit?: AlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertInclude<ExtArgs> | null
    /**
     * Filter, which Alert to fetch.
     */
    where: AlertWhereUniqueInput
  }

  /**
   * Alert findFirst
   */
  export type AlertFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Alert
     */
    omit?: AlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertInclude<ExtArgs> | null
    /**
     * Filter, which Alert to fetch.
     */
    where?: AlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Alerts to fetch.
     */
    orderBy?: AlertOrderByWithRelationInput | AlertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Alerts.
     */
    cursor?: AlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Alerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Alerts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Alerts.
     */
    distinct?: AlertScalarFieldEnum | AlertScalarFieldEnum[]
  }

  /**
   * Alert findFirstOrThrow
   */
  export type AlertFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Alert
     */
    omit?: AlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertInclude<ExtArgs> | null
    /**
     * Filter, which Alert to fetch.
     */
    where?: AlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Alerts to fetch.
     */
    orderBy?: AlertOrderByWithRelationInput | AlertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Alerts.
     */
    cursor?: AlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Alerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Alerts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Alerts.
     */
    distinct?: AlertScalarFieldEnum | AlertScalarFieldEnum[]
  }

  /**
   * Alert findMany
   */
  export type AlertFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Alert
     */
    omit?: AlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertInclude<ExtArgs> | null
    /**
     * Filter, which Alerts to fetch.
     */
    where?: AlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Alerts to fetch.
     */
    orderBy?: AlertOrderByWithRelationInput | AlertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Alerts.
     */
    cursor?: AlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Alerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Alerts.
     */
    skip?: number
    distinct?: AlertScalarFieldEnum | AlertScalarFieldEnum[]
  }

  /**
   * Alert create
   */
  export type AlertCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Alert
     */
    omit?: AlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertInclude<ExtArgs> | null
    /**
     * The data needed to create a Alert.
     */
    data: XOR<AlertCreateInput, AlertUncheckedCreateInput>
  }

  /**
   * Alert createMany
   */
  export type AlertCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Alerts.
     */
    data: AlertCreateManyInput | AlertCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Alert createManyAndReturn
   */
  export type AlertCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Alert
     */
    omit?: AlertOmit<ExtArgs> | null
    /**
     * The data used to create many Alerts.
     */
    data: AlertCreateManyInput | AlertCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Alert update
   */
  export type AlertUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Alert
     */
    omit?: AlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertInclude<ExtArgs> | null
    /**
     * The data needed to update a Alert.
     */
    data: XOR<AlertUpdateInput, AlertUncheckedUpdateInput>
    /**
     * Choose, which Alert to update.
     */
    where: AlertWhereUniqueInput
  }

  /**
   * Alert updateMany
   */
  export type AlertUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Alerts.
     */
    data: XOR<AlertUpdateManyMutationInput, AlertUncheckedUpdateManyInput>
    /**
     * Filter which Alerts to update
     */
    where?: AlertWhereInput
    /**
     * Limit how many Alerts to update.
     */
    limit?: number
  }

  /**
   * Alert updateManyAndReturn
   */
  export type AlertUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Alert
     */
    omit?: AlertOmit<ExtArgs> | null
    /**
     * The data used to update Alerts.
     */
    data: XOR<AlertUpdateManyMutationInput, AlertUncheckedUpdateManyInput>
    /**
     * Filter which Alerts to update
     */
    where?: AlertWhereInput
    /**
     * Limit how many Alerts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Alert upsert
   */
  export type AlertUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Alert
     */
    omit?: AlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertInclude<ExtArgs> | null
    /**
     * The filter to search for the Alert to update in case it exists.
     */
    where: AlertWhereUniqueInput
    /**
     * In case the Alert found by the `where` argument doesn't exist, create a new Alert with this data.
     */
    create: XOR<AlertCreateInput, AlertUncheckedCreateInput>
    /**
     * In case the Alert was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AlertUpdateInput, AlertUncheckedUpdateInput>
  }

  /**
   * Alert delete
   */
  export type AlertDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Alert
     */
    omit?: AlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertInclude<ExtArgs> | null
    /**
     * Filter which Alert to delete.
     */
    where: AlertWhereUniqueInput
  }

  /**
   * Alert deleteMany
   */
  export type AlertDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Alerts to delete
     */
    where?: AlertWhereInput
    /**
     * Limit how many Alerts to delete.
     */
    limit?: number
  }

  /**
   * Alert.employee
   */
  export type Alert$employeeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    where?: EmployeeWhereInput
  }

  /**
   * Alert.user
   */
  export type Alert$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Alert.activity
   */
  export type Alert$activityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    where?: ActivityWhereInput
  }

  /**
   * Alert without action
   */
  export type AlertDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Alert
     */
    omit?: AlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertInclude<ExtArgs> | null
  }


  /**
   * Model Activity
   */

  export type AggregateActivity = {
    _count: ActivityCountAggregateOutputType | null
    _min: ActivityMinAggregateOutputType | null
    _max: ActivityMaxAggregateOutputType | null
  }

  export type ActivityMinAggregateOutputType = {
    id: string | null
    type: $Enums.ActivityType | null
    status: $Enums.AccessStatus | null
    denialReason: string | null
    scannedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    employeeId: string | null
    scannerId: string | null
    gateId: string | null
  }

  export type ActivityMaxAggregateOutputType = {
    id: string | null
    type: $Enums.ActivityType | null
    status: $Enums.AccessStatus | null
    denialReason: string | null
    scannedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    employeeId: string | null
    scannerId: string | null
    gateId: string | null
  }

  export type ActivityCountAggregateOutputType = {
    id: number
    type: number
    status: number
    denialReason: number
    scannedAt: number
    createdAt: number
    updatedAt: number
    employeeId: number
    scannerId: number
    gateId: number
    _all: number
  }


  export type ActivityMinAggregateInputType = {
    id?: true
    type?: true
    status?: true
    denialReason?: true
    scannedAt?: true
    createdAt?: true
    updatedAt?: true
    employeeId?: true
    scannerId?: true
    gateId?: true
  }

  export type ActivityMaxAggregateInputType = {
    id?: true
    type?: true
    status?: true
    denialReason?: true
    scannedAt?: true
    createdAt?: true
    updatedAt?: true
    employeeId?: true
    scannerId?: true
    gateId?: true
  }

  export type ActivityCountAggregateInputType = {
    id?: true
    type?: true
    status?: true
    denialReason?: true
    scannedAt?: true
    createdAt?: true
    updatedAt?: true
    employeeId?: true
    scannerId?: true
    gateId?: true
    _all?: true
  }

  export type ActivityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Activity to aggregate.
     */
    where?: ActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Activities to fetch.
     */
    orderBy?: ActivityOrderByWithRelationInput | ActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Activities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Activities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Activities
    **/
    _count?: true | ActivityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ActivityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ActivityMaxAggregateInputType
  }

  export type GetActivityAggregateType<T extends ActivityAggregateArgs> = {
        [P in keyof T & keyof AggregateActivity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateActivity[P]>
      : GetScalarType<T[P], AggregateActivity[P]>
  }




  export type ActivityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityWhereInput
    orderBy?: ActivityOrderByWithAggregationInput | ActivityOrderByWithAggregationInput[]
    by: ActivityScalarFieldEnum[] | ActivityScalarFieldEnum
    having?: ActivityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ActivityCountAggregateInputType | true
    _min?: ActivityMinAggregateInputType
    _max?: ActivityMaxAggregateInputType
  }

  export type ActivityGroupByOutputType = {
    id: string
    type: $Enums.ActivityType
    status: $Enums.AccessStatus
    denialReason: string | null
    scannedAt: Date
    createdAt: Date
    updatedAt: Date
    employeeId: string
    scannerId: string | null
    gateId: string | null
    _count: ActivityCountAggregateOutputType | null
    _min: ActivityMinAggregateOutputType | null
    _max: ActivityMaxAggregateOutputType | null
  }

  type GetActivityGroupByPayload<T extends ActivityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ActivityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ActivityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ActivityGroupByOutputType[P]>
            : GetScalarType<T[P], ActivityGroupByOutputType[P]>
        }
      >
    >


  export type ActivitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    status?: boolean
    denialReason?: boolean
    scannedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employeeId?: boolean
    scannerId?: boolean
    gateId?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    scanner?: boolean | Activity$scannerArgs<ExtArgs>
    gate?: boolean | Activity$gateArgs<ExtArgs>
    alerts?: boolean | Activity$alertsArgs<ExtArgs>
    _count?: boolean | ActivityCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["activity"]>

  export type ActivitySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    status?: boolean
    denialReason?: boolean
    scannedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employeeId?: boolean
    scannerId?: boolean
    gateId?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    scanner?: boolean | Activity$scannerArgs<ExtArgs>
    gate?: boolean | Activity$gateArgs<ExtArgs>
  }, ExtArgs["result"]["activity"]>

  export type ActivitySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    status?: boolean
    denialReason?: boolean
    scannedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employeeId?: boolean
    scannerId?: boolean
    gateId?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    scanner?: boolean | Activity$scannerArgs<ExtArgs>
    gate?: boolean | Activity$gateArgs<ExtArgs>
  }, ExtArgs["result"]["activity"]>

  export type ActivitySelectScalar = {
    id?: boolean
    type?: boolean
    status?: boolean
    denialReason?: boolean
    scannedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employeeId?: boolean
    scannerId?: boolean
    gateId?: boolean
  }

  export type ActivityOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "type" | "status" | "denialReason" | "scannedAt" | "createdAt" | "updatedAt" | "employeeId" | "scannerId" | "gateId", ExtArgs["result"]["activity"]>
  export type ActivityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    scanner?: boolean | Activity$scannerArgs<ExtArgs>
    gate?: boolean | Activity$gateArgs<ExtArgs>
    alerts?: boolean | Activity$alertsArgs<ExtArgs>
    _count?: boolean | ActivityCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ActivityIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    scanner?: boolean | Activity$scannerArgs<ExtArgs>
    gate?: boolean | Activity$gateArgs<ExtArgs>
  }
  export type ActivityIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    scanner?: boolean | Activity$scannerArgs<ExtArgs>
    gate?: boolean | Activity$gateArgs<ExtArgs>
  }

  export type $ActivityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Activity"
    objects: {
      employee: Prisma.$EmployeePayload<ExtArgs>
      scanner: Prisma.$UserPayload<ExtArgs> | null
      gate: Prisma.$GatePayload<ExtArgs> | null
      alerts: Prisma.$AlertPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      type: $Enums.ActivityType
      status: $Enums.AccessStatus
      denialReason: string | null
      scannedAt: Date
      createdAt: Date
      updatedAt: Date
      employeeId: string
      scannerId: string | null
      gateId: string | null
    }, ExtArgs["result"]["activity"]>
    composites: {}
  }

  type ActivityGetPayload<S extends boolean | null | undefined | ActivityDefaultArgs> = $Result.GetResult<Prisma.$ActivityPayload, S>

  type ActivityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ActivityFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ActivityCountAggregateInputType | true
    }

  export interface ActivityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Activity'], meta: { name: 'Activity' } }
    /**
     * Find zero or one Activity that matches the filter.
     * @param {ActivityFindUniqueArgs} args - Arguments to find a Activity
     * @example
     * // Get one Activity
     * const activity = await prisma.activity.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ActivityFindUniqueArgs>(args: SelectSubset<T, ActivityFindUniqueArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Activity that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ActivityFindUniqueOrThrowArgs} args - Arguments to find a Activity
     * @example
     * // Get one Activity
     * const activity = await prisma.activity.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ActivityFindUniqueOrThrowArgs>(args: SelectSubset<T, ActivityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Activity that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityFindFirstArgs} args - Arguments to find a Activity
     * @example
     * // Get one Activity
     * const activity = await prisma.activity.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ActivityFindFirstArgs>(args?: SelectSubset<T, ActivityFindFirstArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Activity that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityFindFirstOrThrowArgs} args - Arguments to find a Activity
     * @example
     * // Get one Activity
     * const activity = await prisma.activity.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ActivityFindFirstOrThrowArgs>(args?: SelectSubset<T, ActivityFindFirstOrThrowArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Activities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Activities
     * const activities = await prisma.activity.findMany()
     * 
     * // Get first 10 Activities
     * const activities = await prisma.activity.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const activityWithIdOnly = await prisma.activity.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ActivityFindManyArgs>(args?: SelectSubset<T, ActivityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Activity.
     * @param {ActivityCreateArgs} args - Arguments to create a Activity.
     * @example
     * // Create one Activity
     * const Activity = await prisma.activity.create({
     *   data: {
     *     // ... data to create a Activity
     *   }
     * })
     * 
     */
    create<T extends ActivityCreateArgs>(args: SelectSubset<T, ActivityCreateArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Activities.
     * @param {ActivityCreateManyArgs} args - Arguments to create many Activities.
     * @example
     * // Create many Activities
     * const activity = await prisma.activity.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ActivityCreateManyArgs>(args?: SelectSubset<T, ActivityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Activities and returns the data saved in the database.
     * @param {ActivityCreateManyAndReturnArgs} args - Arguments to create many Activities.
     * @example
     * // Create many Activities
     * const activity = await prisma.activity.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Activities and only return the `id`
     * const activityWithIdOnly = await prisma.activity.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ActivityCreateManyAndReturnArgs>(args?: SelectSubset<T, ActivityCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Activity.
     * @param {ActivityDeleteArgs} args - Arguments to delete one Activity.
     * @example
     * // Delete one Activity
     * const Activity = await prisma.activity.delete({
     *   where: {
     *     // ... filter to delete one Activity
     *   }
     * })
     * 
     */
    delete<T extends ActivityDeleteArgs>(args: SelectSubset<T, ActivityDeleteArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Activity.
     * @param {ActivityUpdateArgs} args - Arguments to update one Activity.
     * @example
     * // Update one Activity
     * const activity = await prisma.activity.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ActivityUpdateArgs>(args: SelectSubset<T, ActivityUpdateArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Activities.
     * @param {ActivityDeleteManyArgs} args - Arguments to filter Activities to delete.
     * @example
     * // Delete a few Activities
     * const { count } = await prisma.activity.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ActivityDeleteManyArgs>(args?: SelectSubset<T, ActivityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Activities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Activities
     * const activity = await prisma.activity.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ActivityUpdateManyArgs>(args: SelectSubset<T, ActivityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Activities and returns the data updated in the database.
     * @param {ActivityUpdateManyAndReturnArgs} args - Arguments to update many Activities.
     * @example
     * // Update many Activities
     * const activity = await prisma.activity.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Activities and only return the `id`
     * const activityWithIdOnly = await prisma.activity.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ActivityUpdateManyAndReturnArgs>(args: SelectSubset<T, ActivityUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Activity.
     * @param {ActivityUpsertArgs} args - Arguments to update or create a Activity.
     * @example
     * // Update or create a Activity
     * const activity = await prisma.activity.upsert({
     *   create: {
     *     // ... data to create a Activity
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Activity we want to update
     *   }
     * })
     */
    upsert<T extends ActivityUpsertArgs>(args: SelectSubset<T, ActivityUpsertArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Activities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityCountArgs} args - Arguments to filter Activities to count.
     * @example
     * // Count the number of Activities
     * const count = await prisma.activity.count({
     *   where: {
     *     // ... the filter for the Activities we want to count
     *   }
     * })
    **/
    count<T extends ActivityCountArgs>(
      args?: Subset<T, ActivityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ActivityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Activity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ActivityAggregateArgs>(args: Subset<T, ActivityAggregateArgs>): Prisma.PrismaPromise<GetActivityAggregateType<T>>

    /**
     * Group by Activity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ActivityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ActivityGroupByArgs['orderBy'] }
        : { orderBy?: ActivityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ActivityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetActivityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Activity model
   */
  readonly fields: ActivityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Activity.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ActivityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    employee<T extends EmployeeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmployeeDefaultArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    scanner<T extends Activity$scannerArgs<ExtArgs> = {}>(args?: Subset<T, Activity$scannerArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    gate<T extends Activity$gateArgs<ExtArgs> = {}>(args?: Subset<T, Activity$gateArgs<ExtArgs>>): Prisma__GateClient<$Result.GetResult<Prisma.$GatePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    alerts<T extends Activity$alertsArgs<ExtArgs> = {}>(args?: Subset<T, Activity$alertsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Activity model
   */
  interface ActivityFieldRefs {
    readonly id: FieldRef<"Activity", 'String'>
    readonly type: FieldRef<"Activity", 'ActivityType'>
    readonly status: FieldRef<"Activity", 'AccessStatus'>
    readonly denialReason: FieldRef<"Activity", 'String'>
    readonly scannedAt: FieldRef<"Activity", 'DateTime'>
    readonly createdAt: FieldRef<"Activity", 'DateTime'>
    readonly updatedAt: FieldRef<"Activity", 'DateTime'>
    readonly employeeId: FieldRef<"Activity", 'String'>
    readonly scannerId: FieldRef<"Activity", 'String'>
    readonly gateId: FieldRef<"Activity", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Activity findUnique
   */
  export type ActivityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * Filter, which Activity to fetch.
     */
    where: ActivityWhereUniqueInput
  }

  /**
   * Activity findUniqueOrThrow
   */
  export type ActivityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * Filter, which Activity to fetch.
     */
    where: ActivityWhereUniqueInput
  }

  /**
   * Activity findFirst
   */
  export type ActivityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * Filter, which Activity to fetch.
     */
    where?: ActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Activities to fetch.
     */
    orderBy?: ActivityOrderByWithRelationInput | ActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Activities.
     */
    cursor?: ActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Activities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Activities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Activities.
     */
    distinct?: ActivityScalarFieldEnum | ActivityScalarFieldEnum[]
  }

  /**
   * Activity findFirstOrThrow
   */
  export type ActivityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * Filter, which Activity to fetch.
     */
    where?: ActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Activities to fetch.
     */
    orderBy?: ActivityOrderByWithRelationInput | ActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Activities.
     */
    cursor?: ActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Activities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Activities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Activities.
     */
    distinct?: ActivityScalarFieldEnum | ActivityScalarFieldEnum[]
  }

  /**
   * Activity findMany
   */
  export type ActivityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * Filter, which Activities to fetch.
     */
    where?: ActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Activities to fetch.
     */
    orderBy?: ActivityOrderByWithRelationInput | ActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Activities.
     */
    cursor?: ActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Activities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Activities.
     */
    skip?: number
    distinct?: ActivityScalarFieldEnum | ActivityScalarFieldEnum[]
  }

  /**
   * Activity create
   */
  export type ActivityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * The data needed to create a Activity.
     */
    data: XOR<ActivityCreateInput, ActivityUncheckedCreateInput>
  }

  /**
   * Activity createMany
   */
  export type ActivityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Activities.
     */
    data: ActivityCreateManyInput | ActivityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Activity createManyAndReturn
   */
  export type ActivityCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * The data used to create many Activities.
     */
    data: ActivityCreateManyInput | ActivityCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Activity update
   */
  export type ActivityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * The data needed to update a Activity.
     */
    data: XOR<ActivityUpdateInput, ActivityUncheckedUpdateInput>
    /**
     * Choose, which Activity to update.
     */
    where: ActivityWhereUniqueInput
  }

  /**
   * Activity updateMany
   */
  export type ActivityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Activities.
     */
    data: XOR<ActivityUpdateManyMutationInput, ActivityUncheckedUpdateManyInput>
    /**
     * Filter which Activities to update
     */
    where?: ActivityWhereInput
    /**
     * Limit how many Activities to update.
     */
    limit?: number
  }

  /**
   * Activity updateManyAndReturn
   */
  export type ActivityUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * The data used to update Activities.
     */
    data: XOR<ActivityUpdateManyMutationInput, ActivityUncheckedUpdateManyInput>
    /**
     * Filter which Activities to update
     */
    where?: ActivityWhereInput
    /**
     * Limit how many Activities to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Activity upsert
   */
  export type ActivityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * The filter to search for the Activity to update in case it exists.
     */
    where: ActivityWhereUniqueInput
    /**
     * In case the Activity found by the `where` argument doesn't exist, create a new Activity with this data.
     */
    create: XOR<ActivityCreateInput, ActivityUncheckedCreateInput>
    /**
     * In case the Activity was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ActivityUpdateInput, ActivityUncheckedUpdateInput>
  }

  /**
   * Activity delete
   */
  export type ActivityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * Filter which Activity to delete.
     */
    where: ActivityWhereUniqueInput
  }

  /**
   * Activity deleteMany
   */
  export type ActivityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Activities to delete
     */
    where?: ActivityWhereInput
    /**
     * Limit how many Activities to delete.
     */
    limit?: number
  }

  /**
   * Activity.scanner
   */
  export type Activity$scannerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Activity.gate
   */
  export type Activity$gateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gate
     */
    select?: GateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Gate
     */
    omit?: GateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GateInclude<ExtArgs> | null
    where?: GateWhereInput
  }

  /**
   * Activity.alerts
   */
  export type Activity$alertsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Alert
     */
    omit?: AlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertInclude<ExtArgs> | null
    where?: AlertWhereInput
    orderBy?: AlertOrderByWithRelationInput | AlertOrderByWithRelationInput[]
    cursor?: AlertWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AlertScalarFieldEnum | AlertScalarFieldEnum[]
  }

  /**
   * Activity without action
   */
  export type ActivityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
  }


  /**
   * Model Attachment
   */

  export type AggregateAttachment = {
    _count: AttachmentCountAggregateOutputType | null
    _avg: AttachmentAvgAggregateOutputType | null
    _sum: AttachmentSumAggregateOutputType | null
    _min: AttachmentMinAggregateOutputType | null
    _max: AttachmentMaxAggregateOutputType | null
  }

  export type AttachmentAvgAggregateOutputType = {
    size: number | null
  }

  export type AttachmentSumAggregateOutputType = {
    size: number | null
  }

  export type AttachmentMinAggregateOutputType = {
    id: string | null
    url: string | null
    key: string | null
    name: string | null
    mimeType: string | null
    size: number | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AttachmentMaxAggregateOutputType = {
    id: string | null
    url: string | null
    key: string | null
    name: string | null
    mimeType: string | null
    size: number | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AttachmentCountAggregateOutputType = {
    id: number
    url: number
    key: number
    name: number
    mimeType: number
    size: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AttachmentAvgAggregateInputType = {
    size?: true
  }

  export type AttachmentSumAggregateInputType = {
    size?: true
  }

  export type AttachmentMinAggregateInputType = {
    id?: true
    url?: true
    key?: true
    name?: true
    mimeType?: true
    size?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AttachmentMaxAggregateInputType = {
    id?: true
    url?: true
    key?: true
    name?: true
    mimeType?: true
    size?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AttachmentCountAggregateInputType = {
    id?: true
    url?: true
    key?: true
    name?: true
    mimeType?: true
    size?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AttachmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Attachment to aggregate.
     */
    where?: AttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attachments to fetch.
     */
    orderBy?: AttachmentOrderByWithRelationInput | AttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Attachments
    **/
    _count?: true | AttachmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AttachmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AttachmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AttachmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AttachmentMaxAggregateInputType
  }

  export type GetAttachmentAggregateType<T extends AttachmentAggregateArgs> = {
        [P in keyof T & keyof AggregateAttachment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAttachment[P]>
      : GetScalarType<T[P], AggregateAttachment[P]>
  }




  export type AttachmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttachmentWhereInput
    orderBy?: AttachmentOrderByWithAggregationInput | AttachmentOrderByWithAggregationInput[]
    by: AttachmentScalarFieldEnum[] | AttachmentScalarFieldEnum
    having?: AttachmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AttachmentCountAggregateInputType | true
    _avg?: AttachmentAvgAggregateInputType
    _sum?: AttachmentSumAggregateInputType
    _min?: AttachmentMinAggregateInputType
    _max?: AttachmentMaxAggregateInputType
  }

  export type AttachmentGroupByOutputType = {
    id: string
    url: string
    key: string | null
    name: string | null
    mimeType: string | null
    size: number | null
    description: string | null
    createdAt: Date
    updatedAt: Date
    _count: AttachmentCountAggregateOutputType | null
    _avg: AttachmentAvgAggregateOutputType | null
    _sum: AttachmentSumAggregateOutputType | null
    _min: AttachmentMinAggregateOutputType | null
    _max: AttachmentMaxAggregateOutputType | null
  }

  type GetAttachmentGroupByPayload<T extends AttachmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AttachmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AttachmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AttachmentGroupByOutputType[P]>
            : GetScalarType<T[P], AttachmentGroupByOutputType[P]>
        }
      >
    >


  export type AttachmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    url?: boolean
    key?: boolean
    name?: boolean
    mimeType?: boolean
    size?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    vendorAttachments?: boolean | Attachment$vendorAttachmentsArgs<ExtArgs>
    employeeAttachments?: boolean | Attachment$employeeAttachmentsArgs<ExtArgs>
    _count?: boolean | AttachmentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["attachment"]>

  export type AttachmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    url?: boolean
    key?: boolean
    name?: boolean
    mimeType?: boolean
    size?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["attachment"]>

  export type AttachmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    url?: boolean
    key?: boolean
    name?: boolean
    mimeType?: boolean
    size?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["attachment"]>

  export type AttachmentSelectScalar = {
    id?: boolean
    url?: boolean
    key?: boolean
    name?: boolean
    mimeType?: boolean
    size?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AttachmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "url" | "key" | "name" | "mimeType" | "size" | "description" | "createdAt" | "updatedAt", ExtArgs["result"]["attachment"]>
  export type AttachmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vendorAttachments?: boolean | Attachment$vendorAttachmentsArgs<ExtArgs>
    employeeAttachments?: boolean | Attachment$employeeAttachmentsArgs<ExtArgs>
    _count?: boolean | AttachmentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AttachmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type AttachmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $AttachmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Attachment"
    objects: {
      vendorAttachments: Prisma.$VendorAttachmentPayload<ExtArgs>[]
      employeeAttachments: Prisma.$EmployeeAttachmentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      url: string
      key: string | null
      name: string | null
      mimeType: string | null
      size: number | null
      description: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["attachment"]>
    composites: {}
  }

  type AttachmentGetPayload<S extends boolean | null | undefined | AttachmentDefaultArgs> = $Result.GetResult<Prisma.$AttachmentPayload, S>

  type AttachmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AttachmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AttachmentCountAggregateInputType | true
    }

  export interface AttachmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Attachment'], meta: { name: 'Attachment' } }
    /**
     * Find zero or one Attachment that matches the filter.
     * @param {AttachmentFindUniqueArgs} args - Arguments to find a Attachment
     * @example
     * // Get one Attachment
     * const attachment = await prisma.attachment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AttachmentFindUniqueArgs>(args: SelectSubset<T, AttachmentFindUniqueArgs<ExtArgs>>): Prisma__AttachmentClient<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Attachment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AttachmentFindUniqueOrThrowArgs} args - Arguments to find a Attachment
     * @example
     * // Get one Attachment
     * const attachment = await prisma.attachment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AttachmentFindUniqueOrThrowArgs>(args: SelectSubset<T, AttachmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AttachmentClient<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Attachment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttachmentFindFirstArgs} args - Arguments to find a Attachment
     * @example
     * // Get one Attachment
     * const attachment = await prisma.attachment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AttachmentFindFirstArgs>(args?: SelectSubset<T, AttachmentFindFirstArgs<ExtArgs>>): Prisma__AttachmentClient<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Attachment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttachmentFindFirstOrThrowArgs} args - Arguments to find a Attachment
     * @example
     * // Get one Attachment
     * const attachment = await prisma.attachment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AttachmentFindFirstOrThrowArgs>(args?: SelectSubset<T, AttachmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__AttachmentClient<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Attachments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttachmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Attachments
     * const attachments = await prisma.attachment.findMany()
     * 
     * // Get first 10 Attachments
     * const attachments = await prisma.attachment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const attachmentWithIdOnly = await prisma.attachment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AttachmentFindManyArgs>(args?: SelectSubset<T, AttachmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Attachment.
     * @param {AttachmentCreateArgs} args - Arguments to create a Attachment.
     * @example
     * // Create one Attachment
     * const Attachment = await prisma.attachment.create({
     *   data: {
     *     // ... data to create a Attachment
     *   }
     * })
     * 
     */
    create<T extends AttachmentCreateArgs>(args: SelectSubset<T, AttachmentCreateArgs<ExtArgs>>): Prisma__AttachmentClient<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Attachments.
     * @param {AttachmentCreateManyArgs} args - Arguments to create many Attachments.
     * @example
     * // Create many Attachments
     * const attachment = await prisma.attachment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AttachmentCreateManyArgs>(args?: SelectSubset<T, AttachmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Attachments and returns the data saved in the database.
     * @param {AttachmentCreateManyAndReturnArgs} args - Arguments to create many Attachments.
     * @example
     * // Create many Attachments
     * const attachment = await prisma.attachment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Attachments and only return the `id`
     * const attachmentWithIdOnly = await prisma.attachment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AttachmentCreateManyAndReturnArgs>(args?: SelectSubset<T, AttachmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Attachment.
     * @param {AttachmentDeleteArgs} args - Arguments to delete one Attachment.
     * @example
     * // Delete one Attachment
     * const Attachment = await prisma.attachment.delete({
     *   where: {
     *     // ... filter to delete one Attachment
     *   }
     * })
     * 
     */
    delete<T extends AttachmentDeleteArgs>(args: SelectSubset<T, AttachmentDeleteArgs<ExtArgs>>): Prisma__AttachmentClient<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Attachment.
     * @param {AttachmentUpdateArgs} args - Arguments to update one Attachment.
     * @example
     * // Update one Attachment
     * const attachment = await prisma.attachment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AttachmentUpdateArgs>(args: SelectSubset<T, AttachmentUpdateArgs<ExtArgs>>): Prisma__AttachmentClient<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Attachments.
     * @param {AttachmentDeleteManyArgs} args - Arguments to filter Attachments to delete.
     * @example
     * // Delete a few Attachments
     * const { count } = await prisma.attachment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AttachmentDeleteManyArgs>(args?: SelectSubset<T, AttachmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Attachments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttachmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Attachments
     * const attachment = await prisma.attachment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AttachmentUpdateManyArgs>(args: SelectSubset<T, AttachmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Attachments and returns the data updated in the database.
     * @param {AttachmentUpdateManyAndReturnArgs} args - Arguments to update many Attachments.
     * @example
     * // Update many Attachments
     * const attachment = await prisma.attachment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Attachments and only return the `id`
     * const attachmentWithIdOnly = await prisma.attachment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AttachmentUpdateManyAndReturnArgs>(args: SelectSubset<T, AttachmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Attachment.
     * @param {AttachmentUpsertArgs} args - Arguments to update or create a Attachment.
     * @example
     * // Update or create a Attachment
     * const attachment = await prisma.attachment.upsert({
     *   create: {
     *     // ... data to create a Attachment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Attachment we want to update
     *   }
     * })
     */
    upsert<T extends AttachmentUpsertArgs>(args: SelectSubset<T, AttachmentUpsertArgs<ExtArgs>>): Prisma__AttachmentClient<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Attachments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttachmentCountArgs} args - Arguments to filter Attachments to count.
     * @example
     * // Count the number of Attachments
     * const count = await prisma.attachment.count({
     *   where: {
     *     // ... the filter for the Attachments we want to count
     *   }
     * })
    **/
    count<T extends AttachmentCountArgs>(
      args?: Subset<T, AttachmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AttachmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Attachment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttachmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AttachmentAggregateArgs>(args: Subset<T, AttachmentAggregateArgs>): Prisma.PrismaPromise<GetAttachmentAggregateType<T>>

    /**
     * Group by Attachment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttachmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AttachmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AttachmentGroupByArgs['orderBy'] }
        : { orderBy?: AttachmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AttachmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAttachmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Attachment model
   */
  readonly fields: AttachmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Attachment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AttachmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    vendorAttachments<T extends Attachment$vendorAttachmentsArgs<ExtArgs> = {}>(args?: Subset<T, Attachment$vendorAttachmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VendorAttachmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    employeeAttachments<T extends Attachment$employeeAttachmentsArgs<ExtArgs> = {}>(args?: Subset<T, Attachment$employeeAttachmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeeAttachmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Attachment model
   */
  interface AttachmentFieldRefs {
    readonly id: FieldRef<"Attachment", 'String'>
    readonly url: FieldRef<"Attachment", 'String'>
    readonly key: FieldRef<"Attachment", 'String'>
    readonly name: FieldRef<"Attachment", 'String'>
    readonly mimeType: FieldRef<"Attachment", 'String'>
    readonly size: FieldRef<"Attachment", 'Int'>
    readonly description: FieldRef<"Attachment", 'String'>
    readonly createdAt: FieldRef<"Attachment", 'DateTime'>
    readonly updatedAt: FieldRef<"Attachment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Attachment findUnique
   */
  export type AttachmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attachment
     */
    omit?: AttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
    /**
     * Filter, which Attachment to fetch.
     */
    where: AttachmentWhereUniqueInput
  }

  /**
   * Attachment findUniqueOrThrow
   */
  export type AttachmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attachment
     */
    omit?: AttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
    /**
     * Filter, which Attachment to fetch.
     */
    where: AttachmentWhereUniqueInput
  }

  /**
   * Attachment findFirst
   */
  export type AttachmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attachment
     */
    omit?: AttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
    /**
     * Filter, which Attachment to fetch.
     */
    where?: AttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attachments to fetch.
     */
    orderBy?: AttachmentOrderByWithRelationInput | AttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Attachments.
     */
    cursor?: AttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Attachments.
     */
    distinct?: AttachmentScalarFieldEnum | AttachmentScalarFieldEnum[]
  }

  /**
   * Attachment findFirstOrThrow
   */
  export type AttachmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attachment
     */
    omit?: AttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
    /**
     * Filter, which Attachment to fetch.
     */
    where?: AttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attachments to fetch.
     */
    orderBy?: AttachmentOrderByWithRelationInput | AttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Attachments.
     */
    cursor?: AttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Attachments.
     */
    distinct?: AttachmentScalarFieldEnum | AttachmentScalarFieldEnum[]
  }

  /**
   * Attachment findMany
   */
  export type AttachmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attachment
     */
    omit?: AttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
    /**
     * Filter, which Attachments to fetch.
     */
    where?: AttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attachments to fetch.
     */
    orderBy?: AttachmentOrderByWithRelationInput | AttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Attachments.
     */
    cursor?: AttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attachments.
     */
    skip?: number
    distinct?: AttachmentScalarFieldEnum | AttachmentScalarFieldEnum[]
  }

  /**
   * Attachment create
   */
  export type AttachmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attachment
     */
    omit?: AttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
    /**
     * The data needed to create a Attachment.
     */
    data: XOR<AttachmentCreateInput, AttachmentUncheckedCreateInput>
  }

  /**
   * Attachment createMany
   */
  export type AttachmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Attachments.
     */
    data: AttachmentCreateManyInput | AttachmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Attachment createManyAndReturn
   */
  export type AttachmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Attachment
     */
    omit?: AttachmentOmit<ExtArgs> | null
    /**
     * The data used to create many Attachments.
     */
    data: AttachmentCreateManyInput | AttachmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Attachment update
   */
  export type AttachmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attachment
     */
    omit?: AttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
    /**
     * The data needed to update a Attachment.
     */
    data: XOR<AttachmentUpdateInput, AttachmentUncheckedUpdateInput>
    /**
     * Choose, which Attachment to update.
     */
    where: AttachmentWhereUniqueInput
  }

  /**
   * Attachment updateMany
   */
  export type AttachmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Attachments.
     */
    data: XOR<AttachmentUpdateManyMutationInput, AttachmentUncheckedUpdateManyInput>
    /**
     * Filter which Attachments to update
     */
    where?: AttachmentWhereInput
    /**
     * Limit how many Attachments to update.
     */
    limit?: number
  }

  /**
   * Attachment updateManyAndReturn
   */
  export type AttachmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Attachment
     */
    omit?: AttachmentOmit<ExtArgs> | null
    /**
     * The data used to update Attachments.
     */
    data: XOR<AttachmentUpdateManyMutationInput, AttachmentUncheckedUpdateManyInput>
    /**
     * Filter which Attachments to update
     */
    where?: AttachmentWhereInput
    /**
     * Limit how many Attachments to update.
     */
    limit?: number
  }

  /**
   * Attachment upsert
   */
  export type AttachmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attachment
     */
    omit?: AttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
    /**
     * The filter to search for the Attachment to update in case it exists.
     */
    where: AttachmentWhereUniqueInput
    /**
     * In case the Attachment found by the `where` argument doesn't exist, create a new Attachment with this data.
     */
    create: XOR<AttachmentCreateInput, AttachmentUncheckedCreateInput>
    /**
     * In case the Attachment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AttachmentUpdateInput, AttachmentUncheckedUpdateInput>
  }

  /**
   * Attachment delete
   */
  export type AttachmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attachment
     */
    omit?: AttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
    /**
     * Filter which Attachment to delete.
     */
    where: AttachmentWhereUniqueInput
  }

  /**
   * Attachment deleteMany
   */
  export type AttachmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Attachments to delete
     */
    where?: AttachmentWhereInput
    /**
     * Limit how many Attachments to delete.
     */
    limit?: number
  }

  /**
   * Attachment.vendorAttachments
   */
  export type Attachment$vendorAttachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorAttachment
     */
    select?: VendorAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorAttachment
     */
    omit?: VendorAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorAttachmentInclude<ExtArgs> | null
    where?: VendorAttachmentWhereInput
    orderBy?: VendorAttachmentOrderByWithRelationInput | VendorAttachmentOrderByWithRelationInput[]
    cursor?: VendorAttachmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VendorAttachmentScalarFieldEnum | VendorAttachmentScalarFieldEnum[]
  }

  /**
   * Attachment.employeeAttachments
   */
  export type Attachment$employeeAttachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeAttachment
     */
    select?: EmployeeAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeAttachment
     */
    omit?: EmployeeAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeAttachmentInclude<ExtArgs> | null
    where?: EmployeeAttachmentWhereInput
    orderBy?: EmployeeAttachmentOrderByWithRelationInput | EmployeeAttachmentOrderByWithRelationInput[]
    cursor?: EmployeeAttachmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmployeeAttachmentScalarFieldEnum | EmployeeAttachmentScalarFieldEnum[]
  }

  /**
   * Attachment without action
   */
  export type AttachmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attachment
     */
    omit?: AttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
  }


  /**
   * Model VendorAttachment
   */

  export type AggregateVendorAttachment = {
    _count: VendorAttachmentCountAggregateOutputType | null
    _min: VendorAttachmentMinAggregateOutputType | null
    _max: VendorAttachmentMaxAggregateOutputType | null
  }

  export type VendorAttachmentMinAggregateOutputType = {
    id: string | null
    vendorId: string | null
    attachmentId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VendorAttachmentMaxAggregateOutputType = {
    id: string | null
    vendorId: string | null
    attachmentId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VendorAttachmentCountAggregateOutputType = {
    id: number
    vendorId: number
    attachmentId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type VendorAttachmentMinAggregateInputType = {
    id?: true
    vendorId?: true
    attachmentId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VendorAttachmentMaxAggregateInputType = {
    id?: true
    vendorId?: true
    attachmentId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VendorAttachmentCountAggregateInputType = {
    id?: true
    vendorId?: true
    attachmentId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type VendorAttachmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VendorAttachment to aggregate.
     */
    where?: VendorAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VendorAttachments to fetch.
     */
    orderBy?: VendorAttachmentOrderByWithRelationInput | VendorAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VendorAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VendorAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VendorAttachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VendorAttachments
    **/
    _count?: true | VendorAttachmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VendorAttachmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VendorAttachmentMaxAggregateInputType
  }

  export type GetVendorAttachmentAggregateType<T extends VendorAttachmentAggregateArgs> = {
        [P in keyof T & keyof AggregateVendorAttachment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVendorAttachment[P]>
      : GetScalarType<T[P], AggregateVendorAttachment[P]>
  }




  export type VendorAttachmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VendorAttachmentWhereInput
    orderBy?: VendorAttachmentOrderByWithAggregationInput | VendorAttachmentOrderByWithAggregationInput[]
    by: VendorAttachmentScalarFieldEnum[] | VendorAttachmentScalarFieldEnum
    having?: VendorAttachmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VendorAttachmentCountAggregateInputType | true
    _min?: VendorAttachmentMinAggregateInputType
    _max?: VendorAttachmentMaxAggregateInputType
  }

  export type VendorAttachmentGroupByOutputType = {
    id: string
    vendorId: string
    attachmentId: string
    createdAt: Date
    updatedAt: Date
    _count: VendorAttachmentCountAggregateOutputType | null
    _min: VendorAttachmentMinAggregateOutputType | null
    _max: VendorAttachmentMaxAggregateOutputType | null
  }

  type GetVendorAttachmentGroupByPayload<T extends VendorAttachmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VendorAttachmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VendorAttachmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VendorAttachmentGroupByOutputType[P]>
            : GetScalarType<T[P], VendorAttachmentGroupByOutputType[P]>
        }
      >
    >


  export type VendorAttachmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    vendorId?: boolean
    attachmentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
    attachment?: boolean | AttachmentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vendorAttachment"]>

  export type VendorAttachmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    vendorId?: boolean
    attachmentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
    attachment?: boolean | AttachmentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vendorAttachment"]>

  export type VendorAttachmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    vendorId?: boolean
    attachmentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
    attachment?: boolean | AttachmentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vendorAttachment"]>

  export type VendorAttachmentSelectScalar = {
    id?: boolean
    vendorId?: boolean
    attachmentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type VendorAttachmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "vendorId" | "attachmentId" | "createdAt" | "updatedAt", ExtArgs["result"]["vendorAttachment"]>
  export type VendorAttachmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
    attachment?: boolean | AttachmentDefaultArgs<ExtArgs>
  }
  export type VendorAttachmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
    attachment?: boolean | AttachmentDefaultArgs<ExtArgs>
  }
  export type VendorAttachmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
    attachment?: boolean | AttachmentDefaultArgs<ExtArgs>
  }

  export type $VendorAttachmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VendorAttachment"
    objects: {
      vendor: Prisma.$VendorPayload<ExtArgs>
      attachment: Prisma.$AttachmentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      vendorId: string
      attachmentId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["vendorAttachment"]>
    composites: {}
  }

  type VendorAttachmentGetPayload<S extends boolean | null | undefined | VendorAttachmentDefaultArgs> = $Result.GetResult<Prisma.$VendorAttachmentPayload, S>

  type VendorAttachmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VendorAttachmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VendorAttachmentCountAggregateInputType | true
    }

  export interface VendorAttachmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VendorAttachment'], meta: { name: 'VendorAttachment' } }
    /**
     * Find zero or one VendorAttachment that matches the filter.
     * @param {VendorAttachmentFindUniqueArgs} args - Arguments to find a VendorAttachment
     * @example
     * // Get one VendorAttachment
     * const vendorAttachment = await prisma.vendorAttachment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VendorAttachmentFindUniqueArgs>(args: SelectSubset<T, VendorAttachmentFindUniqueArgs<ExtArgs>>): Prisma__VendorAttachmentClient<$Result.GetResult<Prisma.$VendorAttachmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one VendorAttachment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VendorAttachmentFindUniqueOrThrowArgs} args - Arguments to find a VendorAttachment
     * @example
     * // Get one VendorAttachment
     * const vendorAttachment = await prisma.vendorAttachment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VendorAttachmentFindUniqueOrThrowArgs>(args: SelectSubset<T, VendorAttachmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VendorAttachmentClient<$Result.GetResult<Prisma.$VendorAttachmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VendorAttachment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorAttachmentFindFirstArgs} args - Arguments to find a VendorAttachment
     * @example
     * // Get one VendorAttachment
     * const vendorAttachment = await prisma.vendorAttachment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VendorAttachmentFindFirstArgs>(args?: SelectSubset<T, VendorAttachmentFindFirstArgs<ExtArgs>>): Prisma__VendorAttachmentClient<$Result.GetResult<Prisma.$VendorAttachmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VendorAttachment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorAttachmentFindFirstOrThrowArgs} args - Arguments to find a VendorAttachment
     * @example
     * // Get one VendorAttachment
     * const vendorAttachment = await prisma.vendorAttachment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VendorAttachmentFindFirstOrThrowArgs>(args?: SelectSubset<T, VendorAttachmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__VendorAttachmentClient<$Result.GetResult<Prisma.$VendorAttachmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more VendorAttachments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorAttachmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VendorAttachments
     * const vendorAttachments = await prisma.vendorAttachment.findMany()
     * 
     * // Get first 10 VendorAttachments
     * const vendorAttachments = await prisma.vendorAttachment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const vendorAttachmentWithIdOnly = await prisma.vendorAttachment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VendorAttachmentFindManyArgs>(args?: SelectSubset<T, VendorAttachmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VendorAttachmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a VendorAttachment.
     * @param {VendorAttachmentCreateArgs} args - Arguments to create a VendorAttachment.
     * @example
     * // Create one VendorAttachment
     * const VendorAttachment = await prisma.vendorAttachment.create({
     *   data: {
     *     // ... data to create a VendorAttachment
     *   }
     * })
     * 
     */
    create<T extends VendorAttachmentCreateArgs>(args: SelectSubset<T, VendorAttachmentCreateArgs<ExtArgs>>): Prisma__VendorAttachmentClient<$Result.GetResult<Prisma.$VendorAttachmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many VendorAttachments.
     * @param {VendorAttachmentCreateManyArgs} args - Arguments to create many VendorAttachments.
     * @example
     * // Create many VendorAttachments
     * const vendorAttachment = await prisma.vendorAttachment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VendorAttachmentCreateManyArgs>(args?: SelectSubset<T, VendorAttachmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VendorAttachments and returns the data saved in the database.
     * @param {VendorAttachmentCreateManyAndReturnArgs} args - Arguments to create many VendorAttachments.
     * @example
     * // Create many VendorAttachments
     * const vendorAttachment = await prisma.vendorAttachment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VendorAttachments and only return the `id`
     * const vendorAttachmentWithIdOnly = await prisma.vendorAttachment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VendorAttachmentCreateManyAndReturnArgs>(args?: SelectSubset<T, VendorAttachmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VendorAttachmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a VendorAttachment.
     * @param {VendorAttachmentDeleteArgs} args - Arguments to delete one VendorAttachment.
     * @example
     * // Delete one VendorAttachment
     * const VendorAttachment = await prisma.vendorAttachment.delete({
     *   where: {
     *     // ... filter to delete one VendorAttachment
     *   }
     * })
     * 
     */
    delete<T extends VendorAttachmentDeleteArgs>(args: SelectSubset<T, VendorAttachmentDeleteArgs<ExtArgs>>): Prisma__VendorAttachmentClient<$Result.GetResult<Prisma.$VendorAttachmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one VendorAttachment.
     * @param {VendorAttachmentUpdateArgs} args - Arguments to update one VendorAttachment.
     * @example
     * // Update one VendorAttachment
     * const vendorAttachment = await prisma.vendorAttachment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VendorAttachmentUpdateArgs>(args: SelectSubset<T, VendorAttachmentUpdateArgs<ExtArgs>>): Prisma__VendorAttachmentClient<$Result.GetResult<Prisma.$VendorAttachmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more VendorAttachments.
     * @param {VendorAttachmentDeleteManyArgs} args - Arguments to filter VendorAttachments to delete.
     * @example
     * // Delete a few VendorAttachments
     * const { count } = await prisma.vendorAttachment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VendorAttachmentDeleteManyArgs>(args?: SelectSubset<T, VendorAttachmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VendorAttachments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorAttachmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VendorAttachments
     * const vendorAttachment = await prisma.vendorAttachment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VendorAttachmentUpdateManyArgs>(args: SelectSubset<T, VendorAttachmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VendorAttachments and returns the data updated in the database.
     * @param {VendorAttachmentUpdateManyAndReturnArgs} args - Arguments to update many VendorAttachments.
     * @example
     * // Update many VendorAttachments
     * const vendorAttachment = await prisma.vendorAttachment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more VendorAttachments and only return the `id`
     * const vendorAttachmentWithIdOnly = await prisma.vendorAttachment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VendorAttachmentUpdateManyAndReturnArgs>(args: SelectSubset<T, VendorAttachmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VendorAttachmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one VendorAttachment.
     * @param {VendorAttachmentUpsertArgs} args - Arguments to update or create a VendorAttachment.
     * @example
     * // Update or create a VendorAttachment
     * const vendorAttachment = await prisma.vendorAttachment.upsert({
     *   create: {
     *     // ... data to create a VendorAttachment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VendorAttachment we want to update
     *   }
     * })
     */
    upsert<T extends VendorAttachmentUpsertArgs>(args: SelectSubset<T, VendorAttachmentUpsertArgs<ExtArgs>>): Prisma__VendorAttachmentClient<$Result.GetResult<Prisma.$VendorAttachmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of VendorAttachments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorAttachmentCountArgs} args - Arguments to filter VendorAttachments to count.
     * @example
     * // Count the number of VendorAttachments
     * const count = await prisma.vendorAttachment.count({
     *   where: {
     *     // ... the filter for the VendorAttachments we want to count
     *   }
     * })
    **/
    count<T extends VendorAttachmentCountArgs>(
      args?: Subset<T, VendorAttachmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VendorAttachmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VendorAttachment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorAttachmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VendorAttachmentAggregateArgs>(args: Subset<T, VendorAttachmentAggregateArgs>): Prisma.PrismaPromise<GetVendorAttachmentAggregateType<T>>

    /**
     * Group by VendorAttachment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorAttachmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VendorAttachmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VendorAttachmentGroupByArgs['orderBy'] }
        : { orderBy?: VendorAttachmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VendorAttachmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVendorAttachmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VendorAttachment model
   */
  readonly fields: VendorAttachmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VendorAttachment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VendorAttachmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    vendor<T extends VendorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VendorDefaultArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    attachment<T extends AttachmentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AttachmentDefaultArgs<ExtArgs>>): Prisma__AttachmentClient<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VendorAttachment model
   */
  interface VendorAttachmentFieldRefs {
    readonly id: FieldRef<"VendorAttachment", 'String'>
    readonly vendorId: FieldRef<"VendorAttachment", 'String'>
    readonly attachmentId: FieldRef<"VendorAttachment", 'String'>
    readonly createdAt: FieldRef<"VendorAttachment", 'DateTime'>
    readonly updatedAt: FieldRef<"VendorAttachment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * VendorAttachment findUnique
   */
  export type VendorAttachmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorAttachment
     */
    select?: VendorAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorAttachment
     */
    omit?: VendorAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which VendorAttachment to fetch.
     */
    where: VendorAttachmentWhereUniqueInput
  }

  /**
   * VendorAttachment findUniqueOrThrow
   */
  export type VendorAttachmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorAttachment
     */
    select?: VendorAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorAttachment
     */
    omit?: VendorAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which VendorAttachment to fetch.
     */
    where: VendorAttachmentWhereUniqueInput
  }

  /**
   * VendorAttachment findFirst
   */
  export type VendorAttachmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorAttachment
     */
    select?: VendorAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorAttachment
     */
    omit?: VendorAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which VendorAttachment to fetch.
     */
    where?: VendorAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VendorAttachments to fetch.
     */
    orderBy?: VendorAttachmentOrderByWithRelationInput | VendorAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VendorAttachments.
     */
    cursor?: VendorAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VendorAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VendorAttachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VendorAttachments.
     */
    distinct?: VendorAttachmentScalarFieldEnum | VendorAttachmentScalarFieldEnum[]
  }

  /**
   * VendorAttachment findFirstOrThrow
   */
  export type VendorAttachmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorAttachment
     */
    select?: VendorAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorAttachment
     */
    omit?: VendorAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which VendorAttachment to fetch.
     */
    where?: VendorAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VendorAttachments to fetch.
     */
    orderBy?: VendorAttachmentOrderByWithRelationInput | VendorAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VendorAttachments.
     */
    cursor?: VendorAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VendorAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VendorAttachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VendorAttachments.
     */
    distinct?: VendorAttachmentScalarFieldEnum | VendorAttachmentScalarFieldEnum[]
  }

  /**
   * VendorAttachment findMany
   */
  export type VendorAttachmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorAttachment
     */
    select?: VendorAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorAttachment
     */
    omit?: VendorAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which VendorAttachments to fetch.
     */
    where?: VendorAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VendorAttachments to fetch.
     */
    orderBy?: VendorAttachmentOrderByWithRelationInput | VendorAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VendorAttachments.
     */
    cursor?: VendorAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VendorAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VendorAttachments.
     */
    skip?: number
    distinct?: VendorAttachmentScalarFieldEnum | VendorAttachmentScalarFieldEnum[]
  }

  /**
   * VendorAttachment create
   */
  export type VendorAttachmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorAttachment
     */
    select?: VendorAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorAttachment
     */
    omit?: VendorAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorAttachmentInclude<ExtArgs> | null
    /**
     * The data needed to create a VendorAttachment.
     */
    data: XOR<VendorAttachmentCreateInput, VendorAttachmentUncheckedCreateInput>
  }

  /**
   * VendorAttachment createMany
   */
  export type VendorAttachmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VendorAttachments.
     */
    data: VendorAttachmentCreateManyInput | VendorAttachmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VendorAttachment createManyAndReturn
   */
  export type VendorAttachmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorAttachment
     */
    select?: VendorAttachmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VendorAttachment
     */
    omit?: VendorAttachmentOmit<ExtArgs> | null
    /**
     * The data used to create many VendorAttachments.
     */
    data: VendorAttachmentCreateManyInput | VendorAttachmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorAttachmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * VendorAttachment update
   */
  export type VendorAttachmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorAttachment
     */
    select?: VendorAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorAttachment
     */
    omit?: VendorAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorAttachmentInclude<ExtArgs> | null
    /**
     * The data needed to update a VendorAttachment.
     */
    data: XOR<VendorAttachmentUpdateInput, VendorAttachmentUncheckedUpdateInput>
    /**
     * Choose, which VendorAttachment to update.
     */
    where: VendorAttachmentWhereUniqueInput
  }

  /**
   * VendorAttachment updateMany
   */
  export type VendorAttachmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VendorAttachments.
     */
    data: XOR<VendorAttachmentUpdateManyMutationInput, VendorAttachmentUncheckedUpdateManyInput>
    /**
     * Filter which VendorAttachments to update
     */
    where?: VendorAttachmentWhereInput
    /**
     * Limit how many VendorAttachments to update.
     */
    limit?: number
  }

  /**
   * VendorAttachment updateManyAndReturn
   */
  export type VendorAttachmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorAttachment
     */
    select?: VendorAttachmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VendorAttachment
     */
    omit?: VendorAttachmentOmit<ExtArgs> | null
    /**
     * The data used to update VendorAttachments.
     */
    data: XOR<VendorAttachmentUpdateManyMutationInput, VendorAttachmentUncheckedUpdateManyInput>
    /**
     * Filter which VendorAttachments to update
     */
    where?: VendorAttachmentWhereInput
    /**
     * Limit how many VendorAttachments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorAttachmentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * VendorAttachment upsert
   */
  export type VendorAttachmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorAttachment
     */
    select?: VendorAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorAttachment
     */
    omit?: VendorAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorAttachmentInclude<ExtArgs> | null
    /**
     * The filter to search for the VendorAttachment to update in case it exists.
     */
    where: VendorAttachmentWhereUniqueInput
    /**
     * In case the VendorAttachment found by the `where` argument doesn't exist, create a new VendorAttachment with this data.
     */
    create: XOR<VendorAttachmentCreateInput, VendorAttachmentUncheckedCreateInput>
    /**
     * In case the VendorAttachment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VendorAttachmentUpdateInput, VendorAttachmentUncheckedUpdateInput>
  }

  /**
   * VendorAttachment delete
   */
  export type VendorAttachmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorAttachment
     */
    select?: VendorAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorAttachment
     */
    omit?: VendorAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorAttachmentInclude<ExtArgs> | null
    /**
     * Filter which VendorAttachment to delete.
     */
    where: VendorAttachmentWhereUniqueInput
  }

  /**
   * VendorAttachment deleteMany
   */
  export type VendorAttachmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VendorAttachments to delete
     */
    where?: VendorAttachmentWhereInput
    /**
     * Limit how many VendorAttachments to delete.
     */
    limit?: number
  }

  /**
   * VendorAttachment without action
   */
  export type VendorAttachmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorAttachment
     */
    select?: VendorAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorAttachment
     */
    omit?: VendorAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorAttachmentInclude<ExtArgs> | null
  }


  /**
   * Model EmployeeAttachment
   */

  export type AggregateEmployeeAttachment = {
    _count: EmployeeAttachmentCountAggregateOutputType | null
    _min: EmployeeAttachmentMinAggregateOutputType | null
    _max: EmployeeAttachmentMaxAggregateOutputType | null
  }

  export type EmployeeAttachmentMinAggregateOutputType = {
    id: string | null
    type: $Enums.EmployeeAttachmentType | null
    employeeId: string | null
    attachmentId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EmployeeAttachmentMaxAggregateOutputType = {
    id: string | null
    type: $Enums.EmployeeAttachmentType | null
    employeeId: string | null
    attachmentId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EmployeeAttachmentCountAggregateOutputType = {
    id: number
    type: number
    employeeId: number
    attachmentId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EmployeeAttachmentMinAggregateInputType = {
    id?: true
    type?: true
    employeeId?: true
    attachmentId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EmployeeAttachmentMaxAggregateInputType = {
    id?: true
    type?: true
    employeeId?: true
    attachmentId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EmployeeAttachmentCountAggregateInputType = {
    id?: true
    type?: true
    employeeId?: true
    attachmentId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EmployeeAttachmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmployeeAttachment to aggregate.
     */
    where?: EmployeeAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeeAttachments to fetch.
     */
    orderBy?: EmployeeAttachmentOrderByWithRelationInput | EmployeeAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmployeeAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeeAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeeAttachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EmployeeAttachments
    **/
    _count?: true | EmployeeAttachmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmployeeAttachmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmployeeAttachmentMaxAggregateInputType
  }

  export type GetEmployeeAttachmentAggregateType<T extends EmployeeAttachmentAggregateArgs> = {
        [P in keyof T & keyof AggregateEmployeeAttachment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmployeeAttachment[P]>
      : GetScalarType<T[P], AggregateEmployeeAttachment[P]>
  }




  export type EmployeeAttachmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeAttachmentWhereInput
    orderBy?: EmployeeAttachmentOrderByWithAggregationInput | EmployeeAttachmentOrderByWithAggregationInput[]
    by: EmployeeAttachmentScalarFieldEnum[] | EmployeeAttachmentScalarFieldEnum
    having?: EmployeeAttachmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmployeeAttachmentCountAggregateInputType | true
    _min?: EmployeeAttachmentMinAggregateInputType
    _max?: EmployeeAttachmentMaxAggregateInputType
  }

  export type EmployeeAttachmentGroupByOutputType = {
    id: string
    type: $Enums.EmployeeAttachmentType
    employeeId: string
    attachmentId: string
    createdAt: Date
    updatedAt: Date
    _count: EmployeeAttachmentCountAggregateOutputType | null
    _min: EmployeeAttachmentMinAggregateOutputType | null
    _max: EmployeeAttachmentMaxAggregateOutputType | null
  }

  type GetEmployeeAttachmentGroupByPayload<T extends EmployeeAttachmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmployeeAttachmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmployeeAttachmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmployeeAttachmentGroupByOutputType[P]>
            : GetScalarType<T[P], EmployeeAttachmentGroupByOutputType[P]>
        }
      >
    >


  export type EmployeeAttachmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    employeeId?: boolean
    attachmentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    attachment?: boolean | AttachmentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employeeAttachment"]>

  export type EmployeeAttachmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    employeeId?: boolean
    attachmentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    attachment?: boolean | AttachmentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employeeAttachment"]>

  export type EmployeeAttachmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    employeeId?: boolean
    attachmentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    attachment?: boolean | AttachmentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employeeAttachment"]>

  export type EmployeeAttachmentSelectScalar = {
    id?: boolean
    type?: boolean
    employeeId?: boolean
    attachmentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EmployeeAttachmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "type" | "employeeId" | "attachmentId" | "createdAt" | "updatedAt", ExtArgs["result"]["employeeAttachment"]>
  export type EmployeeAttachmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    attachment?: boolean | AttachmentDefaultArgs<ExtArgs>
  }
  export type EmployeeAttachmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    attachment?: boolean | AttachmentDefaultArgs<ExtArgs>
  }
  export type EmployeeAttachmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    attachment?: boolean | AttachmentDefaultArgs<ExtArgs>
  }

  export type $EmployeeAttachmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EmployeeAttachment"
    objects: {
      employee: Prisma.$EmployeePayload<ExtArgs>
      attachment: Prisma.$AttachmentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      type: $Enums.EmployeeAttachmentType
      employeeId: string
      attachmentId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["employeeAttachment"]>
    composites: {}
  }

  type EmployeeAttachmentGetPayload<S extends boolean | null | undefined | EmployeeAttachmentDefaultArgs> = $Result.GetResult<Prisma.$EmployeeAttachmentPayload, S>

  type EmployeeAttachmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EmployeeAttachmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EmployeeAttachmentCountAggregateInputType | true
    }

  export interface EmployeeAttachmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EmployeeAttachment'], meta: { name: 'EmployeeAttachment' } }
    /**
     * Find zero or one EmployeeAttachment that matches the filter.
     * @param {EmployeeAttachmentFindUniqueArgs} args - Arguments to find a EmployeeAttachment
     * @example
     * // Get one EmployeeAttachment
     * const employeeAttachment = await prisma.employeeAttachment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmployeeAttachmentFindUniqueArgs>(args: SelectSubset<T, EmployeeAttachmentFindUniqueArgs<ExtArgs>>): Prisma__EmployeeAttachmentClient<$Result.GetResult<Prisma.$EmployeeAttachmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EmployeeAttachment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EmployeeAttachmentFindUniqueOrThrowArgs} args - Arguments to find a EmployeeAttachment
     * @example
     * // Get one EmployeeAttachment
     * const employeeAttachment = await prisma.employeeAttachment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmployeeAttachmentFindUniqueOrThrowArgs>(args: SelectSubset<T, EmployeeAttachmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmployeeAttachmentClient<$Result.GetResult<Prisma.$EmployeeAttachmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmployeeAttachment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeAttachmentFindFirstArgs} args - Arguments to find a EmployeeAttachment
     * @example
     * // Get one EmployeeAttachment
     * const employeeAttachment = await prisma.employeeAttachment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmployeeAttachmentFindFirstArgs>(args?: SelectSubset<T, EmployeeAttachmentFindFirstArgs<ExtArgs>>): Prisma__EmployeeAttachmentClient<$Result.GetResult<Prisma.$EmployeeAttachmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmployeeAttachment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeAttachmentFindFirstOrThrowArgs} args - Arguments to find a EmployeeAttachment
     * @example
     * // Get one EmployeeAttachment
     * const employeeAttachment = await prisma.employeeAttachment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmployeeAttachmentFindFirstOrThrowArgs>(args?: SelectSubset<T, EmployeeAttachmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmployeeAttachmentClient<$Result.GetResult<Prisma.$EmployeeAttachmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EmployeeAttachments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeAttachmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EmployeeAttachments
     * const employeeAttachments = await prisma.employeeAttachment.findMany()
     * 
     * // Get first 10 EmployeeAttachments
     * const employeeAttachments = await prisma.employeeAttachment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const employeeAttachmentWithIdOnly = await prisma.employeeAttachment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EmployeeAttachmentFindManyArgs>(args?: SelectSubset<T, EmployeeAttachmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeeAttachmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EmployeeAttachment.
     * @param {EmployeeAttachmentCreateArgs} args - Arguments to create a EmployeeAttachment.
     * @example
     * // Create one EmployeeAttachment
     * const EmployeeAttachment = await prisma.employeeAttachment.create({
     *   data: {
     *     // ... data to create a EmployeeAttachment
     *   }
     * })
     * 
     */
    create<T extends EmployeeAttachmentCreateArgs>(args: SelectSubset<T, EmployeeAttachmentCreateArgs<ExtArgs>>): Prisma__EmployeeAttachmentClient<$Result.GetResult<Prisma.$EmployeeAttachmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EmployeeAttachments.
     * @param {EmployeeAttachmentCreateManyArgs} args - Arguments to create many EmployeeAttachments.
     * @example
     * // Create many EmployeeAttachments
     * const employeeAttachment = await prisma.employeeAttachment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmployeeAttachmentCreateManyArgs>(args?: SelectSubset<T, EmployeeAttachmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EmployeeAttachments and returns the data saved in the database.
     * @param {EmployeeAttachmentCreateManyAndReturnArgs} args - Arguments to create many EmployeeAttachments.
     * @example
     * // Create many EmployeeAttachments
     * const employeeAttachment = await prisma.employeeAttachment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EmployeeAttachments and only return the `id`
     * const employeeAttachmentWithIdOnly = await prisma.employeeAttachment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EmployeeAttachmentCreateManyAndReturnArgs>(args?: SelectSubset<T, EmployeeAttachmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeeAttachmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a EmployeeAttachment.
     * @param {EmployeeAttachmentDeleteArgs} args - Arguments to delete one EmployeeAttachment.
     * @example
     * // Delete one EmployeeAttachment
     * const EmployeeAttachment = await prisma.employeeAttachment.delete({
     *   where: {
     *     // ... filter to delete one EmployeeAttachment
     *   }
     * })
     * 
     */
    delete<T extends EmployeeAttachmentDeleteArgs>(args: SelectSubset<T, EmployeeAttachmentDeleteArgs<ExtArgs>>): Prisma__EmployeeAttachmentClient<$Result.GetResult<Prisma.$EmployeeAttachmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EmployeeAttachment.
     * @param {EmployeeAttachmentUpdateArgs} args - Arguments to update one EmployeeAttachment.
     * @example
     * // Update one EmployeeAttachment
     * const employeeAttachment = await prisma.employeeAttachment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmployeeAttachmentUpdateArgs>(args: SelectSubset<T, EmployeeAttachmentUpdateArgs<ExtArgs>>): Prisma__EmployeeAttachmentClient<$Result.GetResult<Prisma.$EmployeeAttachmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EmployeeAttachments.
     * @param {EmployeeAttachmentDeleteManyArgs} args - Arguments to filter EmployeeAttachments to delete.
     * @example
     * // Delete a few EmployeeAttachments
     * const { count } = await prisma.employeeAttachment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmployeeAttachmentDeleteManyArgs>(args?: SelectSubset<T, EmployeeAttachmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmployeeAttachments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeAttachmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EmployeeAttachments
     * const employeeAttachment = await prisma.employeeAttachment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmployeeAttachmentUpdateManyArgs>(args: SelectSubset<T, EmployeeAttachmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmployeeAttachments and returns the data updated in the database.
     * @param {EmployeeAttachmentUpdateManyAndReturnArgs} args - Arguments to update many EmployeeAttachments.
     * @example
     * // Update many EmployeeAttachments
     * const employeeAttachment = await prisma.employeeAttachment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more EmployeeAttachments and only return the `id`
     * const employeeAttachmentWithIdOnly = await prisma.employeeAttachment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EmployeeAttachmentUpdateManyAndReturnArgs>(args: SelectSubset<T, EmployeeAttachmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeeAttachmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one EmployeeAttachment.
     * @param {EmployeeAttachmentUpsertArgs} args - Arguments to update or create a EmployeeAttachment.
     * @example
     * // Update or create a EmployeeAttachment
     * const employeeAttachment = await prisma.employeeAttachment.upsert({
     *   create: {
     *     // ... data to create a EmployeeAttachment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EmployeeAttachment we want to update
     *   }
     * })
     */
    upsert<T extends EmployeeAttachmentUpsertArgs>(args: SelectSubset<T, EmployeeAttachmentUpsertArgs<ExtArgs>>): Prisma__EmployeeAttachmentClient<$Result.GetResult<Prisma.$EmployeeAttachmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EmployeeAttachments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeAttachmentCountArgs} args - Arguments to filter EmployeeAttachments to count.
     * @example
     * // Count the number of EmployeeAttachments
     * const count = await prisma.employeeAttachment.count({
     *   where: {
     *     // ... the filter for the EmployeeAttachments we want to count
     *   }
     * })
    **/
    count<T extends EmployeeAttachmentCountArgs>(
      args?: Subset<T, EmployeeAttachmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmployeeAttachmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EmployeeAttachment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeAttachmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmployeeAttachmentAggregateArgs>(args: Subset<T, EmployeeAttachmentAggregateArgs>): Prisma.PrismaPromise<GetEmployeeAttachmentAggregateType<T>>

    /**
     * Group by EmployeeAttachment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeAttachmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmployeeAttachmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmployeeAttachmentGroupByArgs['orderBy'] }
        : { orderBy?: EmployeeAttachmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmployeeAttachmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmployeeAttachmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EmployeeAttachment model
   */
  readonly fields: EmployeeAttachmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EmployeeAttachment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmployeeAttachmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    employee<T extends EmployeeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmployeeDefaultArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    attachment<T extends AttachmentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AttachmentDefaultArgs<ExtArgs>>): Prisma__AttachmentClient<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EmployeeAttachment model
   */
  interface EmployeeAttachmentFieldRefs {
    readonly id: FieldRef<"EmployeeAttachment", 'String'>
    readonly type: FieldRef<"EmployeeAttachment", 'EmployeeAttachmentType'>
    readonly employeeId: FieldRef<"EmployeeAttachment", 'String'>
    readonly attachmentId: FieldRef<"EmployeeAttachment", 'String'>
    readonly createdAt: FieldRef<"EmployeeAttachment", 'DateTime'>
    readonly updatedAt: FieldRef<"EmployeeAttachment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EmployeeAttachment findUnique
   */
  export type EmployeeAttachmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeAttachment
     */
    select?: EmployeeAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeAttachment
     */
    omit?: EmployeeAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeAttachment to fetch.
     */
    where: EmployeeAttachmentWhereUniqueInput
  }

  /**
   * EmployeeAttachment findUniqueOrThrow
   */
  export type EmployeeAttachmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeAttachment
     */
    select?: EmployeeAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeAttachment
     */
    omit?: EmployeeAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeAttachment to fetch.
     */
    where: EmployeeAttachmentWhereUniqueInput
  }

  /**
   * EmployeeAttachment findFirst
   */
  export type EmployeeAttachmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeAttachment
     */
    select?: EmployeeAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeAttachment
     */
    omit?: EmployeeAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeAttachment to fetch.
     */
    where?: EmployeeAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeeAttachments to fetch.
     */
    orderBy?: EmployeeAttachmentOrderByWithRelationInput | EmployeeAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmployeeAttachments.
     */
    cursor?: EmployeeAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeeAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeeAttachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmployeeAttachments.
     */
    distinct?: EmployeeAttachmentScalarFieldEnum | EmployeeAttachmentScalarFieldEnum[]
  }

  /**
   * EmployeeAttachment findFirstOrThrow
   */
  export type EmployeeAttachmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeAttachment
     */
    select?: EmployeeAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeAttachment
     */
    omit?: EmployeeAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeAttachment to fetch.
     */
    where?: EmployeeAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeeAttachments to fetch.
     */
    orderBy?: EmployeeAttachmentOrderByWithRelationInput | EmployeeAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmployeeAttachments.
     */
    cursor?: EmployeeAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeeAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeeAttachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmployeeAttachments.
     */
    distinct?: EmployeeAttachmentScalarFieldEnum | EmployeeAttachmentScalarFieldEnum[]
  }

  /**
   * EmployeeAttachment findMany
   */
  export type EmployeeAttachmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeAttachment
     */
    select?: EmployeeAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeAttachment
     */
    omit?: EmployeeAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeAttachments to fetch.
     */
    where?: EmployeeAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeeAttachments to fetch.
     */
    orderBy?: EmployeeAttachmentOrderByWithRelationInput | EmployeeAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EmployeeAttachments.
     */
    cursor?: EmployeeAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeeAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeeAttachments.
     */
    skip?: number
    distinct?: EmployeeAttachmentScalarFieldEnum | EmployeeAttachmentScalarFieldEnum[]
  }

  /**
   * EmployeeAttachment create
   */
  export type EmployeeAttachmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeAttachment
     */
    select?: EmployeeAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeAttachment
     */
    omit?: EmployeeAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeAttachmentInclude<ExtArgs> | null
    /**
     * The data needed to create a EmployeeAttachment.
     */
    data: XOR<EmployeeAttachmentCreateInput, EmployeeAttachmentUncheckedCreateInput>
  }

  /**
   * EmployeeAttachment createMany
   */
  export type EmployeeAttachmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EmployeeAttachments.
     */
    data: EmployeeAttachmentCreateManyInput | EmployeeAttachmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EmployeeAttachment createManyAndReturn
   */
  export type EmployeeAttachmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeAttachment
     */
    select?: EmployeeAttachmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeAttachment
     */
    omit?: EmployeeAttachmentOmit<ExtArgs> | null
    /**
     * The data used to create many EmployeeAttachments.
     */
    data: EmployeeAttachmentCreateManyInput | EmployeeAttachmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeAttachmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EmployeeAttachment update
   */
  export type EmployeeAttachmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeAttachment
     */
    select?: EmployeeAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeAttachment
     */
    omit?: EmployeeAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeAttachmentInclude<ExtArgs> | null
    /**
     * The data needed to update a EmployeeAttachment.
     */
    data: XOR<EmployeeAttachmentUpdateInput, EmployeeAttachmentUncheckedUpdateInput>
    /**
     * Choose, which EmployeeAttachment to update.
     */
    where: EmployeeAttachmentWhereUniqueInput
  }

  /**
   * EmployeeAttachment updateMany
   */
  export type EmployeeAttachmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EmployeeAttachments.
     */
    data: XOR<EmployeeAttachmentUpdateManyMutationInput, EmployeeAttachmentUncheckedUpdateManyInput>
    /**
     * Filter which EmployeeAttachments to update
     */
    where?: EmployeeAttachmentWhereInput
    /**
     * Limit how many EmployeeAttachments to update.
     */
    limit?: number
  }

  /**
   * EmployeeAttachment updateManyAndReturn
   */
  export type EmployeeAttachmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeAttachment
     */
    select?: EmployeeAttachmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeAttachment
     */
    omit?: EmployeeAttachmentOmit<ExtArgs> | null
    /**
     * The data used to update EmployeeAttachments.
     */
    data: XOR<EmployeeAttachmentUpdateManyMutationInput, EmployeeAttachmentUncheckedUpdateManyInput>
    /**
     * Filter which EmployeeAttachments to update
     */
    where?: EmployeeAttachmentWhereInput
    /**
     * Limit how many EmployeeAttachments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeAttachmentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * EmployeeAttachment upsert
   */
  export type EmployeeAttachmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeAttachment
     */
    select?: EmployeeAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeAttachment
     */
    omit?: EmployeeAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeAttachmentInclude<ExtArgs> | null
    /**
     * The filter to search for the EmployeeAttachment to update in case it exists.
     */
    where: EmployeeAttachmentWhereUniqueInput
    /**
     * In case the EmployeeAttachment found by the `where` argument doesn't exist, create a new EmployeeAttachment with this data.
     */
    create: XOR<EmployeeAttachmentCreateInput, EmployeeAttachmentUncheckedCreateInput>
    /**
     * In case the EmployeeAttachment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmployeeAttachmentUpdateInput, EmployeeAttachmentUncheckedUpdateInput>
  }

  /**
   * EmployeeAttachment delete
   */
  export type EmployeeAttachmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeAttachment
     */
    select?: EmployeeAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeAttachment
     */
    omit?: EmployeeAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeAttachmentInclude<ExtArgs> | null
    /**
     * Filter which EmployeeAttachment to delete.
     */
    where: EmployeeAttachmentWhereUniqueInput
  }

  /**
   * EmployeeAttachment deleteMany
   */
  export type EmployeeAttachmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmployeeAttachments to delete
     */
    where?: EmployeeAttachmentWhereInput
    /**
     * Limit how many EmployeeAttachments to delete.
     */
    limit?: number
  }

  /**
   * EmployeeAttachment without action
   */
  export type EmployeeAttachmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeAttachment
     */
    select?: EmployeeAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeAttachment
     */
    omit?: EmployeeAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeAttachmentInclude<ExtArgs> | null
  }


  /**
   * Model EmployeePermission
   */

  export type AggregateEmployeePermission = {
    _count: EmployeePermissionCountAggregateOutputType | null
    _min: EmployeePermissionMinAggregateOutputType | null
    _max: EmployeePermissionMaxAggregateOutputType | null
  }

  export type EmployeePermissionMinAggregateOutputType = {
    id: string | null
    employeeId: string | null
    permissionId: string | null
    grantedAt: Date | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EmployeePermissionMaxAggregateOutputType = {
    id: string | null
    employeeId: string | null
    permissionId: string | null
    grantedAt: Date | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EmployeePermissionCountAggregateOutputType = {
    id: number
    employeeId: number
    permissionId: number
    grantedAt: number
    expiresAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EmployeePermissionMinAggregateInputType = {
    id?: true
    employeeId?: true
    permissionId?: true
    grantedAt?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EmployeePermissionMaxAggregateInputType = {
    id?: true
    employeeId?: true
    permissionId?: true
    grantedAt?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EmployeePermissionCountAggregateInputType = {
    id?: true
    employeeId?: true
    permissionId?: true
    grantedAt?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EmployeePermissionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmployeePermission to aggregate.
     */
    where?: EmployeePermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeePermissions to fetch.
     */
    orderBy?: EmployeePermissionOrderByWithRelationInput | EmployeePermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmployeePermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeePermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeePermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EmployeePermissions
    **/
    _count?: true | EmployeePermissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmployeePermissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmployeePermissionMaxAggregateInputType
  }

  export type GetEmployeePermissionAggregateType<T extends EmployeePermissionAggregateArgs> = {
        [P in keyof T & keyof AggregateEmployeePermission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmployeePermission[P]>
      : GetScalarType<T[P], AggregateEmployeePermission[P]>
  }




  export type EmployeePermissionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeePermissionWhereInput
    orderBy?: EmployeePermissionOrderByWithAggregationInput | EmployeePermissionOrderByWithAggregationInput[]
    by: EmployeePermissionScalarFieldEnum[] | EmployeePermissionScalarFieldEnum
    having?: EmployeePermissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmployeePermissionCountAggregateInputType | true
    _min?: EmployeePermissionMinAggregateInputType
    _max?: EmployeePermissionMaxAggregateInputType
  }

  export type EmployeePermissionGroupByOutputType = {
    id: string
    employeeId: string
    permissionId: string
    grantedAt: Date
    expiresAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: EmployeePermissionCountAggregateOutputType | null
    _min: EmployeePermissionMinAggregateOutputType | null
    _max: EmployeePermissionMaxAggregateOutputType | null
  }

  type GetEmployeePermissionGroupByPayload<T extends EmployeePermissionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmployeePermissionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmployeePermissionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmployeePermissionGroupByOutputType[P]>
            : GetScalarType<T[P], EmployeePermissionGroupByOutputType[P]>
        }
      >
    >


  export type EmployeePermissionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    permissionId?: boolean
    grantedAt?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    permission?: boolean | PermissionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employeePermission"]>

  export type EmployeePermissionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    permissionId?: boolean
    grantedAt?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    permission?: boolean | PermissionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employeePermission"]>

  export type EmployeePermissionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    permissionId?: boolean
    grantedAt?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    permission?: boolean | PermissionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employeePermission"]>

  export type EmployeePermissionSelectScalar = {
    id?: boolean
    employeeId?: boolean
    permissionId?: boolean
    grantedAt?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EmployeePermissionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "employeeId" | "permissionId" | "grantedAt" | "expiresAt" | "createdAt" | "updatedAt", ExtArgs["result"]["employeePermission"]>
  export type EmployeePermissionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    permission?: boolean | PermissionDefaultArgs<ExtArgs>
  }
  export type EmployeePermissionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    permission?: boolean | PermissionDefaultArgs<ExtArgs>
  }
  export type EmployeePermissionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    permission?: boolean | PermissionDefaultArgs<ExtArgs>
  }

  export type $EmployeePermissionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EmployeePermission"
    objects: {
      employee: Prisma.$EmployeePayload<ExtArgs>
      permission: Prisma.$PermissionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      employeeId: string
      permissionId: string
      grantedAt: Date
      expiresAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["employeePermission"]>
    composites: {}
  }

  type EmployeePermissionGetPayload<S extends boolean | null | undefined | EmployeePermissionDefaultArgs> = $Result.GetResult<Prisma.$EmployeePermissionPayload, S>

  type EmployeePermissionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EmployeePermissionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EmployeePermissionCountAggregateInputType | true
    }

  export interface EmployeePermissionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EmployeePermission'], meta: { name: 'EmployeePermission' } }
    /**
     * Find zero or one EmployeePermission that matches the filter.
     * @param {EmployeePermissionFindUniqueArgs} args - Arguments to find a EmployeePermission
     * @example
     * // Get one EmployeePermission
     * const employeePermission = await prisma.employeePermission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmployeePermissionFindUniqueArgs>(args: SelectSubset<T, EmployeePermissionFindUniqueArgs<ExtArgs>>): Prisma__EmployeePermissionClient<$Result.GetResult<Prisma.$EmployeePermissionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EmployeePermission that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EmployeePermissionFindUniqueOrThrowArgs} args - Arguments to find a EmployeePermission
     * @example
     * // Get one EmployeePermission
     * const employeePermission = await prisma.employeePermission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmployeePermissionFindUniqueOrThrowArgs>(args: SelectSubset<T, EmployeePermissionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmployeePermissionClient<$Result.GetResult<Prisma.$EmployeePermissionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmployeePermission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeePermissionFindFirstArgs} args - Arguments to find a EmployeePermission
     * @example
     * // Get one EmployeePermission
     * const employeePermission = await prisma.employeePermission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmployeePermissionFindFirstArgs>(args?: SelectSubset<T, EmployeePermissionFindFirstArgs<ExtArgs>>): Prisma__EmployeePermissionClient<$Result.GetResult<Prisma.$EmployeePermissionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmployeePermission that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeePermissionFindFirstOrThrowArgs} args - Arguments to find a EmployeePermission
     * @example
     * // Get one EmployeePermission
     * const employeePermission = await prisma.employeePermission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmployeePermissionFindFirstOrThrowArgs>(args?: SelectSubset<T, EmployeePermissionFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmployeePermissionClient<$Result.GetResult<Prisma.$EmployeePermissionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EmployeePermissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeePermissionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EmployeePermissions
     * const employeePermissions = await prisma.employeePermission.findMany()
     * 
     * // Get first 10 EmployeePermissions
     * const employeePermissions = await prisma.employeePermission.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const employeePermissionWithIdOnly = await prisma.employeePermission.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EmployeePermissionFindManyArgs>(args?: SelectSubset<T, EmployeePermissionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeePermissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EmployeePermission.
     * @param {EmployeePermissionCreateArgs} args - Arguments to create a EmployeePermission.
     * @example
     * // Create one EmployeePermission
     * const EmployeePermission = await prisma.employeePermission.create({
     *   data: {
     *     // ... data to create a EmployeePermission
     *   }
     * })
     * 
     */
    create<T extends EmployeePermissionCreateArgs>(args: SelectSubset<T, EmployeePermissionCreateArgs<ExtArgs>>): Prisma__EmployeePermissionClient<$Result.GetResult<Prisma.$EmployeePermissionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EmployeePermissions.
     * @param {EmployeePermissionCreateManyArgs} args - Arguments to create many EmployeePermissions.
     * @example
     * // Create many EmployeePermissions
     * const employeePermission = await prisma.employeePermission.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmployeePermissionCreateManyArgs>(args?: SelectSubset<T, EmployeePermissionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EmployeePermissions and returns the data saved in the database.
     * @param {EmployeePermissionCreateManyAndReturnArgs} args - Arguments to create many EmployeePermissions.
     * @example
     * // Create many EmployeePermissions
     * const employeePermission = await prisma.employeePermission.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EmployeePermissions and only return the `id`
     * const employeePermissionWithIdOnly = await prisma.employeePermission.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EmployeePermissionCreateManyAndReturnArgs>(args?: SelectSubset<T, EmployeePermissionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeePermissionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a EmployeePermission.
     * @param {EmployeePermissionDeleteArgs} args - Arguments to delete one EmployeePermission.
     * @example
     * // Delete one EmployeePermission
     * const EmployeePermission = await prisma.employeePermission.delete({
     *   where: {
     *     // ... filter to delete one EmployeePermission
     *   }
     * })
     * 
     */
    delete<T extends EmployeePermissionDeleteArgs>(args: SelectSubset<T, EmployeePermissionDeleteArgs<ExtArgs>>): Prisma__EmployeePermissionClient<$Result.GetResult<Prisma.$EmployeePermissionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EmployeePermission.
     * @param {EmployeePermissionUpdateArgs} args - Arguments to update one EmployeePermission.
     * @example
     * // Update one EmployeePermission
     * const employeePermission = await prisma.employeePermission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmployeePermissionUpdateArgs>(args: SelectSubset<T, EmployeePermissionUpdateArgs<ExtArgs>>): Prisma__EmployeePermissionClient<$Result.GetResult<Prisma.$EmployeePermissionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EmployeePermissions.
     * @param {EmployeePermissionDeleteManyArgs} args - Arguments to filter EmployeePermissions to delete.
     * @example
     * // Delete a few EmployeePermissions
     * const { count } = await prisma.employeePermission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmployeePermissionDeleteManyArgs>(args?: SelectSubset<T, EmployeePermissionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmployeePermissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeePermissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EmployeePermissions
     * const employeePermission = await prisma.employeePermission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmployeePermissionUpdateManyArgs>(args: SelectSubset<T, EmployeePermissionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmployeePermissions and returns the data updated in the database.
     * @param {EmployeePermissionUpdateManyAndReturnArgs} args - Arguments to update many EmployeePermissions.
     * @example
     * // Update many EmployeePermissions
     * const employeePermission = await prisma.employeePermission.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more EmployeePermissions and only return the `id`
     * const employeePermissionWithIdOnly = await prisma.employeePermission.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EmployeePermissionUpdateManyAndReturnArgs>(args: SelectSubset<T, EmployeePermissionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeePermissionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one EmployeePermission.
     * @param {EmployeePermissionUpsertArgs} args - Arguments to update or create a EmployeePermission.
     * @example
     * // Update or create a EmployeePermission
     * const employeePermission = await prisma.employeePermission.upsert({
     *   create: {
     *     // ... data to create a EmployeePermission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EmployeePermission we want to update
     *   }
     * })
     */
    upsert<T extends EmployeePermissionUpsertArgs>(args: SelectSubset<T, EmployeePermissionUpsertArgs<ExtArgs>>): Prisma__EmployeePermissionClient<$Result.GetResult<Prisma.$EmployeePermissionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EmployeePermissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeePermissionCountArgs} args - Arguments to filter EmployeePermissions to count.
     * @example
     * // Count the number of EmployeePermissions
     * const count = await prisma.employeePermission.count({
     *   where: {
     *     // ... the filter for the EmployeePermissions we want to count
     *   }
     * })
    **/
    count<T extends EmployeePermissionCountArgs>(
      args?: Subset<T, EmployeePermissionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmployeePermissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EmployeePermission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeePermissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmployeePermissionAggregateArgs>(args: Subset<T, EmployeePermissionAggregateArgs>): Prisma.PrismaPromise<GetEmployeePermissionAggregateType<T>>

    /**
     * Group by EmployeePermission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeePermissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmployeePermissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmployeePermissionGroupByArgs['orderBy'] }
        : { orderBy?: EmployeePermissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmployeePermissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmployeePermissionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EmployeePermission model
   */
  readonly fields: EmployeePermissionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EmployeePermission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmployeePermissionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    employee<T extends EmployeeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmployeeDefaultArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    permission<T extends PermissionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PermissionDefaultArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EmployeePermission model
   */
  interface EmployeePermissionFieldRefs {
    readonly id: FieldRef<"EmployeePermission", 'String'>
    readonly employeeId: FieldRef<"EmployeePermission", 'String'>
    readonly permissionId: FieldRef<"EmployeePermission", 'String'>
    readonly grantedAt: FieldRef<"EmployeePermission", 'DateTime'>
    readonly expiresAt: FieldRef<"EmployeePermission", 'DateTime'>
    readonly createdAt: FieldRef<"EmployeePermission", 'DateTime'>
    readonly updatedAt: FieldRef<"EmployeePermission", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EmployeePermission findUnique
   */
  export type EmployeePermissionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeePermission
     */
    select?: EmployeePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeePermission
     */
    omit?: EmployeePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeePermissionInclude<ExtArgs> | null
    /**
     * Filter, which EmployeePermission to fetch.
     */
    where: EmployeePermissionWhereUniqueInput
  }

  /**
   * EmployeePermission findUniqueOrThrow
   */
  export type EmployeePermissionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeePermission
     */
    select?: EmployeePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeePermission
     */
    omit?: EmployeePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeePermissionInclude<ExtArgs> | null
    /**
     * Filter, which EmployeePermission to fetch.
     */
    where: EmployeePermissionWhereUniqueInput
  }

  /**
   * EmployeePermission findFirst
   */
  export type EmployeePermissionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeePermission
     */
    select?: EmployeePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeePermission
     */
    omit?: EmployeePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeePermissionInclude<ExtArgs> | null
    /**
     * Filter, which EmployeePermission to fetch.
     */
    where?: EmployeePermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeePermissions to fetch.
     */
    orderBy?: EmployeePermissionOrderByWithRelationInput | EmployeePermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmployeePermissions.
     */
    cursor?: EmployeePermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeePermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeePermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmployeePermissions.
     */
    distinct?: EmployeePermissionScalarFieldEnum | EmployeePermissionScalarFieldEnum[]
  }

  /**
   * EmployeePermission findFirstOrThrow
   */
  export type EmployeePermissionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeePermission
     */
    select?: EmployeePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeePermission
     */
    omit?: EmployeePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeePermissionInclude<ExtArgs> | null
    /**
     * Filter, which EmployeePermission to fetch.
     */
    where?: EmployeePermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeePermissions to fetch.
     */
    orderBy?: EmployeePermissionOrderByWithRelationInput | EmployeePermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmployeePermissions.
     */
    cursor?: EmployeePermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeePermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeePermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmployeePermissions.
     */
    distinct?: EmployeePermissionScalarFieldEnum | EmployeePermissionScalarFieldEnum[]
  }

  /**
   * EmployeePermission findMany
   */
  export type EmployeePermissionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeePermission
     */
    select?: EmployeePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeePermission
     */
    omit?: EmployeePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeePermissionInclude<ExtArgs> | null
    /**
     * Filter, which EmployeePermissions to fetch.
     */
    where?: EmployeePermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeePermissions to fetch.
     */
    orderBy?: EmployeePermissionOrderByWithRelationInput | EmployeePermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EmployeePermissions.
     */
    cursor?: EmployeePermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeePermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeePermissions.
     */
    skip?: number
    distinct?: EmployeePermissionScalarFieldEnum | EmployeePermissionScalarFieldEnum[]
  }

  /**
   * EmployeePermission create
   */
  export type EmployeePermissionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeePermission
     */
    select?: EmployeePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeePermission
     */
    omit?: EmployeePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeePermissionInclude<ExtArgs> | null
    /**
     * The data needed to create a EmployeePermission.
     */
    data: XOR<EmployeePermissionCreateInput, EmployeePermissionUncheckedCreateInput>
  }

  /**
   * EmployeePermission createMany
   */
  export type EmployeePermissionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EmployeePermissions.
     */
    data: EmployeePermissionCreateManyInput | EmployeePermissionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EmployeePermission createManyAndReturn
   */
  export type EmployeePermissionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeePermission
     */
    select?: EmployeePermissionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeePermission
     */
    omit?: EmployeePermissionOmit<ExtArgs> | null
    /**
     * The data used to create many EmployeePermissions.
     */
    data: EmployeePermissionCreateManyInput | EmployeePermissionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeePermissionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EmployeePermission update
   */
  export type EmployeePermissionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeePermission
     */
    select?: EmployeePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeePermission
     */
    omit?: EmployeePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeePermissionInclude<ExtArgs> | null
    /**
     * The data needed to update a EmployeePermission.
     */
    data: XOR<EmployeePermissionUpdateInput, EmployeePermissionUncheckedUpdateInput>
    /**
     * Choose, which EmployeePermission to update.
     */
    where: EmployeePermissionWhereUniqueInput
  }

  /**
   * EmployeePermission updateMany
   */
  export type EmployeePermissionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EmployeePermissions.
     */
    data: XOR<EmployeePermissionUpdateManyMutationInput, EmployeePermissionUncheckedUpdateManyInput>
    /**
     * Filter which EmployeePermissions to update
     */
    where?: EmployeePermissionWhereInput
    /**
     * Limit how many EmployeePermissions to update.
     */
    limit?: number
  }

  /**
   * EmployeePermission updateManyAndReturn
   */
  export type EmployeePermissionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeePermission
     */
    select?: EmployeePermissionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeePermission
     */
    omit?: EmployeePermissionOmit<ExtArgs> | null
    /**
     * The data used to update EmployeePermissions.
     */
    data: XOR<EmployeePermissionUpdateManyMutationInput, EmployeePermissionUncheckedUpdateManyInput>
    /**
     * Filter which EmployeePermissions to update
     */
    where?: EmployeePermissionWhereInput
    /**
     * Limit how many EmployeePermissions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeePermissionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * EmployeePermission upsert
   */
  export type EmployeePermissionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeePermission
     */
    select?: EmployeePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeePermission
     */
    omit?: EmployeePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeePermissionInclude<ExtArgs> | null
    /**
     * The filter to search for the EmployeePermission to update in case it exists.
     */
    where: EmployeePermissionWhereUniqueInput
    /**
     * In case the EmployeePermission found by the `where` argument doesn't exist, create a new EmployeePermission with this data.
     */
    create: XOR<EmployeePermissionCreateInput, EmployeePermissionUncheckedCreateInput>
    /**
     * In case the EmployeePermission was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmployeePermissionUpdateInput, EmployeePermissionUncheckedUpdateInput>
  }

  /**
   * EmployeePermission delete
   */
  export type EmployeePermissionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeePermission
     */
    select?: EmployeePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeePermission
     */
    omit?: EmployeePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeePermissionInclude<ExtArgs> | null
    /**
     * Filter which EmployeePermission to delete.
     */
    where: EmployeePermissionWhereUniqueInput
  }

  /**
   * EmployeePermission deleteMany
   */
  export type EmployeePermissionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmployeePermissions to delete
     */
    where?: EmployeePermissionWhereInput
    /**
     * Limit how many EmployeePermissions to delete.
     */
    limit?: number
  }

  /**
   * EmployeePermission without action
   */
  export type EmployeePermissionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeePermission
     */
    select?: EmployeePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeePermission
     */
    omit?: EmployeePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeePermissionInclude<ExtArgs> | null
  }


  /**
   * Model VendorGate
   */

  export type AggregateVendorGate = {
    _count: VendorGateCountAggregateOutputType | null
    _min: VendorGateMinAggregateOutputType | null
    _max: VendorGateMaxAggregateOutputType | null
  }

  export type VendorGateMinAggregateOutputType = {
    id: string | null
    vendorId: string | null
    gateId: string | null
    createdAt: Date | null
  }

  export type VendorGateMaxAggregateOutputType = {
    id: string | null
    vendorId: string | null
    gateId: string | null
    createdAt: Date | null
  }

  export type VendorGateCountAggregateOutputType = {
    id: number
    vendorId: number
    gateId: number
    createdAt: number
    _all: number
  }


  export type VendorGateMinAggregateInputType = {
    id?: true
    vendorId?: true
    gateId?: true
    createdAt?: true
  }

  export type VendorGateMaxAggregateInputType = {
    id?: true
    vendorId?: true
    gateId?: true
    createdAt?: true
  }

  export type VendorGateCountAggregateInputType = {
    id?: true
    vendorId?: true
    gateId?: true
    createdAt?: true
    _all?: true
  }

  export type VendorGateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VendorGate to aggregate.
     */
    where?: VendorGateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VendorGates to fetch.
     */
    orderBy?: VendorGateOrderByWithRelationInput | VendorGateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VendorGateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VendorGates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VendorGates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VendorGates
    **/
    _count?: true | VendorGateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VendorGateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VendorGateMaxAggregateInputType
  }

  export type GetVendorGateAggregateType<T extends VendorGateAggregateArgs> = {
        [P in keyof T & keyof AggregateVendorGate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVendorGate[P]>
      : GetScalarType<T[P], AggregateVendorGate[P]>
  }




  export type VendorGateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VendorGateWhereInput
    orderBy?: VendorGateOrderByWithAggregationInput | VendorGateOrderByWithAggregationInput[]
    by: VendorGateScalarFieldEnum[] | VendorGateScalarFieldEnum
    having?: VendorGateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VendorGateCountAggregateInputType | true
    _min?: VendorGateMinAggregateInputType
    _max?: VendorGateMaxAggregateInputType
  }

  export type VendorGateGroupByOutputType = {
    id: string
    vendorId: string
    gateId: string
    createdAt: Date
    _count: VendorGateCountAggregateOutputType | null
    _min: VendorGateMinAggregateOutputType | null
    _max: VendorGateMaxAggregateOutputType | null
  }

  type GetVendorGateGroupByPayload<T extends VendorGateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VendorGateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VendorGateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VendorGateGroupByOutputType[P]>
            : GetScalarType<T[P], VendorGateGroupByOutputType[P]>
        }
      >
    >


  export type VendorGateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    vendorId?: boolean
    gateId?: boolean
    createdAt?: boolean
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
    gate?: boolean | GateDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vendorGate"]>

  export type VendorGateSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    vendorId?: boolean
    gateId?: boolean
    createdAt?: boolean
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
    gate?: boolean | GateDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vendorGate"]>

  export type VendorGateSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    vendorId?: boolean
    gateId?: boolean
    createdAt?: boolean
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
    gate?: boolean | GateDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vendorGate"]>

  export type VendorGateSelectScalar = {
    id?: boolean
    vendorId?: boolean
    gateId?: boolean
    createdAt?: boolean
  }

  export type VendorGateOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "vendorId" | "gateId" | "createdAt", ExtArgs["result"]["vendorGate"]>
  export type VendorGateInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
    gate?: boolean | GateDefaultArgs<ExtArgs>
  }
  export type VendorGateIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
    gate?: boolean | GateDefaultArgs<ExtArgs>
  }
  export type VendorGateIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
    gate?: boolean | GateDefaultArgs<ExtArgs>
  }

  export type $VendorGatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VendorGate"
    objects: {
      vendor: Prisma.$VendorPayload<ExtArgs>
      gate: Prisma.$GatePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      vendorId: string
      gateId: string
      createdAt: Date
    }, ExtArgs["result"]["vendorGate"]>
    composites: {}
  }

  type VendorGateGetPayload<S extends boolean | null | undefined | VendorGateDefaultArgs> = $Result.GetResult<Prisma.$VendorGatePayload, S>

  type VendorGateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VendorGateFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VendorGateCountAggregateInputType | true
    }

  export interface VendorGateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VendorGate'], meta: { name: 'VendorGate' } }
    /**
     * Find zero or one VendorGate that matches the filter.
     * @param {VendorGateFindUniqueArgs} args - Arguments to find a VendorGate
     * @example
     * // Get one VendorGate
     * const vendorGate = await prisma.vendorGate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VendorGateFindUniqueArgs>(args: SelectSubset<T, VendorGateFindUniqueArgs<ExtArgs>>): Prisma__VendorGateClient<$Result.GetResult<Prisma.$VendorGatePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one VendorGate that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VendorGateFindUniqueOrThrowArgs} args - Arguments to find a VendorGate
     * @example
     * // Get one VendorGate
     * const vendorGate = await prisma.vendorGate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VendorGateFindUniqueOrThrowArgs>(args: SelectSubset<T, VendorGateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VendorGateClient<$Result.GetResult<Prisma.$VendorGatePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VendorGate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorGateFindFirstArgs} args - Arguments to find a VendorGate
     * @example
     * // Get one VendorGate
     * const vendorGate = await prisma.vendorGate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VendorGateFindFirstArgs>(args?: SelectSubset<T, VendorGateFindFirstArgs<ExtArgs>>): Prisma__VendorGateClient<$Result.GetResult<Prisma.$VendorGatePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VendorGate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorGateFindFirstOrThrowArgs} args - Arguments to find a VendorGate
     * @example
     * // Get one VendorGate
     * const vendorGate = await prisma.vendorGate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VendorGateFindFirstOrThrowArgs>(args?: SelectSubset<T, VendorGateFindFirstOrThrowArgs<ExtArgs>>): Prisma__VendorGateClient<$Result.GetResult<Prisma.$VendorGatePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more VendorGates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorGateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VendorGates
     * const vendorGates = await prisma.vendorGate.findMany()
     * 
     * // Get first 10 VendorGates
     * const vendorGates = await prisma.vendorGate.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const vendorGateWithIdOnly = await prisma.vendorGate.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VendorGateFindManyArgs>(args?: SelectSubset<T, VendorGateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VendorGatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a VendorGate.
     * @param {VendorGateCreateArgs} args - Arguments to create a VendorGate.
     * @example
     * // Create one VendorGate
     * const VendorGate = await prisma.vendorGate.create({
     *   data: {
     *     // ... data to create a VendorGate
     *   }
     * })
     * 
     */
    create<T extends VendorGateCreateArgs>(args: SelectSubset<T, VendorGateCreateArgs<ExtArgs>>): Prisma__VendorGateClient<$Result.GetResult<Prisma.$VendorGatePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many VendorGates.
     * @param {VendorGateCreateManyArgs} args - Arguments to create many VendorGates.
     * @example
     * // Create many VendorGates
     * const vendorGate = await prisma.vendorGate.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VendorGateCreateManyArgs>(args?: SelectSubset<T, VendorGateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VendorGates and returns the data saved in the database.
     * @param {VendorGateCreateManyAndReturnArgs} args - Arguments to create many VendorGates.
     * @example
     * // Create many VendorGates
     * const vendorGate = await prisma.vendorGate.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VendorGates and only return the `id`
     * const vendorGateWithIdOnly = await prisma.vendorGate.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VendorGateCreateManyAndReturnArgs>(args?: SelectSubset<T, VendorGateCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VendorGatePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a VendorGate.
     * @param {VendorGateDeleteArgs} args - Arguments to delete one VendorGate.
     * @example
     * // Delete one VendorGate
     * const VendorGate = await prisma.vendorGate.delete({
     *   where: {
     *     // ... filter to delete one VendorGate
     *   }
     * })
     * 
     */
    delete<T extends VendorGateDeleteArgs>(args: SelectSubset<T, VendorGateDeleteArgs<ExtArgs>>): Prisma__VendorGateClient<$Result.GetResult<Prisma.$VendorGatePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one VendorGate.
     * @param {VendorGateUpdateArgs} args - Arguments to update one VendorGate.
     * @example
     * // Update one VendorGate
     * const vendorGate = await prisma.vendorGate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VendorGateUpdateArgs>(args: SelectSubset<T, VendorGateUpdateArgs<ExtArgs>>): Prisma__VendorGateClient<$Result.GetResult<Prisma.$VendorGatePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more VendorGates.
     * @param {VendorGateDeleteManyArgs} args - Arguments to filter VendorGates to delete.
     * @example
     * // Delete a few VendorGates
     * const { count } = await prisma.vendorGate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VendorGateDeleteManyArgs>(args?: SelectSubset<T, VendorGateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VendorGates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorGateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VendorGates
     * const vendorGate = await prisma.vendorGate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VendorGateUpdateManyArgs>(args: SelectSubset<T, VendorGateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VendorGates and returns the data updated in the database.
     * @param {VendorGateUpdateManyAndReturnArgs} args - Arguments to update many VendorGates.
     * @example
     * // Update many VendorGates
     * const vendorGate = await prisma.vendorGate.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more VendorGates and only return the `id`
     * const vendorGateWithIdOnly = await prisma.vendorGate.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VendorGateUpdateManyAndReturnArgs>(args: SelectSubset<T, VendorGateUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VendorGatePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one VendorGate.
     * @param {VendorGateUpsertArgs} args - Arguments to update or create a VendorGate.
     * @example
     * // Update or create a VendorGate
     * const vendorGate = await prisma.vendorGate.upsert({
     *   create: {
     *     // ... data to create a VendorGate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VendorGate we want to update
     *   }
     * })
     */
    upsert<T extends VendorGateUpsertArgs>(args: SelectSubset<T, VendorGateUpsertArgs<ExtArgs>>): Prisma__VendorGateClient<$Result.GetResult<Prisma.$VendorGatePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of VendorGates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorGateCountArgs} args - Arguments to filter VendorGates to count.
     * @example
     * // Count the number of VendorGates
     * const count = await prisma.vendorGate.count({
     *   where: {
     *     // ... the filter for the VendorGates we want to count
     *   }
     * })
    **/
    count<T extends VendorGateCountArgs>(
      args?: Subset<T, VendorGateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VendorGateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VendorGate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorGateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VendorGateAggregateArgs>(args: Subset<T, VendorGateAggregateArgs>): Prisma.PrismaPromise<GetVendorGateAggregateType<T>>

    /**
     * Group by VendorGate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorGateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VendorGateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VendorGateGroupByArgs['orderBy'] }
        : { orderBy?: VendorGateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VendorGateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVendorGateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VendorGate model
   */
  readonly fields: VendorGateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VendorGate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VendorGateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    vendor<T extends VendorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VendorDefaultArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    gate<T extends GateDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GateDefaultArgs<ExtArgs>>): Prisma__GateClient<$Result.GetResult<Prisma.$GatePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VendorGate model
   */
  interface VendorGateFieldRefs {
    readonly id: FieldRef<"VendorGate", 'String'>
    readonly vendorId: FieldRef<"VendorGate", 'String'>
    readonly gateId: FieldRef<"VendorGate", 'String'>
    readonly createdAt: FieldRef<"VendorGate", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * VendorGate findUnique
   */
  export type VendorGateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorGate
     */
    select?: VendorGateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorGate
     */
    omit?: VendorGateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorGateInclude<ExtArgs> | null
    /**
     * Filter, which VendorGate to fetch.
     */
    where: VendorGateWhereUniqueInput
  }

  /**
   * VendorGate findUniqueOrThrow
   */
  export type VendorGateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorGate
     */
    select?: VendorGateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorGate
     */
    omit?: VendorGateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorGateInclude<ExtArgs> | null
    /**
     * Filter, which VendorGate to fetch.
     */
    where: VendorGateWhereUniqueInput
  }

  /**
   * VendorGate findFirst
   */
  export type VendorGateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorGate
     */
    select?: VendorGateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorGate
     */
    omit?: VendorGateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorGateInclude<ExtArgs> | null
    /**
     * Filter, which VendorGate to fetch.
     */
    where?: VendorGateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VendorGates to fetch.
     */
    orderBy?: VendorGateOrderByWithRelationInput | VendorGateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VendorGates.
     */
    cursor?: VendorGateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VendorGates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VendorGates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VendorGates.
     */
    distinct?: VendorGateScalarFieldEnum | VendorGateScalarFieldEnum[]
  }

  /**
   * VendorGate findFirstOrThrow
   */
  export type VendorGateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorGate
     */
    select?: VendorGateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorGate
     */
    omit?: VendorGateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorGateInclude<ExtArgs> | null
    /**
     * Filter, which VendorGate to fetch.
     */
    where?: VendorGateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VendorGates to fetch.
     */
    orderBy?: VendorGateOrderByWithRelationInput | VendorGateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VendorGates.
     */
    cursor?: VendorGateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VendorGates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VendorGates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VendorGates.
     */
    distinct?: VendorGateScalarFieldEnum | VendorGateScalarFieldEnum[]
  }

  /**
   * VendorGate findMany
   */
  export type VendorGateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorGate
     */
    select?: VendorGateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorGate
     */
    omit?: VendorGateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorGateInclude<ExtArgs> | null
    /**
     * Filter, which VendorGates to fetch.
     */
    where?: VendorGateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VendorGates to fetch.
     */
    orderBy?: VendorGateOrderByWithRelationInput | VendorGateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VendorGates.
     */
    cursor?: VendorGateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VendorGates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VendorGates.
     */
    skip?: number
    distinct?: VendorGateScalarFieldEnum | VendorGateScalarFieldEnum[]
  }

  /**
   * VendorGate create
   */
  export type VendorGateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorGate
     */
    select?: VendorGateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorGate
     */
    omit?: VendorGateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorGateInclude<ExtArgs> | null
    /**
     * The data needed to create a VendorGate.
     */
    data: XOR<VendorGateCreateInput, VendorGateUncheckedCreateInput>
  }

  /**
   * VendorGate createMany
   */
  export type VendorGateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VendorGates.
     */
    data: VendorGateCreateManyInput | VendorGateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VendorGate createManyAndReturn
   */
  export type VendorGateCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorGate
     */
    select?: VendorGateSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VendorGate
     */
    omit?: VendorGateOmit<ExtArgs> | null
    /**
     * The data used to create many VendorGates.
     */
    data: VendorGateCreateManyInput | VendorGateCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorGateIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * VendorGate update
   */
  export type VendorGateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorGate
     */
    select?: VendorGateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorGate
     */
    omit?: VendorGateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorGateInclude<ExtArgs> | null
    /**
     * The data needed to update a VendorGate.
     */
    data: XOR<VendorGateUpdateInput, VendorGateUncheckedUpdateInput>
    /**
     * Choose, which VendorGate to update.
     */
    where: VendorGateWhereUniqueInput
  }

  /**
   * VendorGate updateMany
   */
  export type VendorGateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VendorGates.
     */
    data: XOR<VendorGateUpdateManyMutationInput, VendorGateUncheckedUpdateManyInput>
    /**
     * Filter which VendorGates to update
     */
    where?: VendorGateWhereInput
    /**
     * Limit how many VendorGates to update.
     */
    limit?: number
  }

  /**
   * VendorGate updateManyAndReturn
   */
  export type VendorGateUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorGate
     */
    select?: VendorGateSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VendorGate
     */
    omit?: VendorGateOmit<ExtArgs> | null
    /**
     * The data used to update VendorGates.
     */
    data: XOR<VendorGateUpdateManyMutationInput, VendorGateUncheckedUpdateManyInput>
    /**
     * Filter which VendorGates to update
     */
    where?: VendorGateWhereInput
    /**
     * Limit how many VendorGates to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorGateIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * VendorGate upsert
   */
  export type VendorGateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorGate
     */
    select?: VendorGateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorGate
     */
    omit?: VendorGateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorGateInclude<ExtArgs> | null
    /**
     * The filter to search for the VendorGate to update in case it exists.
     */
    where: VendorGateWhereUniqueInput
    /**
     * In case the VendorGate found by the `where` argument doesn't exist, create a new VendorGate with this data.
     */
    create: XOR<VendorGateCreateInput, VendorGateUncheckedCreateInput>
    /**
     * In case the VendorGate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VendorGateUpdateInput, VendorGateUncheckedUpdateInput>
  }

  /**
   * VendorGate delete
   */
  export type VendorGateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorGate
     */
    select?: VendorGateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorGate
     */
    omit?: VendorGateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorGateInclude<ExtArgs> | null
    /**
     * Filter which VendorGate to delete.
     */
    where: VendorGateWhereUniqueInput
  }

  /**
   * VendorGate deleteMany
   */
  export type VendorGateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VendorGates to delete
     */
    where?: VendorGateWhereInput
    /**
     * Limit how many VendorGates to delete.
     */
    limit?: number
  }

  /**
   * VendorGate without action
   */
  export type VendorGateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorGate
     */
    select?: VendorGateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorGate
     */
    omit?: VendorGateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorGateInclude<ExtArgs> | null
  }


  /**
   * Model VendorZone
   */

  export type AggregateVendorZone = {
    _count: VendorZoneCountAggregateOutputType | null
    _min: VendorZoneMinAggregateOutputType | null
    _max: VendorZoneMaxAggregateOutputType | null
  }

  export type VendorZoneMinAggregateOutputType = {
    id: string | null
    vendorId: string | null
    zoneId: string | null
    createdAt: Date | null
  }

  export type VendorZoneMaxAggregateOutputType = {
    id: string | null
    vendorId: string | null
    zoneId: string | null
    createdAt: Date | null
  }

  export type VendorZoneCountAggregateOutputType = {
    id: number
    vendorId: number
    zoneId: number
    createdAt: number
    _all: number
  }


  export type VendorZoneMinAggregateInputType = {
    id?: true
    vendorId?: true
    zoneId?: true
    createdAt?: true
  }

  export type VendorZoneMaxAggregateInputType = {
    id?: true
    vendorId?: true
    zoneId?: true
    createdAt?: true
  }

  export type VendorZoneCountAggregateInputType = {
    id?: true
    vendorId?: true
    zoneId?: true
    createdAt?: true
    _all?: true
  }

  export type VendorZoneAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VendorZone to aggregate.
     */
    where?: VendorZoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VendorZones to fetch.
     */
    orderBy?: VendorZoneOrderByWithRelationInput | VendorZoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VendorZoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VendorZones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VendorZones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VendorZones
    **/
    _count?: true | VendorZoneCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VendorZoneMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VendorZoneMaxAggregateInputType
  }

  export type GetVendorZoneAggregateType<T extends VendorZoneAggregateArgs> = {
        [P in keyof T & keyof AggregateVendorZone]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVendorZone[P]>
      : GetScalarType<T[P], AggregateVendorZone[P]>
  }




  export type VendorZoneGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VendorZoneWhereInput
    orderBy?: VendorZoneOrderByWithAggregationInput | VendorZoneOrderByWithAggregationInput[]
    by: VendorZoneScalarFieldEnum[] | VendorZoneScalarFieldEnum
    having?: VendorZoneScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VendorZoneCountAggregateInputType | true
    _min?: VendorZoneMinAggregateInputType
    _max?: VendorZoneMaxAggregateInputType
  }

  export type VendorZoneGroupByOutputType = {
    id: string
    vendorId: string
    zoneId: string
    createdAt: Date
    _count: VendorZoneCountAggregateOutputType | null
    _min: VendorZoneMinAggregateOutputType | null
    _max: VendorZoneMaxAggregateOutputType | null
  }

  type GetVendorZoneGroupByPayload<T extends VendorZoneGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VendorZoneGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VendorZoneGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VendorZoneGroupByOutputType[P]>
            : GetScalarType<T[P], VendorZoneGroupByOutputType[P]>
        }
      >
    >


  export type VendorZoneSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    vendorId?: boolean
    zoneId?: boolean
    createdAt?: boolean
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
    zone?: boolean | ZoneDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vendorZone"]>

  export type VendorZoneSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    vendorId?: boolean
    zoneId?: boolean
    createdAt?: boolean
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
    zone?: boolean | ZoneDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vendorZone"]>

  export type VendorZoneSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    vendorId?: boolean
    zoneId?: boolean
    createdAt?: boolean
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
    zone?: boolean | ZoneDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vendorZone"]>

  export type VendorZoneSelectScalar = {
    id?: boolean
    vendorId?: boolean
    zoneId?: boolean
    createdAt?: boolean
  }

  export type VendorZoneOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "vendorId" | "zoneId" | "createdAt", ExtArgs["result"]["vendorZone"]>
  export type VendorZoneInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
    zone?: boolean | ZoneDefaultArgs<ExtArgs>
  }
  export type VendorZoneIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
    zone?: boolean | ZoneDefaultArgs<ExtArgs>
  }
  export type VendorZoneIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
    zone?: boolean | ZoneDefaultArgs<ExtArgs>
  }

  export type $VendorZonePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VendorZone"
    objects: {
      vendor: Prisma.$VendorPayload<ExtArgs>
      zone: Prisma.$ZonePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      vendorId: string
      zoneId: string
      createdAt: Date
    }, ExtArgs["result"]["vendorZone"]>
    composites: {}
  }

  type VendorZoneGetPayload<S extends boolean | null | undefined | VendorZoneDefaultArgs> = $Result.GetResult<Prisma.$VendorZonePayload, S>

  type VendorZoneCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VendorZoneFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VendorZoneCountAggregateInputType | true
    }

  export interface VendorZoneDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VendorZone'], meta: { name: 'VendorZone' } }
    /**
     * Find zero or one VendorZone that matches the filter.
     * @param {VendorZoneFindUniqueArgs} args - Arguments to find a VendorZone
     * @example
     * // Get one VendorZone
     * const vendorZone = await prisma.vendorZone.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VendorZoneFindUniqueArgs>(args: SelectSubset<T, VendorZoneFindUniqueArgs<ExtArgs>>): Prisma__VendorZoneClient<$Result.GetResult<Prisma.$VendorZonePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one VendorZone that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VendorZoneFindUniqueOrThrowArgs} args - Arguments to find a VendorZone
     * @example
     * // Get one VendorZone
     * const vendorZone = await prisma.vendorZone.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VendorZoneFindUniqueOrThrowArgs>(args: SelectSubset<T, VendorZoneFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VendorZoneClient<$Result.GetResult<Prisma.$VendorZonePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VendorZone that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorZoneFindFirstArgs} args - Arguments to find a VendorZone
     * @example
     * // Get one VendorZone
     * const vendorZone = await prisma.vendorZone.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VendorZoneFindFirstArgs>(args?: SelectSubset<T, VendorZoneFindFirstArgs<ExtArgs>>): Prisma__VendorZoneClient<$Result.GetResult<Prisma.$VendorZonePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VendorZone that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorZoneFindFirstOrThrowArgs} args - Arguments to find a VendorZone
     * @example
     * // Get one VendorZone
     * const vendorZone = await prisma.vendorZone.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VendorZoneFindFirstOrThrowArgs>(args?: SelectSubset<T, VendorZoneFindFirstOrThrowArgs<ExtArgs>>): Prisma__VendorZoneClient<$Result.GetResult<Prisma.$VendorZonePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more VendorZones that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorZoneFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VendorZones
     * const vendorZones = await prisma.vendorZone.findMany()
     * 
     * // Get first 10 VendorZones
     * const vendorZones = await prisma.vendorZone.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const vendorZoneWithIdOnly = await prisma.vendorZone.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VendorZoneFindManyArgs>(args?: SelectSubset<T, VendorZoneFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VendorZonePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a VendorZone.
     * @param {VendorZoneCreateArgs} args - Arguments to create a VendorZone.
     * @example
     * // Create one VendorZone
     * const VendorZone = await prisma.vendorZone.create({
     *   data: {
     *     // ... data to create a VendorZone
     *   }
     * })
     * 
     */
    create<T extends VendorZoneCreateArgs>(args: SelectSubset<T, VendorZoneCreateArgs<ExtArgs>>): Prisma__VendorZoneClient<$Result.GetResult<Prisma.$VendorZonePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many VendorZones.
     * @param {VendorZoneCreateManyArgs} args - Arguments to create many VendorZones.
     * @example
     * // Create many VendorZones
     * const vendorZone = await prisma.vendorZone.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VendorZoneCreateManyArgs>(args?: SelectSubset<T, VendorZoneCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VendorZones and returns the data saved in the database.
     * @param {VendorZoneCreateManyAndReturnArgs} args - Arguments to create many VendorZones.
     * @example
     * // Create many VendorZones
     * const vendorZone = await prisma.vendorZone.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VendorZones and only return the `id`
     * const vendorZoneWithIdOnly = await prisma.vendorZone.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VendorZoneCreateManyAndReturnArgs>(args?: SelectSubset<T, VendorZoneCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VendorZonePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a VendorZone.
     * @param {VendorZoneDeleteArgs} args - Arguments to delete one VendorZone.
     * @example
     * // Delete one VendorZone
     * const VendorZone = await prisma.vendorZone.delete({
     *   where: {
     *     // ... filter to delete one VendorZone
     *   }
     * })
     * 
     */
    delete<T extends VendorZoneDeleteArgs>(args: SelectSubset<T, VendorZoneDeleteArgs<ExtArgs>>): Prisma__VendorZoneClient<$Result.GetResult<Prisma.$VendorZonePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one VendorZone.
     * @param {VendorZoneUpdateArgs} args - Arguments to update one VendorZone.
     * @example
     * // Update one VendorZone
     * const vendorZone = await prisma.vendorZone.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VendorZoneUpdateArgs>(args: SelectSubset<T, VendorZoneUpdateArgs<ExtArgs>>): Prisma__VendorZoneClient<$Result.GetResult<Prisma.$VendorZonePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more VendorZones.
     * @param {VendorZoneDeleteManyArgs} args - Arguments to filter VendorZones to delete.
     * @example
     * // Delete a few VendorZones
     * const { count } = await prisma.vendorZone.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VendorZoneDeleteManyArgs>(args?: SelectSubset<T, VendorZoneDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VendorZones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorZoneUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VendorZones
     * const vendorZone = await prisma.vendorZone.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VendorZoneUpdateManyArgs>(args: SelectSubset<T, VendorZoneUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VendorZones and returns the data updated in the database.
     * @param {VendorZoneUpdateManyAndReturnArgs} args - Arguments to update many VendorZones.
     * @example
     * // Update many VendorZones
     * const vendorZone = await prisma.vendorZone.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more VendorZones and only return the `id`
     * const vendorZoneWithIdOnly = await prisma.vendorZone.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VendorZoneUpdateManyAndReturnArgs>(args: SelectSubset<T, VendorZoneUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VendorZonePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one VendorZone.
     * @param {VendorZoneUpsertArgs} args - Arguments to update or create a VendorZone.
     * @example
     * // Update or create a VendorZone
     * const vendorZone = await prisma.vendorZone.upsert({
     *   create: {
     *     // ... data to create a VendorZone
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VendorZone we want to update
     *   }
     * })
     */
    upsert<T extends VendorZoneUpsertArgs>(args: SelectSubset<T, VendorZoneUpsertArgs<ExtArgs>>): Prisma__VendorZoneClient<$Result.GetResult<Prisma.$VendorZonePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of VendorZones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorZoneCountArgs} args - Arguments to filter VendorZones to count.
     * @example
     * // Count the number of VendorZones
     * const count = await prisma.vendorZone.count({
     *   where: {
     *     // ... the filter for the VendorZones we want to count
     *   }
     * })
    **/
    count<T extends VendorZoneCountArgs>(
      args?: Subset<T, VendorZoneCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VendorZoneCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VendorZone.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorZoneAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VendorZoneAggregateArgs>(args: Subset<T, VendorZoneAggregateArgs>): Prisma.PrismaPromise<GetVendorZoneAggregateType<T>>

    /**
     * Group by VendorZone.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorZoneGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VendorZoneGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VendorZoneGroupByArgs['orderBy'] }
        : { orderBy?: VendorZoneGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VendorZoneGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVendorZoneGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VendorZone model
   */
  readonly fields: VendorZoneFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VendorZone.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VendorZoneClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    vendor<T extends VendorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VendorDefaultArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    zone<T extends ZoneDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ZoneDefaultArgs<ExtArgs>>): Prisma__ZoneClient<$Result.GetResult<Prisma.$ZonePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VendorZone model
   */
  interface VendorZoneFieldRefs {
    readonly id: FieldRef<"VendorZone", 'String'>
    readonly vendorId: FieldRef<"VendorZone", 'String'>
    readonly zoneId: FieldRef<"VendorZone", 'String'>
    readonly createdAt: FieldRef<"VendorZone", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * VendorZone findUnique
   */
  export type VendorZoneFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorZone
     */
    select?: VendorZoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorZone
     */
    omit?: VendorZoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorZoneInclude<ExtArgs> | null
    /**
     * Filter, which VendorZone to fetch.
     */
    where: VendorZoneWhereUniqueInput
  }

  /**
   * VendorZone findUniqueOrThrow
   */
  export type VendorZoneFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorZone
     */
    select?: VendorZoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorZone
     */
    omit?: VendorZoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorZoneInclude<ExtArgs> | null
    /**
     * Filter, which VendorZone to fetch.
     */
    where: VendorZoneWhereUniqueInput
  }

  /**
   * VendorZone findFirst
   */
  export type VendorZoneFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorZone
     */
    select?: VendorZoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorZone
     */
    omit?: VendorZoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorZoneInclude<ExtArgs> | null
    /**
     * Filter, which VendorZone to fetch.
     */
    where?: VendorZoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VendorZones to fetch.
     */
    orderBy?: VendorZoneOrderByWithRelationInput | VendorZoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VendorZones.
     */
    cursor?: VendorZoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VendorZones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VendorZones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VendorZones.
     */
    distinct?: VendorZoneScalarFieldEnum | VendorZoneScalarFieldEnum[]
  }

  /**
   * VendorZone findFirstOrThrow
   */
  export type VendorZoneFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorZone
     */
    select?: VendorZoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorZone
     */
    omit?: VendorZoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorZoneInclude<ExtArgs> | null
    /**
     * Filter, which VendorZone to fetch.
     */
    where?: VendorZoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VendorZones to fetch.
     */
    orderBy?: VendorZoneOrderByWithRelationInput | VendorZoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VendorZones.
     */
    cursor?: VendorZoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VendorZones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VendorZones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VendorZones.
     */
    distinct?: VendorZoneScalarFieldEnum | VendorZoneScalarFieldEnum[]
  }

  /**
   * VendorZone findMany
   */
  export type VendorZoneFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorZone
     */
    select?: VendorZoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorZone
     */
    omit?: VendorZoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorZoneInclude<ExtArgs> | null
    /**
     * Filter, which VendorZones to fetch.
     */
    where?: VendorZoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VendorZones to fetch.
     */
    orderBy?: VendorZoneOrderByWithRelationInput | VendorZoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VendorZones.
     */
    cursor?: VendorZoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VendorZones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VendorZones.
     */
    skip?: number
    distinct?: VendorZoneScalarFieldEnum | VendorZoneScalarFieldEnum[]
  }

  /**
   * VendorZone create
   */
  export type VendorZoneCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorZone
     */
    select?: VendorZoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorZone
     */
    omit?: VendorZoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorZoneInclude<ExtArgs> | null
    /**
     * The data needed to create a VendorZone.
     */
    data: XOR<VendorZoneCreateInput, VendorZoneUncheckedCreateInput>
  }

  /**
   * VendorZone createMany
   */
  export type VendorZoneCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VendorZones.
     */
    data: VendorZoneCreateManyInput | VendorZoneCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VendorZone createManyAndReturn
   */
  export type VendorZoneCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorZone
     */
    select?: VendorZoneSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VendorZone
     */
    omit?: VendorZoneOmit<ExtArgs> | null
    /**
     * The data used to create many VendorZones.
     */
    data: VendorZoneCreateManyInput | VendorZoneCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorZoneIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * VendorZone update
   */
  export type VendorZoneUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorZone
     */
    select?: VendorZoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorZone
     */
    omit?: VendorZoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorZoneInclude<ExtArgs> | null
    /**
     * The data needed to update a VendorZone.
     */
    data: XOR<VendorZoneUpdateInput, VendorZoneUncheckedUpdateInput>
    /**
     * Choose, which VendorZone to update.
     */
    where: VendorZoneWhereUniqueInput
  }

  /**
   * VendorZone updateMany
   */
  export type VendorZoneUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VendorZones.
     */
    data: XOR<VendorZoneUpdateManyMutationInput, VendorZoneUncheckedUpdateManyInput>
    /**
     * Filter which VendorZones to update
     */
    where?: VendorZoneWhereInput
    /**
     * Limit how many VendorZones to update.
     */
    limit?: number
  }

  /**
   * VendorZone updateManyAndReturn
   */
  export type VendorZoneUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorZone
     */
    select?: VendorZoneSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VendorZone
     */
    omit?: VendorZoneOmit<ExtArgs> | null
    /**
     * The data used to update VendorZones.
     */
    data: XOR<VendorZoneUpdateManyMutationInput, VendorZoneUncheckedUpdateManyInput>
    /**
     * Filter which VendorZones to update
     */
    where?: VendorZoneWhereInput
    /**
     * Limit how many VendorZones to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorZoneIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * VendorZone upsert
   */
  export type VendorZoneUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorZone
     */
    select?: VendorZoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorZone
     */
    omit?: VendorZoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorZoneInclude<ExtArgs> | null
    /**
     * The filter to search for the VendorZone to update in case it exists.
     */
    where: VendorZoneWhereUniqueInput
    /**
     * In case the VendorZone found by the `where` argument doesn't exist, create a new VendorZone with this data.
     */
    create: XOR<VendorZoneCreateInput, VendorZoneUncheckedCreateInput>
    /**
     * In case the VendorZone was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VendorZoneUpdateInput, VendorZoneUncheckedUpdateInput>
  }

  /**
   * VendorZone delete
   */
  export type VendorZoneDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorZone
     */
    select?: VendorZoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorZone
     */
    omit?: VendorZoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorZoneInclude<ExtArgs> | null
    /**
     * Filter which VendorZone to delete.
     */
    where: VendorZoneWhereUniqueInput
  }

  /**
   * VendorZone deleteMany
   */
  export type VendorZoneDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VendorZones to delete
     */
    where?: VendorZoneWhereInput
    /**
     * Limit how many VendorZones to delete.
     */
    limit?: number
  }

  /**
   * VendorZone without action
   */
  export type VendorZoneDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorZone
     */
    select?: VendorZoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorZone
     */
    omit?: VendorZoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorZoneInclude<ExtArgs> | null
  }


  /**
   * Model EmployeeGate
   */

  export type AggregateEmployeeGate = {
    _count: EmployeeGateCountAggregateOutputType | null
    _min: EmployeeGateMinAggregateOutputType | null
    _max: EmployeeGateMaxAggregateOutputType | null
  }

  export type EmployeeGateMinAggregateOutputType = {
    id: string | null
    employeeId: string | null
    gateId: string | null
    createdAt: Date | null
  }

  export type EmployeeGateMaxAggregateOutputType = {
    id: string | null
    employeeId: string | null
    gateId: string | null
    createdAt: Date | null
  }

  export type EmployeeGateCountAggregateOutputType = {
    id: number
    employeeId: number
    gateId: number
    createdAt: number
    _all: number
  }


  export type EmployeeGateMinAggregateInputType = {
    id?: true
    employeeId?: true
    gateId?: true
    createdAt?: true
  }

  export type EmployeeGateMaxAggregateInputType = {
    id?: true
    employeeId?: true
    gateId?: true
    createdAt?: true
  }

  export type EmployeeGateCountAggregateInputType = {
    id?: true
    employeeId?: true
    gateId?: true
    createdAt?: true
    _all?: true
  }

  export type EmployeeGateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmployeeGate to aggregate.
     */
    where?: EmployeeGateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeeGates to fetch.
     */
    orderBy?: EmployeeGateOrderByWithRelationInput | EmployeeGateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmployeeGateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeeGates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeeGates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EmployeeGates
    **/
    _count?: true | EmployeeGateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmployeeGateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmployeeGateMaxAggregateInputType
  }

  export type GetEmployeeGateAggregateType<T extends EmployeeGateAggregateArgs> = {
        [P in keyof T & keyof AggregateEmployeeGate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmployeeGate[P]>
      : GetScalarType<T[P], AggregateEmployeeGate[P]>
  }




  export type EmployeeGateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeGateWhereInput
    orderBy?: EmployeeGateOrderByWithAggregationInput | EmployeeGateOrderByWithAggregationInput[]
    by: EmployeeGateScalarFieldEnum[] | EmployeeGateScalarFieldEnum
    having?: EmployeeGateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmployeeGateCountAggregateInputType | true
    _min?: EmployeeGateMinAggregateInputType
    _max?: EmployeeGateMaxAggregateInputType
  }

  export type EmployeeGateGroupByOutputType = {
    id: string
    employeeId: string
    gateId: string
    createdAt: Date
    _count: EmployeeGateCountAggregateOutputType | null
    _min: EmployeeGateMinAggregateOutputType | null
    _max: EmployeeGateMaxAggregateOutputType | null
  }

  type GetEmployeeGateGroupByPayload<T extends EmployeeGateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmployeeGateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmployeeGateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmployeeGateGroupByOutputType[P]>
            : GetScalarType<T[P], EmployeeGateGroupByOutputType[P]>
        }
      >
    >


  export type EmployeeGateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    gateId?: boolean
    createdAt?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    gate?: boolean | GateDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employeeGate"]>

  export type EmployeeGateSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    gateId?: boolean
    createdAt?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    gate?: boolean | GateDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employeeGate"]>

  export type EmployeeGateSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    gateId?: boolean
    createdAt?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    gate?: boolean | GateDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employeeGate"]>

  export type EmployeeGateSelectScalar = {
    id?: boolean
    employeeId?: boolean
    gateId?: boolean
    createdAt?: boolean
  }

  export type EmployeeGateOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "employeeId" | "gateId" | "createdAt", ExtArgs["result"]["employeeGate"]>
  export type EmployeeGateInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    gate?: boolean | GateDefaultArgs<ExtArgs>
  }
  export type EmployeeGateIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    gate?: boolean | GateDefaultArgs<ExtArgs>
  }
  export type EmployeeGateIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    gate?: boolean | GateDefaultArgs<ExtArgs>
  }

  export type $EmployeeGatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EmployeeGate"
    objects: {
      employee: Prisma.$EmployeePayload<ExtArgs>
      gate: Prisma.$GatePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      employeeId: string
      gateId: string
      createdAt: Date
    }, ExtArgs["result"]["employeeGate"]>
    composites: {}
  }

  type EmployeeGateGetPayload<S extends boolean | null | undefined | EmployeeGateDefaultArgs> = $Result.GetResult<Prisma.$EmployeeGatePayload, S>

  type EmployeeGateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EmployeeGateFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EmployeeGateCountAggregateInputType | true
    }

  export interface EmployeeGateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EmployeeGate'], meta: { name: 'EmployeeGate' } }
    /**
     * Find zero or one EmployeeGate that matches the filter.
     * @param {EmployeeGateFindUniqueArgs} args - Arguments to find a EmployeeGate
     * @example
     * // Get one EmployeeGate
     * const employeeGate = await prisma.employeeGate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmployeeGateFindUniqueArgs>(args: SelectSubset<T, EmployeeGateFindUniqueArgs<ExtArgs>>): Prisma__EmployeeGateClient<$Result.GetResult<Prisma.$EmployeeGatePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EmployeeGate that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EmployeeGateFindUniqueOrThrowArgs} args - Arguments to find a EmployeeGate
     * @example
     * // Get one EmployeeGate
     * const employeeGate = await prisma.employeeGate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmployeeGateFindUniqueOrThrowArgs>(args: SelectSubset<T, EmployeeGateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmployeeGateClient<$Result.GetResult<Prisma.$EmployeeGatePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmployeeGate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeGateFindFirstArgs} args - Arguments to find a EmployeeGate
     * @example
     * // Get one EmployeeGate
     * const employeeGate = await prisma.employeeGate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmployeeGateFindFirstArgs>(args?: SelectSubset<T, EmployeeGateFindFirstArgs<ExtArgs>>): Prisma__EmployeeGateClient<$Result.GetResult<Prisma.$EmployeeGatePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmployeeGate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeGateFindFirstOrThrowArgs} args - Arguments to find a EmployeeGate
     * @example
     * // Get one EmployeeGate
     * const employeeGate = await prisma.employeeGate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmployeeGateFindFirstOrThrowArgs>(args?: SelectSubset<T, EmployeeGateFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmployeeGateClient<$Result.GetResult<Prisma.$EmployeeGatePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EmployeeGates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeGateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EmployeeGates
     * const employeeGates = await prisma.employeeGate.findMany()
     * 
     * // Get first 10 EmployeeGates
     * const employeeGates = await prisma.employeeGate.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const employeeGateWithIdOnly = await prisma.employeeGate.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EmployeeGateFindManyArgs>(args?: SelectSubset<T, EmployeeGateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeeGatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EmployeeGate.
     * @param {EmployeeGateCreateArgs} args - Arguments to create a EmployeeGate.
     * @example
     * // Create one EmployeeGate
     * const EmployeeGate = await prisma.employeeGate.create({
     *   data: {
     *     // ... data to create a EmployeeGate
     *   }
     * })
     * 
     */
    create<T extends EmployeeGateCreateArgs>(args: SelectSubset<T, EmployeeGateCreateArgs<ExtArgs>>): Prisma__EmployeeGateClient<$Result.GetResult<Prisma.$EmployeeGatePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EmployeeGates.
     * @param {EmployeeGateCreateManyArgs} args - Arguments to create many EmployeeGates.
     * @example
     * // Create many EmployeeGates
     * const employeeGate = await prisma.employeeGate.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmployeeGateCreateManyArgs>(args?: SelectSubset<T, EmployeeGateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EmployeeGates and returns the data saved in the database.
     * @param {EmployeeGateCreateManyAndReturnArgs} args - Arguments to create many EmployeeGates.
     * @example
     * // Create many EmployeeGates
     * const employeeGate = await prisma.employeeGate.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EmployeeGates and only return the `id`
     * const employeeGateWithIdOnly = await prisma.employeeGate.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EmployeeGateCreateManyAndReturnArgs>(args?: SelectSubset<T, EmployeeGateCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeeGatePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a EmployeeGate.
     * @param {EmployeeGateDeleteArgs} args - Arguments to delete one EmployeeGate.
     * @example
     * // Delete one EmployeeGate
     * const EmployeeGate = await prisma.employeeGate.delete({
     *   where: {
     *     // ... filter to delete one EmployeeGate
     *   }
     * })
     * 
     */
    delete<T extends EmployeeGateDeleteArgs>(args: SelectSubset<T, EmployeeGateDeleteArgs<ExtArgs>>): Prisma__EmployeeGateClient<$Result.GetResult<Prisma.$EmployeeGatePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EmployeeGate.
     * @param {EmployeeGateUpdateArgs} args - Arguments to update one EmployeeGate.
     * @example
     * // Update one EmployeeGate
     * const employeeGate = await prisma.employeeGate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmployeeGateUpdateArgs>(args: SelectSubset<T, EmployeeGateUpdateArgs<ExtArgs>>): Prisma__EmployeeGateClient<$Result.GetResult<Prisma.$EmployeeGatePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EmployeeGates.
     * @param {EmployeeGateDeleteManyArgs} args - Arguments to filter EmployeeGates to delete.
     * @example
     * // Delete a few EmployeeGates
     * const { count } = await prisma.employeeGate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmployeeGateDeleteManyArgs>(args?: SelectSubset<T, EmployeeGateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmployeeGates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeGateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EmployeeGates
     * const employeeGate = await prisma.employeeGate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmployeeGateUpdateManyArgs>(args: SelectSubset<T, EmployeeGateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmployeeGates and returns the data updated in the database.
     * @param {EmployeeGateUpdateManyAndReturnArgs} args - Arguments to update many EmployeeGates.
     * @example
     * // Update many EmployeeGates
     * const employeeGate = await prisma.employeeGate.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more EmployeeGates and only return the `id`
     * const employeeGateWithIdOnly = await prisma.employeeGate.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EmployeeGateUpdateManyAndReturnArgs>(args: SelectSubset<T, EmployeeGateUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeeGatePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one EmployeeGate.
     * @param {EmployeeGateUpsertArgs} args - Arguments to update or create a EmployeeGate.
     * @example
     * // Update or create a EmployeeGate
     * const employeeGate = await prisma.employeeGate.upsert({
     *   create: {
     *     // ... data to create a EmployeeGate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EmployeeGate we want to update
     *   }
     * })
     */
    upsert<T extends EmployeeGateUpsertArgs>(args: SelectSubset<T, EmployeeGateUpsertArgs<ExtArgs>>): Prisma__EmployeeGateClient<$Result.GetResult<Prisma.$EmployeeGatePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EmployeeGates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeGateCountArgs} args - Arguments to filter EmployeeGates to count.
     * @example
     * // Count the number of EmployeeGates
     * const count = await prisma.employeeGate.count({
     *   where: {
     *     // ... the filter for the EmployeeGates we want to count
     *   }
     * })
    **/
    count<T extends EmployeeGateCountArgs>(
      args?: Subset<T, EmployeeGateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmployeeGateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EmployeeGate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeGateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmployeeGateAggregateArgs>(args: Subset<T, EmployeeGateAggregateArgs>): Prisma.PrismaPromise<GetEmployeeGateAggregateType<T>>

    /**
     * Group by EmployeeGate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeGateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmployeeGateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmployeeGateGroupByArgs['orderBy'] }
        : { orderBy?: EmployeeGateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmployeeGateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmployeeGateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EmployeeGate model
   */
  readonly fields: EmployeeGateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EmployeeGate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmployeeGateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    employee<T extends EmployeeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmployeeDefaultArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    gate<T extends GateDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GateDefaultArgs<ExtArgs>>): Prisma__GateClient<$Result.GetResult<Prisma.$GatePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EmployeeGate model
   */
  interface EmployeeGateFieldRefs {
    readonly id: FieldRef<"EmployeeGate", 'String'>
    readonly employeeId: FieldRef<"EmployeeGate", 'String'>
    readonly gateId: FieldRef<"EmployeeGate", 'String'>
    readonly createdAt: FieldRef<"EmployeeGate", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EmployeeGate findUnique
   */
  export type EmployeeGateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeGate
     */
    select?: EmployeeGateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeGate
     */
    omit?: EmployeeGateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeGateInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeGate to fetch.
     */
    where: EmployeeGateWhereUniqueInput
  }

  /**
   * EmployeeGate findUniqueOrThrow
   */
  export type EmployeeGateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeGate
     */
    select?: EmployeeGateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeGate
     */
    omit?: EmployeeGateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeGateInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeGate to fetch.
     */
    where: EmployeeGateWhereUniqueInput
  }

  /**
   * EmployeeGate findFirst
   */
  export type EmployeeGateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeGate
     */
    select?: EmployeeGateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeGate
     */
    omit?: EmployeeGateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeGateInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeGate to fetch.
     */
    where?: EmployeeGateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeeGates to fetch.
     */
    orderBy?: EmployeeGateOrderByWithRelationInput | EmployeeGateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmployeeGates.
     */
    cursor?: EmployeeGateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeeGates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeeGates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmployeeGates.
     */
    distinct?: EmployeeGateScalarFieldEnum | EmployeeGateScalarFieldEnum[]
  }

  /**
   * EmployeeGate findFirstOrThrow
   */
  export type EmployeeGateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeGate
     */
    select?: EmployeeGateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeGate
     */
    omit?: EmployeeGateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeGateInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeGate to fetch.
     */
    where?: EmployeeGateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeeGates to fetch.
     */
    orderBy?: EmployeeGateOrderByWithRelationInput | EmployeeGateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmployeeGates.
     */
    cursor?: EmployeeGateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeeGates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeeGates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmployeeGates.
     */
    distinct?: EmployeeGateScalarFieldEnum | EmployeeGateScalarFieldEnum[]
  }

  /**
   * EmployeeGate findMany
   */
  export type EmployeeGateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeGate
     */
    select?: EmployeeGateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeGate
     */
    omit?: EmployeeGateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeGateInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeGates to fetch.
     */
    where?: EmployeeGateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeeGates to fetch.
     */
    orderBy?: EmployeeGateOrderByWithRelationInput | EmployeeGateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EmployeeGates.
     */
    cursor?: EmployeeGateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeeGates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeeGates.
     */
    skip?: number
    distinct?: EmployeeGateScalarFieldEnum | EmployeeGateScalarFieldEnum[]
  }

  /**
   * EmployeeGate create
   */
  export type EmployeeGateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeGate
     */
    select?: EmployeeGateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeGate
     */
    omit?: EmployeeGateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeGateInclude<ExtArgs> | null
    /**
     * The data needed to create a EmployeeGate.
     */
    data: XOR<EmployeeGateCreateInput, EmployeeGateUncheckedCreateInput>
  }

  /**
   * EmployeeGate createMany
   */
  export type EmployeeGateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EmployeeGates.
     */
    data: EmployeeGateCreateManyInput | EmployeeGateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EmployeeGate createManyAndReturn
   */
  export type EmployeeGateCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeGate
     */
    select?: EmployeeGateSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeGate
     */
    omit?: EmployeeGateOmit<ExtArgs> | null
    /**
     * The data used to create many EmployeeGates.
     */
    data: EmployeeGateCreateManyInput | EmployeeGateCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeGateIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EmployeeGate update
   */
  export type EmployeeGateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeGate
     */
    select?: EmployeeGateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeGate
     */
    omit?: EmployeeGateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeGateInclude<ExtArgs> | null
    /**
     * The data needed to update a EmployeeGate.
     */
    data: XOR<EmployeeGateUpdateInput, EmployeeGateUncheckedUpdateInput>
    /**
     * Choose, which EmployeeGate to update.
     */
    where: EmployeeGateWhereUniqueInput
  }

  /**
   * EmployeeGate updateMany
   */
  export type EmployeeGateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EmployeeGates.
     */
    data: XOR<EmployeeGateUpdateManyMutationInput, EmployeeGateUncheckedUpdateManyInput>
    /**
     * Filter which EmployeeGates to update
     */
    where?: EmployeeGateWhereInput
    /**
     * Limit how many EmployeeGates to update.
     */
    limit?: number
  }

  /**
   * EmployeeGate updateManyAndReturn
   */
  export type EmployeeGateUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeGate
     */
    select?: EmployeeGateSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeGate
     */
    omit?: EmployeeGateOmit<ExtArgs> | null
    /**
     * The data used to update EmployeeGates.
     */
    data: XOR<EmployeeGateUpdateManyMutationInput, EmployeeGateUncheckedUpdateManyInput>
    /**
     * Filter which EmployeeGates to update
     */
    where?: EmployeeGateWhereInput
    /**
     * Limit how many EmployeeGates to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeGateIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * EmployeeGate upsert
   */
  export type EmployeeGateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeGate
     */
    select?: EmployeeGateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeGate
     */
    omit?: EmployeeGateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeGateInclude<ExtArgs> | null
    /**
     * The filter to search for the EmployeeGate to update in case it exists.
     */
    where: EmployeeGateWhereUniqueInput
    /**
     * In case the EmployeeGate found by the `where` argument doesn't exist, create a new EmployeeGate with this data.
     */
    create: XOR<EmployeeGateCreateInput, EmployeeGateUncheckedCreateInput>
    /**
     * In case the EmployeeGate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmployeeGateUpdateInput, EmployeeGateUncheckedUpdateInput>
  }

  /**
   * EmployeeGate delete
   */
  export type EmployeeGateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeGate
     */
    select?: EmployeeGateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeGate
     */
    omit?: EmployeeGateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeGateInclude<ExtArgs> | null
    /**
     * Filter which EmployeeGate to delete.
     */
    where: EmployeeGateWhereUniqueInput
  }

  /**
   * EmployeeGate deleteMany
   */
  export type EmployeeGateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmployeeGates to delete
     */
    where?: EmployeeGateWhereInput
    /**
     * Limit how many EmployeeGates to delete.
     */
    limit?: number
  }

  /**
   * EmployeeGate without action
   */
  export type EmployeeGateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeGate
     */
    select?: EmployeeGateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeGate
     */
    omit?: EmployeeGateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeGateInclude<ExtArgs> | null
  }


  /**
   * Model EmployeeZone
   */

  export type AggregateEmployeeZone = {
    _count: EmployeeZoneCountAggregateOutputType | null
    _min: EmployeeZoneMinAggregateOutputType | null
    _max: EmployeeZoneMaxAggregateOutputType | null
  }

  export type EmployeeZoneMinAggregateOutputType = {
    id: string | null
    employeeId: string | null
    zoneId: string | null
    createdAt: Date | null
  }

  export type EmployeeZoneMaxAggregateOutputType = {
    id: string | null
    employeeId: string | null
    zoneId: string | null
    createdAt: Date | null
  }

  export type EmployeeZoneCountAggregateOutputType = {
    id: number
    employeeId: number
    zoneId: number
    createdAt: number
    _all: number
  }


  export type EmployeeZoneMinAggregateInputType = {
    id?: true
    employeeId?: true
    zoneId?: true
    createdAt?: true
  }

  export type EmployeeZoneMaxAggregateInputType = {
    id?: true
    employeeId?: true
    zoneId?: true
    createdAt?: true
  }

  export type EmployeeZoneCountAggregateInputType = {
    id?: true
    employeeId?: true
    zoneId?: true
    createdAt?: true
    _all?: true
  }

  export type EmployeeZoneAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmployeeZone to aggregate.
     */
    where?: EmployeeZoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeeZones to fetch.
     */
    orderBy?: EmployeeZoneOrderByWithRelationInput | EmployeeZoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmployeeZoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeeZones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeeZones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EmployeeZones
    **/
    _count?: true | EmployeeZoneCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmployeeZoneMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmployeeZoneMaxAggregateInputType
  }

  export type GetEmployeeZoneAggregateType<T extends EmployeeZoneAggregateArgs> = {
        [P in keyof T & keyof AggregateEmployeeZone]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmployeeZone[P]>
      : GetScalarType<T[P], AggregateEmployeeZone[P]>
  }




  export type EmployeeZoneGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeZoneWhereInput
    orderBy?: EmployeeZoneOrderByWithAggregationInput | EmployeeZoneOrderByWithAggregationInput[]
    by: EmployeeZoneScalarFieldEnum[] | EmployeeZoneScalarFieldEnum
    having?: EmployeeZoneScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmployeeZoneCountAggregateInputType | true
    _min?: EmployeeZoneMinAggregateInputType
    _max?: EmployeeZoneMaxAggregateInputType
  }

  export type EmployeeZoneGroupByOutputType = {
    id: string
    employeeId: string
    zoneId: string
    createdAt: Date
    _count: EmployeeZoneCountAggregateOutputType | null
    _min: EmployeeZoneMinAggregateOutputType | null
    _max: EmployeeZoneMaxAggregateOutputType | null
  }

  type GetEmployeeZoneGroupByPayload<T extends EmployeeZoneGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmployeeZoneGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmployeeZoneGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmployeeZoneGroupByOutputType[P]>
            : GetScalarType<T[P], EmployeeZoneGroupByOutputType[P]>
        }
      >
    >


  export type EmployeeZoneSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    zoneId?: boolean
    createdAt?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    zone?: boolean | ZoneDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employeeZone"]>

  export type EmployeeZoneSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    zoneId?: boolean
    createdAt?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    zone?: boolean | ZoneDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employeeZone"]>

  export type EmployeeZoneSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    zoneId?: boolean
    createdAt?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    zone?: boolean | ZoneDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employeeZone"]>

  export type EmployeeZoneSelectScalar = {
    id?: boolean
    employeeId?: boolean
    zoneId?: boolean
    createdAt?: boolean
  }

  export type EmployeeZoneOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "employeeId" | "zoneId" | "createdAt", ExtArgs["result"]["employeeZone"]>
  export type EmployeeZoneInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    zone?: boolean | ZoneDefaultArgs<ExtArgs>
  }
  export type EmployeeZoneIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    zone?: boolean | ZoneDefaultArgs<ExtArgs>
  }
  export type EmployeeZoneIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    zone?: boolean | ZoneDefaultArgs<ExtArgs>
  }

  export type $EmployeeZonePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EmployeeZone"
    objects: {
      employee: Prisma.$EmployeePayload<ExtArgs>
      zone: Prisma.$ZonePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      employeeId: string
      zoneId: string
      createdAt: Date
    }, ExtArgs["result"]["employeeZone"]>
    composites: {}
  }

  type EmployeeZoneGetPayload<S extends boolean | null | undefined | EmployeeZoneDefaultArgs> = $Result.GetResult<Prisma.$EmployeeZonePayload, S>

  type EmployeeZoneCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EmployeeZoneFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EmployeeZoneCountAggregateInputType | true
    }

  export interface EmployeeZoneDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EmployeeZone'], meta: { name: 'EmployeeZone' } }
    /**
     * Find zero or one EmployeeZone that matches the filter.
     * @param {EmployeeZoneFindUniqueArgs} args - Arguments to find a EmployeeZone
     * @example
     * // Get one EmployeeZone
     * const employeeZone = await prisma.employeeZone.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmployeeZoneFindUniqueArgs>(args: SelectSubset<T, EmployeeZoneFindUniqueArgs<ExtArgs>>): Prisma__EmployeeZoneClient<$Result.GetResult<Prisma.$EmployeeZonePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EmployeeZone that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EmployeeZoneFindUniqueOrThrowArgs} args - Arguments to find a EmployeeZone
     * @example
     * // Get one EmployeeZone
     * const employeeZone = await prisma.employeeZone.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmployeeZoneFindUniqueOrThrowArgs>(args: SelectSubset<T, EmployeeZoneFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmployeeZoneClient<$Result.GetResult<Prisma.$EmployeeZonePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmployeeZone that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeZoneFindFirstArgs} args - Arguments to find a EmployeeZone
     * @example
     * // Get one EmployeeZone
     * const employeeZone = await prisma.employeeZone.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmployeeZoneFindFirstArgs>(args?: SelectSubset<T, EmployeeZoneFindFirstArgs<ExtArgs>>): Prisma__EmployeeZoneClient<$Result.GetResult<Prisma.$EmployeeZonePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmployeeZone that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeZoneFindFirstOrThrowArgs} args - Arguments to find a EmployeeZone
     * @example
     * // Get one EmployeeZone
     * const employeeZone = await prisma.employeeZone.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmployeeZoneFindFirstOrThrowArgs>(args?: SelectSubset<T, EmployeeZoneFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmployeeZoneClient<$Result.GetResult<Prisma.$EmployeeZonePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EmployeeZones that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeZoneFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EmployeeZones
     * const employeeZones = await prisma.employeeZone.findMany()
     * 
     * // Get first 10 EmployeeZones
     * const employeeZones = await prisma.employeeZone.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const employeeZoneWithIdOnly = await prisma.employeeZone.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EmployeeZoneFindManyArgs>(args?: SelectSubset<T, EmployeeZoneFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeeZonePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EmployeeZone.
     * @param {EmployeeZoneCreateArgs} args - Arguments to create a EmployeeZone.
     * @example
     * // Create one EmployeeZone
     * const EmployeeZone = await prisma.employeeZone.create({
     *   data: {
     *     // ... data to create a EmployeeZone
     *   }
     * })
     * 
     */
    create<T extends EmployeeZoneCreateArgs>(args: SelectSubset<T, EmployeeZoneCreateArgs<ExtArgs>>): Prisma__EmployeeZoneClient<$Result.GetResult<Prisma.$EmployeeZonePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EmployeeZones.
     * @param {EmployeeZoneCreateManyArgs} args - Arguments to create many EmployeeZones.
     * @example
     * // Create many EmployeeZones
     * const employeeZone = await prisma.employeeZone.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmployeeZoneCreateManyArgs>(args?: SelectSubset<T, EmployeeZoneCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EmployeeZones and returns the data saved in the database.
     * @param {EmployeeZoneCreateManyAndReturnArgs} args - Arguments to create many EmployeeZones.
     * @example
     * // Create many EmployeeZones
     * const employeeZone = await prisma.employeeZone.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EmployeeZones and only return the `id`
     * const employeeZoneWithIdOnly = await prisma.employeeZone.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EmployeeZoneCreateManyAndReturnArgs>(args?: SelectSubset<T, EmployeeZoneCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeeZonePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a EmployeeZone.
     * @param {EmployeeZoneDeleteArgs} args - Arguments to delete one EmployeeZone.
     * @example
     * // Delete one EmployeeZone
     * const EmployeeZone = await prisma.employeeZone.delete({
     *   where: {
     *     // ... filter to delete one EmployeeZone
     *   }
     * })
     * 
     */
    delete<T extends EmployeeZoneDeleteArgs>(args: SelectSubset<T, EmployeeZoneDeleteArgs<ExtArgs>>): Prisma__EmployeeZoneClient<$Result.GetResult<Prisma.$EmployeeZonePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EmployeeZone.
     * @param {EmployeeZoneUpdateArgs} args - Arguments to update one EmployeeZone.
     * @example
     * // Update one EmployeeZone
     * const employeeZone = await prisma.employeeZone.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmployeeZoneUpdateArgs>(args: SelectSubset<T, EmployeeZoneUpdateArgs<ExtArgs>>): Prisma__EmployeeZoneClient<$Result.GetResult<Prisma.$EmployeeZonePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EmployeeZones.
     * @param {EmployeeZoneDeleteManyArgs} args - Arguments to filter EmployeeZones to delete.
     * @example
     * // Delete a few EmployeeZones
     * const { count } = await prisma.employeeZone.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmployeeZoneDeleteManyArgs>(args?: SelectSubset<T, EmployeeZoneDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmployeeZones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeZoneUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EmployeeZones
     * const employeeZone = await prisma.employeeZone.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmployeeZoneUpdateManyArgs>(args: SelectSubset<T, EmployeeZoneUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmployeeZones and returns the data updated in the database.
     * @param {EmployeeZoneUpdateManyAndReturnArgs} args - Arguments to update many EmployeeZones.
     * @example
     * // Update many EmployeeZones
     * const employeeZone = await prisma.employeeZone.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more EmployeeZones and only return the `id`
     * const employeeZoneWithIdOnly = await prisma.employeeZone.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EmployeeZoneUpdateManyAndReturnArgs>(args: SelectSubset<T, EmployeeZoneUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeeZonePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one EmployeeZone.
     * @param {EmployeeZoneUpsertArgs} args - Arguments to update or create a EmployeeZone.
     * @example
     * // Update or create a EmployeeZone
     * const employeeZone = await prisma.employeeZone.upsert({
     *   create: {
     *     // ... data to create a EmployeeZone
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EmployeeZone we want to update
     *   }
     * })
     */
    upsert<T extends EmployeeZoneUpsertArgs>(args: SelectSubset<T, EmployeeZoneUpsertArgs<ExtArgs>>): Prisma__EmployeeZoneClient<$Result.GetResult<Prisma.$EmployeeZonePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EmployeeZones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeZoneCountArgs} args - Arguments to filter EmployeeZones to count.
     * @example
     * // Count the number of EmployeeZones
     * const count = await prisma.employeeZone.count({
     *   where: {
     *     // ... the filter for the EmployeeZones we want to count
     *   }
     * })
    **/
    count<T extends EmployeeZoneCountArgs>(
      args?: Subset<T, EmployeeZoneCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmployeeZoneCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EmployeeZone.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeZoneAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmployeeZoneAggregateArgs>(args: Subset<T, EmployeeZoneAggregateArgs>): Prisma.PrismaPromise<GetEmployeeZoneAggregateType<T>>

    /**
     * Group by EmployeeZone.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeZoneGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmployeeZoneGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmployeeZoneGroupByArgs['orderBy'] }
        : { orderBy?: EmployeeZoneGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmployeeZoneGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmployeeZoneGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EmployeeZone model
   */
  readonly fields: EmployeeZoneFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EmployeeZone.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmployeeZoneClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    employee<T extends EmployeeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmployeeDefaultArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    zone<T extends ZoneDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ZoneDefaultArgs<ExtArgs>>): Prisma__ZoneClient<$Result.GetResult<Prisma.$ZonePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EmployeeZone model
   */
  interface EmployeeZoneFieldRefs {
    readonly id: FieldRef<"EmployeeZone", 'String'>
    readonly employeeId: FieldRef<"EmployeeZone", 'String'>
    readonly zoneId: FieldRef<"EmployeeZone", 'String'>
    readonly createdAt: FieldRef<"EmployeeZone", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EmployeeZone findUnique
   */
  export type EmployeeZoneFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeZone
     */
    select?: EmployeeZoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeZone
     */
    omit?: EmployeeZoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeZoneInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeZone to fetch.
     */
    where: EmployeeZoneWhereUniqueInput
  }

  /**
   * EmployeeZone findUniqueOrThrow
   */
  export type EmployeeZoneFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeZone
     */
    select?: EmployeeZoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeZone
     */
    omit?: EmployeeZoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeZoneInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeZone to fetch.
     */
    where: EmployeeZoneWhereUniqueInput
  }

  /**
   * EmployeeZone findFirst
   */
  export type EmployeeZoneFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeZone
     */
    select?: EmployeeZoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeZone
     */
    omit?: EmployeeZoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeZoneInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeZone to fetch.
     */
    where?: EmployeeZoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeeZones to fetch.
     */
    orderBy?: EmployeeZoneOrderByWithRelationInput | EmployeeZoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmployeeZones.
     */
    cursor?: EmployeeZoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeeZones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeeZones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmployeeZones.
     */
    distinct?: EmployeeZoneScalarFieldEnum | EmployeeZoneScalarFieldEnum[]
  }

  /**
   * EmployeeZone findFirstOrThrow
   */
  export type EmployeeZoneFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeZone
     */
    select?: EmployeeZoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeZone
     */
    omit?: EmployeeZoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeZoneInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeZone to fetch.
     */
    where?: EmployeeZoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeeZones to fetch.
     */
    orderBy?: EmployeeZoneOrderByWithRelationInput | EmployeeZoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmployeeZones.
     */
    cursor?: EmployeeZoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeeZones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeeZones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmployeeZones.
     */
    distinct?: EmployeeZoneScalarFieldEnum | EmployeeZoneScalarFieldEnum[]
  }

  /**
   * EmployeeZone findMany
   */
  export type EmployeeZoneFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeZone
     */
    select?: EmployeeZoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeZone
     */
    omit?: EmployeeZoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeZoneInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeZones to fetch.
     */
    where?: EmployeeZoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeeZones to fetch.
     */
    orderBy?: EmployeeZoneOrderByWithRelationInput | EmployeeZoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EmployeeZones.
     */
    cursor?: EmployeeZoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeeZones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeeZones.
     */
    skip?: number
    distinct?: EmployeeZoneScalarFieldEnum | EmployeeZoneScalarFieldEnum[]
  }

  /**
   * EmployeeZone create
   */
  export type EmployeeZoneCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeZone
     */
    select?: EmployeeZoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeZone
     */
    omit?: EmployeeZoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeZoneInclude<ExtArgs> | null
    /**
     * The data needed to create a EmployeeZone.
     */
    data: XOR<EmployeeZoneCreateInput, EmployeeZoneUncheckedCreateInput>
  }

  /**
   * EmployeeZone createMany
   */
  export type EmployeeZoneCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EmployeeZones.
     */
    data: EmployeeZoneCreateManyInput | EmployeeZoneCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EmployeeZone createManyAndReturn
   */
  export type EmployeeZoneCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeZone
     */
    select?: EmployeeZoneSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeZone
     */
    omit?: EmployeeZoneOmit<ExtArgs> | null
    /**
     * The data used to create many EmployeeZones.
     */
    data: EmployeeZoneCreateManyInput | EmployeeZoneCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeZoneIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EmployeeZone update
   */
  export type EmployeeZoneUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeZone
     */
    select?: EmployeeZoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeZone
     */
    omit?: EmployeeZoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeZoneInclude<ExtArgs> | null
    /**
     * The data needed to update a EmployeeZone.
     */
    data: XOR<EmployeeZoneUpdateInput, EmployeeZoneUncheckedUpdateInput>
    /**
     * Choose, which EmployeeZone to update.
     */
    where: EmployeeZoneWhereUniqueInput
  }

  /**
   * EmployeeZone updateMany
   */
  export type EmployeeZoneUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EmployeeZones.
     */
    data: XOR<EmployeeZoneUpdateManyMutationInput, EmployeeZoneUncheckedUpdateManyInput>
    /**
     * Filter which EmployeeZones to update
     */
    where?: EmployeeZoneWhereInput
    /**
     * Limit how many EmployeeZones to update.
     */
    limit?: number
  }

  /**
   * EmployeeZone updateManyAndReturn
   */
  export type EmployeeZoneUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeZone
     */
    select?: EmployeeZoneSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeZone
     */
    omit?: EmployeeZoneOmit<ExtArgs> | null
    /**
     * The data used to update EmployeeZones.
     */
    data: XOR<EmployeeZoneUpdateManyMutationInput, EmployeeZoneUncheckedUpdateManyInput>
    /**
     * Filter which EmployeeZones to update
     */
    where?: EmployeeZoneWhereInput
    /**
     * Limit how many EmployeeZones to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeZoneIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * EmployeeZone upsert
   */
  export type EmployeeZoneUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeZone
     */
    select?: EmployeeZoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeZone
     */
    omit?: EmployeeZoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeZoneInclude<ExtArgs> | null
    /**
     * The filter to search for the EmployeeZone to update in case it exists.
     */
    where: EmployeeZoneWhereUniqueInput
    /**
     * In case the EmployeeZone found by the `where` argument doesn't exist, create a new EmployeeZone with this data.
     */
    create: XOR<EmployeeZoneCreateInput, EmployeeZoneUncheckedCreateInput>
    /**
     * In case the EmployeeZone was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmployeeZoneUpdateInput, EmployeeZoneUncheckedUpdateInput>
  }

  /**
   * EmployeeZone delete
   */
  export type EmployeeZoneDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeZone
     */
    select?: EmployeeZoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeZone
     */
    omit?: EmployeeZoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeZoneInclude<ExtArgs> | null
    /**
     * Filter which EmployeeZone to delete.
     */
    where: EmployeeZoneWhereUniqueInput
  }

  /**
   * EmployeeZone deleteMany
   */
  export type EmployeeZoneDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmployeeZones to delete
     */
    where?: EmployeeZoneWhereInput
    /**
     * Limit how many EmployeeZones to delete.
     */
    limit?: number
  }

  /**
   * EmployeeZone without action
   */
  export type EmployeeZoneDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeZone
     */
    select?: EmployeeZoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeZone
     */
    omit?: EmployeeZoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeZoneInclude<ExtArgs> | null
  }


  /**
   * Model EmployeeAllowedDate
   */

  export type AggregateEmployeeAllowedDate = {
    _count: EmployeeAllowedDateCountAggregateOutputType | null
    _min: EmployeeAllowedDateMinAggregateOutputType | null
    _max: EmployeeAllowedDateMaxAggregateOutputType | null
  }

  export type EmployeeAllowedDateMinAggregateOutputType = {
    id: string | null
    employeeId: string | null
    date: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EmployeeAllowedDateMaxAggregateOutputType = {
    id: string | null
    employeeId: string | null
    date: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EmployeeAllowedDateCountAggregateOutputType = {
    id: number
    employeeId: number
    date: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EmployeeAllowedDateMinAggregateInputType = {
    id?: true
    employeeId?: true
    date?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EmployeeAllowedDateMaxAggregateInputType = {
    id?: true
    employeeId?: true
    date?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EmployeeAllowedDateCountAggregateInputType = {
    id?: true
    employeeId?: true
    date?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EmployeeAllowedDateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmployeeAllowedDate to aggregate.
     */
    where?: EmployeeAllowedDateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeeAllowedDates to fetch.
     */
    orderBy?: EmployeeAllowedDateOrderByWithRelationInput | EmployeeAllowedDateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmployeeAllowedDateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeeAllowedDates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeeAllowedDates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EmployeeAllowedDates
    **/
    _count?: true | EmployeeAllowedDateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmployeeAllowedDateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmployeeAllowedDateMaxAggregateInputType
  }

  export type GetEmployeeAllowedDateAggregateType<T extends EmployeeAllowedDateAggregateArgs> = {
        [P in keyof T & keyof AggregateEmployeeAllowedDate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmployeeAllowedDate[P]>
      : GetScalarType<T[P], AggregateEmployeeAllowedDate[P]>
  }




  export type EmployeeAllowedDateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeAllowedDateWhereInput
    orderBy?: EmployeeAllowedDateOrderByWithAggregationInput | EmployeeAllowedDateOrderByWithAggregationInput[]
    by: EmployeeAllowedDateScalarFieldEnum[] | EmployeeAllowedDateScalarFieldEnum
    having?: EmployeeAllowedDateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmployeeAllowedDateCountAggregateInputType | true
    _min?: EmployeeAllowedDateMinAggregateInputType
    _max?: EmployeeAllowedDateMaxAggregateInputType
  }

  export type EmployeeAllowedDateGroupByOutputType = {
    id: string
    employeeId: string
    date: Date
    createdAt: Date
    updatedAt: Date
    _count: EmployeeAllowedDateCountAggregateOutputType | null
    _min: EmployeeAllowedDateMinAggregateOutputType | null
    _max: EmployeeAllowedDateMaxAggregateOutputType | null
  }

  type GetEmployeeAllowedDateGroupByPayload<T extends EmployeeAllowedDateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmployeeAllowedDateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmployeeAllowedDateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmployeeAllowedDateGroupByOutputType[P]>
            : GetScalarType<T[P], EmployeeAllowedDateGroupByOutputType[P]>
        }
      >
    >


  export type EmployeeAllowedDateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    date?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employeeAllowedDate"]>

  export type EmployeeAllowedDateSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    date?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employeeAllowedDate"]>

  export type EmployeeAllowedDateSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    date?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employeeAllowedDate"]>

  export type EmployeeAllowedDateSelectScalar = {
    id?: boolean
    employeeId?: boolean
    date?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EmployeeAllowedDateOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "employeeId" | "date" | "createdAt" | "updatedAt", ExtArgs["result"]["employeeAllowedDate"]>
  export type EmployeeAllowedDateInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }
  export type EmployeeAllowedDateIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }
  export type EmployeeAllowedDateIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }

  export type $EmployeeAllowedDatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EmployeeAllowedDate"
    objects: {
      employee: Prisma.$EmployeePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      employeeId: string
      date: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["employeeAllowedDate"]>
    composites: {}
  }

  type EmployeeAllowedDateGetPayload<S extends boolean | null | undefined | EmployeeAllowedDateDefaultArgs> = $Result.GetResult<Prisma.$EmployeeAllowedDatePayload, S>

  type EmployeeAllowedDateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EmployeeAllowedDateFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EmployeeAllowedDateCountAggregateInputType | true
    }

  export interface EmployeeAllowedDateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EmployeeAllowedDate'], meta: { name: 'EmployeeAllowedDate' } }
    /**
     * Find zero or one EmployeeAllowedDate that matches the filter.
     * @param {EmployeeAllowedDateFindUniqueArgs} args - Arguments to find a EmployeeAllowedDate
     * @example
     * // Get one EmployeeAllowedDate
     * const employeeAllowedDate = await prisma.employeeAllowedDate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmployeeAllowedDateFindUniqueArgs>(args: SelectSubset<T, EmployeeAllowedDateFindUniqueArgs<ExtArgs>>): Prisma__EmployeeAllowedDateClient<$Result.GetResult<Prisma.$EmployeeAllowedDatePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EmployeeAllowedDate that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EmployeeAllowedDateFindUniqueOrThrowArgs} args - Arguments to find a EmployeeAllowedDate
     * @example
     * // Get one EmployeeAllowedDate
     * const employeeAllowedDate = await prisma.employeeAllowedDate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmployeeAllowedDateFindUniqueOrThrowArgs>(args: SelectSubset<T, EmployeeAllowedDateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmployeeAllowedDateClient<$Result.GetResult<Prisma.$EmployeeAllowedDatePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmployeeAllowedDate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeAllowedDateFindFirstArgs} args - Arguments to find a EmployeeAllowedDate
     * @example
     * // Get one EmployeeAllowedDate
     * const employeeAllowedDate = await prisma.employeeAllowedDate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmployeeAllowedDateFindFirstArgs>(args?: SelectSubset<T, EmployeeAllowedDateFindFirstArgs<ExtArgs>>): Prisma__EmployeeAllowedDateClient<$Result.GetResult<Prisma.$EmployeeAllowedDatePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmployeeAllowedDate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeAllowedDateFindFirstOrThrowArgs} args - Arguments to find a EmployeeAllowedDate
     * @example
     * // Get one EmployeeAllowedDate
     * const employeeAllowedDate = await prisma.employeeAllowedDate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmployeeAllowedDateFindFirstOrThrowArgs>(args?: SelectSubset<T, EmployeeAllowedDateFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmployeeAllowedDateClient<$Result.GetResult<Prisma.$EmployeeAllowedDatePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EmployeeAllowedDates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeAllowedDateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EmployeeAllowedDates
     * const employeeAllowedDates = await prisma.employeeAllowedDate.findMany()
     * 
     * // Get first 10 EmployeeAllowedDates
     * const employeeAllowedDates = await prisma.employeeAllowedDate.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const employeeAllowedDateWithIdOnly = await prisma.employeeAllowedDate.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EmployeeAllowedDateFindManyArgs>(args?: SelectSubset<T, EmployeeAllowedDateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeeAllowedDatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EmployeeAllowedDate.
     * @param {EmployeeAllowedDateCreateArgs} args - Arguments to create a EmployeeAllowedDate.
     * @example
     * // Create one EmployeeAllowedDate
     * const EmployeeAllowedDate = await prisma.employeeAllowedDate.create({
     *   data: {
     *     // ... data to create a EmployeeAllowedDate
     *   }
     * })
     * 
     */
    create<T extends EmployeeAllowedDateCreateArgs>(args: SelectSubset<T, EmployeeAllowedDateCreateArgs<ExtArgs>>): Prisma__EmployeeAllowedDateClient<$Result.GetResult<Prisma.$EmployeeAllowedDatePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EmployeeAllowedDates.
     * @param {EmployeeAllowedDateCreateManyArgs} args - Arguments to create many EmployeeAllowedDates.
     * @example
     * // Create many EmployeeAllowedDates
     * const employeeAllowedDate = await prisma.employeeAllowedDate.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmployeeAllowedDateCreateManyArgs>(args?: SelectSubset<T, EmployeeAllowedDateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EmployeeAllowedDates and returns the data saved in the database.
     * @param {EmployeeAllowedDateCreateManyAndReturnArgs} args - Arguments to create many EmployeeAllowedDates.
     * @example
     * // Create many EmployeeAllowedDates
     * const employeeAllowedDate = await prisma.employeeAllowedDate.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EmployeeAllowedDates and only return the `id`
     * const employeeAllowedDateWithIdOnly = await prisma.employeeAllowedDate.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EmployeeAllowedDateCreateManyAndReturnArgs>(args?: SelectSubset<T, EmployeeAllowedDateCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeeAllowedDatePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a EmployeeAllowedDate.
     * @param {EmployeeAllowedDateDeleteArgs} args - Arguments to delete one EmployeeAllowedDate.
     * @example
     * // Delete one EmployeeAllowedDate
     * const EmployeeAllowedDate = await prisma.employeeAllowedDate.delete({
     *   where: {
     *     // ... filter to delete one EmployeeAllowedDate
     *   }
     * })
     * 
     */
    delete<T extends EmployeeAllowedDateDeleteArgs>(args: SelectSubset<T, EmployeeAllowedDateDeleteArgs<ExtArgs>>): Prisma__EmployeeAllowedDateClient<$Result.GetResult<Prisma.$EmployeeAllowedDatePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EmployeeAllowedDate.
     * @param {EmployeeAllowedDateUpdateArgs} args - Arguments to update one EmployeeAllowedDate.
     * @example
     * // Update one EmployeeAllowedDate
     * const employeeAllowedDate = await prisma.employeeAllowedDate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmployeeAllowedDateUpdateArgs>(args: SelectSubset<T, EmployeeAllowedDateUpdateArgs<ExtArgs>>): Prisma__EmployeeAllowedDateClient<$Result.GetResult<Prisma.$EmployeeAllowedDatePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EmployeeAllowedDates.
     * @param {EmployeeAllowedDateDeleteManyArgs} args - Arguments to filter EmployeeAllowedDates to delete.
     * @example
     * // Delete a few EmployeeAllowedDates
     * const { count } = await prisma.employeeAllowedDate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmployeeAllowedDateDeleteManyArgs>(args?: SelectSubset<T, EmployeeAllowedDateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmployeeAllowedDates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeAllowedDateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EmployeeAllowedDates
     * const employeeAllowedDate = await prisma.employeeAllowedDate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmployeeAllowedDateUpdateManyArgs>(args: SelectSubset<T, EmployeeAllowedDateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmployeeAllowedDates and returns the data updated in the database.
     * @param {EmployeeAllowedDateUpdateManyAndReturnArgs} args - Arguments to update many EmployeeAllowedDates.
     * @example
     * // Update many EmployeeAllowedDates
     * const employeeAllowedDate = await prisma.employeeAllowedDate.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more EmployeeAllowedDates and only return the `id`
     * const employeeAllowedDateWithIdOnly = await prisma.employeeAllowedDate.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EmployeeAllowedDateUpdateManyAndReturnArgs>(args: SelectSubset<T, EmployeeAllowedDateUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeeAllowedDatePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one EmployeeAllowedDate.
     * @param {EmployeeAllowedDateUpsertArgs} args - Arguments to update or create a EmployeeAllowedDate.
     * @example
     * // Update or create a EmployeeAllowedDate
     * const employeeAllowedDate = await prisma.employeeAllowedDate.upsert({
     *   create: {
     *     // ... data to create a EmployeeAllowedDate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EmployeeAllowedDate we want to update
     *   }
     * })
     */
    upsert<T extends EmployeeAllowedDateUpsertArgs>(args: SelectSubset<T, EmployeeAllowedDateUpsertArgs<ExtArgs>>): Prisma__EmployeeAllowedDateClient<$Result.GetResult<Prisma.$EmployeeAllowedDatePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EmployeeAllowedDates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeAllowedDateCountArgs} args - Arguments to filter EmployeeAllowedDates to count.
     * @example
     * // Count the number of EmployeeAllowedDates
     * const count = await prisma.employeeAllowedDate.count({
     *   where: {
     *     // ... the filter for the EmployeeAllowedDates we want to count
     *   }
     * })
    **/
    count<T extends EmployeeAllowedDateCountArgs>(
      args?: Subset<T, EmployeeAllowedDateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmployeeAllowedDateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EmployeeAllowedDate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeAllowedDateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmployeeAllowedDateAggregateArgs>(args: Subset<T, EmployeeAllowedDateAggregateArgs>): Prisma.PrismaPromise<GetEmployeeAllowedDateAggregateType<T>>

    /**
     * Group by EmployeeAllowedDate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeAllowedDateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmployeeAllowedDateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmployeeAllowedDateGroupByArgs['orderBy'] }
        : { orderBy?: EmployeeAllowedDateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmployeeAllowedDateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmployeeAllowedDateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EmployeeAllowedDate model
   */
  readonly fields: EmployeeAllowedDateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EmployeeAllowedDate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmployeeAllowedDateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    employee<T extends EmployeeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmployeeDefaultArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EmployeeAllowedDate model
   */
  interface EmployeeAllowedDateFieldRefs {
    readonly id: FieldRef<"EmployeeAllowedDate", 'String'>
    readonly employeeId: FieldRef<"EmployeeAllowedDate", 'String'>
    readonly date: FieldRef<"EmployeeAllowedDate", 'DateTime'>
    readonly createdAt: FieldRef<"EmployeeAllowedDate", 'DateTime'>
    readonly updatedAt: FieldRef<"EmployeeAllowedDate", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EmployeeAllowedDate findUnique
   */
  export type EmployeeAllowedDateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeAllowedDate
     */
    select?: EmployeeAllowedDateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeAllowedDate
     */
    omit?: EmployeeAllowedDateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeAllowedDateInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeAllowedDate to fetch.
     */
    where: EmployeeAllowedDateWhereUniqueInput
  }

  /**
   * EmployeeAllowedDate findUniqueOrThrow
   */
  export type EmployeeAllowedDateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeAllowedDate
     */
    select?: EmployeeAllowedDateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeAllowedDate
     */
    omit?: EmployeeAllowedDateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeAllowedDateInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeAllowedDate to fetch.
     */
    where: EmployeeAllowedDateWhereUniqueInput
  }

  /**
   * EmployeeAllowedDate findFirst
   */
  export type EmployeeAllowedDateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeAllowedDate
     */
    select?: EmployeeAllowedDateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeAllowedDate
     */
    omit?: EmployeeAllowedDateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeAllowedDateInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeAllowedDate to fetch.
     */
    where?: EmployeeAllowedDateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeeAllowedDates to fetch.
     */
    orderBy?: EmployeeAllowedDateOrderByWithRelationInput | EmployeeAllowedDateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmployeeAllowedDates.
     */
    cursor?: EmployeeAllowedDateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeeAllowedDates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeeAllowedDates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmployeeAllowedDates.
     */
    distinct?: EmployeeAllowedDateScalarFieldEnum | EmployeeAllowedDateScalarFieldEnum[]
  }

  /**
   * EmployeeAllowedDate findFirstOrThrow
   */
  export type EmployeeAllowedDateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeAllowedDate
     */
    select?: EmployeeAllowedDateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeAllowedDate
     */
    omit?: EmployeeAllowedDateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeAllowedDateInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeAllowedDate to fetch.
     */
    where?: EmployeeAllowedDateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeeAllowedDates to fetch.
     */
    orderBy?: EmployeeAllowedDateOrderByWithRelationInput | EmployeeAllowedDateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmployeeAllowedDates.
     */
    cursor?: EmployeeAllowedDateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeeAllowedDates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeeAllowedDates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmployeeAllowedDates.
     */
    distinct?: EmployeeAllowedDateScalarFieldEnum | EmployeeAllowedDateScalarFieldEnum[]
  }

  /**
   * EmployeeAllowedDate findMany
   */
  export type EmployeeAllowedDateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeAllowedDate
     */
    select?: EmployeeAllowedDateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeAllowedDate
     */
    omit?: EmployeeAllowedDateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeAllowedDateInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeAllowedDates to fetch.
     */
    where?: EmployeeAllowedDateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeeAllowedDates to fetch.
     */
    orderBy?: EmployeeAllowedDateOrderByWithRelationInput | EmployeeAllowedDateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EmployeeAllowedDates.
     */
    cursor?: EmployeeAllowedDateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeeAllowedDates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeeAllowedDates.
     */
    skip?: number
    distinct?: EmployeeAllowedDateScalarFieldEnum | EmployeeAllowedDateScalarFieldEnum[]
  }

  /**
   * EmployeeAllowedDate create
   */
  export type EmployeeAllowedDateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeAllowedDate
     */
    select?: EmployeeAllowedDateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeAllowedDate
     */
    omit?: EmployeeAllowedDateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeAllowedDateInclude<ExtArgs> | null
    /**
     * The data needed to create a EmployeeAllowedDate.
     */
    data: XOR<EmployeeAllowedDateCreateInput, EmployeeAllowedDateUncheckedCreateInput>
  }

  /**
   * EmployeeAllowedDate createMany
   */
  export type EmployeeAllowedDateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EmployeeAllowedDates.
     */
    data: EmployeeAllowedDateCreateManyInput | EmployeeAllowedDateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EmployeeAllowedDate createManyAndReturn
   */
  export type EmployeeAllowedDateCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeAllowedDate
     */
    select?: EmployeeAllowedDateSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeAllowedDate
     */
    omit?: EmployeeAllowedDateOmit<ExtArgs> | null
    /**
     * The data used to create many EmployeeAllowedDates.
     */
    data: EmployeeAllowedDateCreateManyInput | EmployeeAllowedDateCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeAllowedDateIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EmployeeAllowedDate update
   */
  export type EmployeeAllowedDateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeAllowedDate
     */
    select?: EmployeeAllowedDateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeAllowedDate
     */
    omit?: EmployeeAllowedDateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeAllowedDateInclude<ExtArgs> | null
    /**
     * The data needed to update a EmployeeAllowedDate.
     */
    data: XOR<EmployeeAllowedDateUpdateInput, EmployeeAllowedDateUncheckedUpdateInput>
    /**
     * Choose, which EmployeeAllowedDate to update.
     */
    where: EmployeeAllowedDateWhereUniqueInput
  }

  /**
   * EmployeeAllowedDate updateMany
   */
  export type EmployeeAllowedDateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EmployeeAllowedDates.
     */
    data: XOR<EmployeeAllowedDateUpdateManyMutationInput, EmployeeAllowedDateUncheckedUpdateManyInput>
    /**
     * Filter which EmployeeAllowedDates to update
     */
    where?: EmployeeAllowedDateWhereInput
    /**
     * Limit how many EmployeeAllowedDates to update.
     */
    limit?: number
  }

  /**
   * EmployeeAllowedDate updateManyAndReturn
   */
  export type EmployeeAllowedDateUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeAllowedDate
     */
    select?: EmployeeAllowedDateSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeAllowedDate
     */
    omit?: EmployeeAllowedDateOmit<ExtArgs> | null
    /**
     * The data used to update EmployeeAllowedDates.
     */
    data: XOR<EmployeeAllowedDateUpdateManyMutationInput, EmployeeAllowedDateUncheckedUpdateManyInput>
    /**
     * Filter which EmployeeAllowedDates to update
     */
    where?: EmployeeAllowedDateWhereInput
    /**
     * Limit how many EmployeeAllowedDates to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeAllowedDateIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * EmployeeAllowedDate upsert
   */
  export type EmployeeAllowedDateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeAllowedDate
     */
    select?: EmployeeAllowedDateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeAllowedDate
     */
    omit?: EmployeeAllowedDateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeAllowedDateInclude<ExtArgs> | null
    /**
     * The filter to search for the EmployeeAllowedDate to update in case it exists.
     */
    where: EmployeeAllowedDateWhereUniqueInput
    /**
     * In case the EmployeeAllowedDate found by the `where` argument doesn't exist, create a new EmployeeAllowedDate with this data.
     */
    create: XOR<EmployeeAllowedDateCreateInput, EmployeeAllowedDateUncheckedCreateInput>
    /**
     * In case the EmployeeAllowedDate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmployeeAllowedDateUpdateInput, EmployeeAllowedDateUncheckedUpdateInput>
  }

  /**
   * EmployeeAllowedDate delete
   */
  export type EmployeeAllowedDateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeAllowedDate
     */
    select?: EmployeeAllowedDateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeAllowedDate
     */
    omit?: EmployeeAllowedDateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeAllowedDateInclude<ExtArgs> | null
    /**
     * Filter which EmployeeAllowedDate to delete.
     */
    where: EmployeeAllowedDateWhereUniqueInput
  }

  /**
   * EmployeeAllowedDate deleteMany
   */
  export type EmployeeAllowedDateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmployeeAllowedDates to delete
     */
    where?: EmployeeAllowedDateWhereInput
    /**
     * Limit how many EmployeeAllowedDates to delete.
     */
    limit?: number
  }

  /**
   * EmployeeAllowedDate without action
   */
  export type EmployeeAllowedDateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeAllowedDate
     */
    select?: EmployeeAllowedDateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeAllowedDate
     */
    omit?: EmployeeAllowedDateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeAllowedDateInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    name: 'name',
    username: 'username',
    email: 'email',
    role: 'role',
    password: 'password',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const VendorScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    phoneNumber: 'phoneNumber',
    allowedStaffCount: 'allowedStaffCount',
    accessToken: 'accessToken',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type VendorScalarFieldEnum = (typeof VendorScalarFieldEnum)[keyof typeof VendorScalarFieldEnum]


  export const ZoneScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type ZoneScalarFieldEnum = (typeof ZoneScalarFieldEnum)[keyof typeof ZoneScalarFieldEnum]


  export const GateScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type GateScalarFieldEnum = (typeof GateScalarFieldEnum)[keyof typeof GateScalarFieldEnum]


  export const PermissionScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type PermissionScalarFieldEnum = (typeof PermissionScalarFieldEnum)[keyof typeof PermissionScalarFieldEnum]


  export const EmployeeScalarFieldEnum: {
    id: 'id',
    identifier: 'identifier',
    name: 'name',
    job: 'job',
    nationalId: 'nationalId',
    version: 'version',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt',
    status: 'status',
    vendorId: 'vendorId'
  };

  export type EmployeeScalarFieldEnum = (typeof EmployeeScalarFieldEnum)[keyof typeof EmployeeScalarFieldEnum]


  export const WorkingHoursScalarFieldEnum: {
    id: 'id',
    dayOfWeek: 'dayOfWeek',
    startTime: 'startTime',
    endTime: 'endTime',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    employeeId: 'employeeId'
  };

  export type WorkingHoursScalarFieldEnum = (typeof WorkingHoursScalarFieldEnum)[keyof typeof WorkingHoursScalarFieldEnum]


  export const AlertScalarFieldEnum: {
    id: 'id',
    text: 'text',
    severity: 'severity',
    isResolved: 'isResolved',
    resolvedAt: 'resolvedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    employeeId: 'employeeId',
    userId: 'userId',
    activityId: 'activityId'
  };

  export type AlertScalarFieldEnum = (typeof AlertScalarFieldEnum)[keyof typeof AlertScalarFieldEnum]


  export const ActivityScalarFieldEnum: {
    id: 'id',
    type: 'type',
    status: 'status',
    denialReason: 'denialReason',
    scannedAt: 'scannedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    employeeId: 'employeeId',
    scannerId: 'scannerId',
    gateId: 'gateId'
  };

  export type ActivityScalarFieldEnum = (typeof ActivityScalarFieldEnum)[keyof typeof ActivityScalarFieldEnum]


  export const AttachmentScalarFieldEnum: {
    id: 'id',
    url: 'url',
    key: 'key',
    name: 'name',
    mimeType: 'mimeType',
    size: 'size',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AttachmentScalarFieldEnum = (typeof AttachmentScalarFieldEnum)[keyof typeof AttachmentScalarFieldEnum]


  export const VendorAttachmentScalarFieldEnum: {
    id: 'id',
    vendorId: 'vendorId',
    attachmentId: 'attachmentId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type VendorAttachmentScalarFieldEnum = (typeof VendorAttachmentScalarFieldEnum)[keyof typeof VendorAttachmentScalarFieldEnum]


  export const EmployeeAttachmentScalarFieldEnum: {
    id: 'id',
    type: 'type',
    employeeId: 'employeeId',
    attachmentId: 'attachmentId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EmployeeAttachmentScalarFieldEnum = (typeof EmployeeAttachmentScalarFieldEnum)[keyof typeof EmployeeAttachmentScalarFieldEnum]


  export const EmployeePermissionScalarFieldEnum: {
    id: 'id',
    employeeId: 'employeeId',
    permissionId: 'permissionId',
    grantedAt: 'grantedAt',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EmployeePermissionScalarFieldEnum = (typeof EmployeePermissionScalarFieldEnum)[keyof typeof EmployeePermissionScalarFieldEnum]


  export const VendorGateScalarFieldEnum: {
    id: 'id',
    vendorId: 'vendorId',
    gateId: 'gateId',
    createdAt: 'createdAt'
  };

  export type VendorGateScalarFieldEnum = (typeof VendorGateScalarFieldEnum)[keyof typeof VendorGateScalarFieldEnum]


  export const VendorZoneScalarFieldEnum: {
    id: 'id',
    vendorId: 'vendorId',
    zoneId: 'zoneId',
    createdAt: 'createdAt'
  };

  export type VendorZoneScalarFieldEnum = (typeof VendorZoneScalarFieldEnum)[keyof typeof VendorZoneScalarFieldEnum]


  export const EmployeeGateScalarFieldEnum: {
    id: 'id',
    employeeId: 'employeeId',
    gateId: 'gateId',
    createdAt: 'createdAt'
  };

  export type EmployeeGateScalarFieldEnum = (typeof EmployeeGateScalarFieldEnum)[keyof typeof EmployeeGateScalarFieldEnum]


  export const EmployeeZoneScalarFieldEnum: {
    id: 'id',
    employeeId: 'employeeId',
    zoneId: 'zoneId',
    createdAt: 'createdAt'
  };

  export type EmployeeZoneScalarFieldEnum = (typeof EmployeeZoneScalarFieldEnum)[keyof typeof EmployeeZoneScalarFieldEnum]


  export const EmployeeAllowedDateScalarFieldEnum: {
    id: 'id',
    employeeId: 'employeeId',
    date: 'date',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EmployeeAllowedDateScalarFieldEnum = (typeof EmployeeAllowedDateScalarFieldEnum)[keyof typeof EmployeeAllowedDateScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Role'
   */
  export type EnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role'>
    


  /**
   * Reference to a field of type 'Role[]'
   */
  export type ListEnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'EmployeeStatus'
   */
  export type EnumEmployeeStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EmployeeStatus'>
    


  /**
   * Reference to a field of type 'EmployeeStatus[]'
   */
  export type ListEnumEmployeeStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EmployeeStatus[]'>
    


  /**
   * Reference to a field of type 'DayOfWeek'
   */
  export type EnumDayOfWeekFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DayOfWeek'>
    


  /**
   * Reference to a field of type 'DayOfWeek[]'
   */
  export type ListEnumDayOfWeekFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DayOfWeek[]'>
    


  /**
   * Reference to a field of type 'ActivityType'
   */
  export type EnumActivityTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ActivityType'>
    


  /**
   * Reference to a field of type 'ActivityType[]'
   */
  export type ListEnumActivityTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ActivityType[]'>
    


  /**
   * Reference to a field of type 'AccessStatus'
   */
  export type EnumAccessStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AccessStatus'>
    


  /**
   * Reference to a field of type 'AccessStatus[]'
   */
  export type ListEnumAccessStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AccessStatus[]'>
    


  /**
   * Reference to a field of type 'EmployeeAttachmentType'
   */
  export type EnumEmployeeAttachmentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EmployeeAttachmentType'>
    


  /**
   * Reference to a field of type 'EmployeeAttachmentType[]'
   */
  export type ListEnumEmployeeAttachmentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EmployeeAttachmentType[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    username?: StringNullableFilter<"User"> | string | null
    email?: StringNullableFilter<"User"> | string | null
    role?: EnumRoleFilter<"User"> | $Enums.Role
    password?: StringNullableFilter<"User"> | string | null
    isActive?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    activities?: ActivityListRelationFilter
    alerts?: AlertListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    username?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    role?: SortOrder
    password?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    activities?: ActivityOrderByRelationAggregateInput
    alerts?: AlertOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    username?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringNullableFilter<"User"> | string | null
    role?: EnumRoleFilter<"User"> | $Enums.Role
    password?: StringNullableFilter<"User"> | string | null
    isActive?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    activities?: ActivityListRelationFilter
    alerts?: AlertListRelationFilter
  }, "id" | "username" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    username?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    role?: SortOrder
    password?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    name?: StringNullableWithAggregatesFilter<"User"> | string | null
    username?: StringNullableWithAggregatesFilter<"User"> | string | null
    email?: StringNullableWithAggregatesFilter<"User"> | string | null
    role?: EnumRoleWithAggregatesFilter<"User"> | $Enums.Role
    password?: StringNullableWithAggregatesFilter<"User"> | string | null
    isActive?: BoolWithAggregatesFilter<"User"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type VendorWhereInput = {
    AND?: VendorWhereInput | VendorWhereInput[]
    OR?: VendorWhereInput[]
    NOT?: VendorWhereInput | VendorWhereInput[]
    id?: StringFilter<"Vendor"> | string
    name?: StringFilter<"Vendor"> | string
    description?: StringNullableFilter<"Vendor"> | string | null
    phoneNumber?: StringNullableFilter<"Vendor"> | string | null
    allowedStaffCount?: IntFilter<"Vendor"> | number
    accessToken?: StringFilter<"Vendor"> | string
    createdAt?: DateTimeFilter<"Vendor"> | Date | string
    updatedAt?: DateTimeFilter<"Vendor"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Vendor"> | Date | string | null
    employees?: EmployeeListRelationFilter
    vendorAttachments?: VendorAttachmentListRelationFilter
    gates?: VendorGateListRelationFilter
    zones?: VendorZoneListRelationFilter
  }

  export type VendorOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    phoneNumber?: SortOrderInput | SortOrder
    allowedStaffCount?: SortOrder
    accessToken?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    employees?: EmployeeOrderByRelationAggregateInput
    vendorAttachments?: VendorAttachmentOrderByRelationAggregateInput
    gates?: VendorGateOrderByRelationAggregateInput
    zones?: VendorZoneOrderByRelationAggregateInput
  }

  export type VendorWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    accessToken?: string
    AND?: VendorWhereInput | VendorWhereInput[]
    OR?: VendorWhereInput[]
    NOT?: VendorWhereInput | VendorWhereInput[]
    name?: StringFilter<"Vendor"> | string
    description?: StringNullableFilter<"Vendor"> | string | null
    phoneNumber?: StringNullableFilter<"Vendor"> | string | null
    allowedStaffCount?: IntFilter<"Vendor"> | number
    createdAt?: DateTimeFilter<"Vendor"> | Date | string
    updatedAt?: DateTimeFilter<"Vendor"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Vendor"> | Date | string | null
    employees?: EmployeeListRelationFilter
    vendorAttachments?: VendorAttachmentListRelationFilter
    gates?: VendorGateListRelationFilter
    zones?: VendorZoneListRelationFilter
  }, "id" | "accessToken">

  export type VendorOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    phoneNumber?: SortOrderInput | SortOrder
    allowedStaffCount?: SortOrder
    accessToken?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: VendorCountOrderByAggregateInput
    _avg?: VendorAvgOrderByAggregateInput
    _max?: VendorMaxOrderByAggregateInput
    _min?: VendorMinOrderByAggregateInput
    _sum?: VendorSumOrderByAggregateInput
  }

  export type VendorScalarWhereWithAggregatesInput = {
    AND?: VendorScalarWhereWithAggregatesInput | VendorScalarWhereWithAggregatesInput[]
    OR?: VendorScalarWhereWithAggregatesInput[]
    NOT?: VendorScalarWhereWithAggregatesInput | VendorScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Vendor"> | string
    name?: StringWithAggregatesFilter<"Vendor"> | string
    description?: StringNullableWithAggregatesFilter<"Vendor"> | string | null
    phoneNumber?: StringNullableWithAggregatesFilter<"Vendor"> | string | null
    allowedStaffCount?: IntWithAggregatesFilter<"Vendor"> | number
    accessToken?: StringWithAggregatesFilter<"Vendor"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Vendor"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Vendor"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Vendor"> | Date | string | null
  }

  export type ZoneWhereInput = {
    AND?: ZoneWhereInput | ZoneWhereInput[]
    OR?: ZoneWhereInput[]
    NOT?: ZoneWhereInput | ZoneWhereInput[]
    id?: StringFilter<"Zone"> | string
    name?: StringFilter<"Zone"> | string
    description?: StringNullableFilter<"Zone"> | string | null
    createdAt?: DateTimeFilter<"Zone"> | Date | string
    updatedAt?: DateTimeFilter<"Zone"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Zone"> | Date | string | null
    vendors?: VendorZoneListRelationFilter
    employees?: EmployeeZoneListRelationFilter
  }

  export type ZoneOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    vendors?: VendorZoneOrderByRelationAggregateInput
    employees?: EmployeeZoneOrderByRelationAggregateInput
  }

  export type ZoneWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ZoneWhereInput | ZoneWhereInput[]
    OR?: ZoneWhereInput[]
    NOT?: ZoneWhereInput | ZoneWhereInput[]
    name?: StringFilter<"Zone"> | string
    description?: StringNullableFilter<"Zone"> | string | null
    createdAt?: DateTimeFilter<"Zone"> | Date | string
    updatedAt?: DateTimeFilter<"Zone"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Zone"> | Date | string | null
    vendors?: VendorZoneListRelationFilter
    employees?: EmployeeZoneListRelationFilter
  }, "id">

  export type ZoneOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: ZoneCountOrderByAggregateInput
    _max?: ZoneMaxOrderByAggregateInput
    _min?: ZoneMinOrderByAggregateInput
  }

  export type ZoneScalarWhereWithAggregatesInput = {
    AND?: ZoneScalarWhereWithAggregatesInput | ZoneScalarWhereWithAggregatesInput[]
    OR?: ZoneScalarWhereWithAggregatesInput[]
    NOT?: ZoneScalarWhereWithAggregatesInput | ZoneScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Zone"> | string
    name?: StringWithAggregatesFilter<"Zone"> | string
    description?: StringNullableWithAggregatesFilter<"Zone"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Zone"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Zone"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Zone"> | Date | string | null
  }

  export type GateWhereInput = {
    AND?: GateWhereInput | GateWhereInput[]
    OR?: GateWhereInput[]
    NOT?: GateWhereInput | GateWhereInput[]
    id?: StringFilter<"Gate"> | string
    name?: StringFilter<"Gate"> | string
    description?: StringNullableFilter<"Gate"> | string | null
    createdAt?: DateTimeFilter<"Gate"> | Date | string
    updatedAt?: DateTimeFilter<"Gate"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Gate"> | Date | string | null
    vendors?: VendorGateListRelationFilter
    employees?: EmployeeGateListRelationFilter
    activities?: ActivityListRelationFilter
  }

  export type GateOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    vendors?: VendorGateOrderByRelationAggregateInput
    employees?: EmployeeGateOrderByRelationAggregateInput
    activities?: ActivityOrderByRelationAggregateInput
  }

  export type GateWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: GateWhereInput | GateWhereInput[]
    OR?: GateWhereInput[]
    NOT?: GateWhereInput | GateWhereInput[]
    name?: StringFilter<"Gate"> | string
    description?: StringNullableFilter<"Gate"> | string | null
    createdAt?: DateTimeFilter<"Gate"> | Date | string
    updatedAt?: DateTimeFilter<"Gate"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Gate"> | Date | string | null
    vendors?: VendorGateListRelationFilter
    employees?: EmployeeGateListRelationFilter
    activities?: ActivityListRelationFilter
  }, "id">

  export type GateOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: GateCountOrderByAggregateInput
    _max?: GateMaxOrderByAggregateInput
    _min?: GateMinOrderByAggregateInput
  }

  export type GateScalarWhereWithAggregatesInput = {
    AND?: GateScalarWhereWithAggregatesInput | GateScalarWhereWithAggregatesInput[]
    OR?: GateScalarWhereWithAggregatesInput[]
    NOT?: GateScalarWhereWithAggregatesInput | GateScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Gate"> | string
    name?: StringWithAggregatesFilter<"Gate"> | string
    description?: StringNullableWithAggregatesFilter<"Gate"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Gate"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Gate"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Gate"> | Date | string | null
  }

  export type PermissionWhereInput = {
    AND?: PermissionWhereInput | PermissionWhereInput[]
    OR?: PermissionWhereInput[]
    NOT?: PermissionWhereInput | PermissionWhereInput[]
    id?: StringFilter<"Permission"> | string
    name?: StringFilter<"Permission"> | string
    description?: StringNullableFilter<"Permission"> | string | null
    createdAt?: DateTimeFilter<"Permission"> | Date | string
    updatedAt?: DateTimeFilter<"Permission"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Permission"> | Date | string | null
    employeePermissions?: EmployeePermissionListRelationFilter
  }

  export type PermissionOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    employeePermissions?: EmployeePermissionOrderByRelationAggregateInput
  }

  export type PermissionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PermissionWhereInput | PermissionWhereInput[]
    OR?: PermissionWhereInput[]
    NOT?: PermissionWhereInput | PermissionWhereInput[]
    name?: StringFilter<"Permission"> | string
    description?: StringNullableFilter<"Permission"> | string | null
    createdAt?: DateTimeFilter<"Permission"> | Date | string
    updatedAt?: DateTimeFilter<"Permission"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Permission"> | Date | string | null
    employeePermissions?: EmployeePermissionListRelationFilter
  }, "id">

  export type PermissionOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: PermissionCountOrderByAggregateInput
    _max?: PermissionMaxOrderByAggregateInput
    _min?: PermissionMinOrderByAggregateInput
  }

  export type PermissionScalarWhereWithAggregatesInput = {
    AND?: PermissionScalarWhereWithAggregatesInput | PermissionScalarWhereWithAggregatesInput[]
    OR?: PermissionScalarWhereWithAggregatesInput[]
    NOT?: PermissionScalarWhereWithAggregatesInput | PermissionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Permission"> | string
    name?: StringWithAggregatesFilter<"Permission"> | string
    description?: StringNullableWithAggregatesFilter<"Permission"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Permission"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Permission"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Permission"> | Date | string | null
  }

  export type EmployeeWhereInput = {
    AND?: EmployeeWhereInput | EmployeeWhereInput[]
    OR?: EmployeeWhereInput[]
    NOT?: EmployeeWhereInput | EmployeeWhereInput[]
    id?: StringFilter<"Employee"> | string
    identifier?: StringFilter<"Employee"> | string
    name?: StringFilter<"Employee"> | string
    job?: StringFilter<"Employee"> | string
    nationalId?: StringFilter<"Employee"> | string
    version?: IntFilter<"Employee"> | number
    createdAt?: DateTimeFilter<"Employee"> | Date | string
    updatedAt?: DateTimeFilter<"Employee"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Employee"> | Date | string | null
    status?: EnumEmployeeStatusFilter<"Employee"> | $Enums.EmployeeStatus
    vendorId?: StringFilter<"Employee"> | string
    vendor?: XOR<VendorScalarRelationFilter, VendorWhereInput>
    gates?: EmployeeGateListRelationFilter
    zones?: EmployeeZoneListRelationFilter
    activities?: ActivityListRelationFilter
    workingHours?: WorkingHoursListRelationFilter
    employeeAttachments?: EmployeeAttachmentListRelationFilter
    employeePermissions?: EmployeePermissionListRelationFilter
    alerts?: AlertListRelationFilter
    allowedDates?: EmployeeAllowedDateListRelationFilter
  }

  export type EmployeeOrderByWithRelationInput = {
    id?: SortOrder
    identifier?: SortOrder
    name?: SortOrder
    job?: SortOrder
    nationalId?: SortOrder
    version?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    status?: SortOrder
    vendorId?: SortOrder
    vendor?: VendorOrderByWithRelationInput
    gates?: EmployeeGateOrderByRelationAggregateInput
    zones?: EmployeeZoneOrderByRelationAggregateInput
    activities?: ActivityOrderByRelationAggregateInput
    workingHours?: WorkingHoursOrderByRelationAggregateInput
    employeeAttachments?: EmployeeAttachmentOrderByRelationAggregateInput
    employeePermissions?: EmployeePermissionOrderByRelationAggregateInput
    alerts?: AlertOrderByRelationAggregateInput
    allowedDates?: EmployeeAllowedDateOrderByRelationAggregateInput
  }

  export type EmployeeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    identifier_deletedAt?: EmployeeIdentifierDeletedAtCompoundUniqueInput
    AND?: EmployeeWhereInput | EmployeeWhereInput[]
    OR?: EmployeeWhereInput[]
    NOT?: EmployeeWhereInput | EmployeeWhereInput[]
    identifier?: StringFilter<"Employee"> | string
    name?: StringFilter<"Employee"> | string
    job?: StringFilter<"Employee"> | string
    nationalId?: StringFilter<"Employee"> | string
    version?: IntFilter<"Employee"> | number
    createdAt?: DateTimeFilter<"Employee"> | Date | string
    updatedAt?: DateTimeFilter<"Employee"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Employee"> | Date | string | null
    status?: EnumEmployeeStatusFilter<"Employee"> | $Enums.EmployeeStatus
    vendorId?: StringFilter<"Employee"> | string
    vendor?: XOR<VendorScalarRelationFilter, VendorWhereInput>
    gates?: EmployeeGateListRelationFilter
    zones?: EmployeeZoneListRelationFilter
    activities?: ActivityListRelationFilter
    workingHours?: WorkingHoursListRelationFilter
    employeeAttachments?: EmployeeAttachmentListRelationFilter
    employeePermissions?: EmployeePermissionListRelationFilter
    alerts?: AlertListRelationFilter
    allowedDates?: EmployeeAllowedDateListRelationFilter
  }, "id" | "identifier_deletedAt">

  export type EmployeeOrderByWithAggregationInput = {
    id?: SortOrder
    identifier?: SortOrder
    name?: SortOrder
    job?: SortOrder
    nationalId?: SortOrder
    version?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    status?: SortOrder
    vendorId?: SortOrder
    _count?: EmployeeCountOrderByAggregateInput
    _avg?: EmployeeAvgOrderByAggregateInput
    _max?: EmployeeMaxOrderByAggregateInput
    _min?: EmployeeMinOrderByAggregateInput
    _sum?: EmployeeSumOrderByAggregateInput
  }

  export type EmployeeScalarWhereWithAggregatesInput = {
    AND?: EmployeeScalarWhereWithAggregatesInput | EmployeeScalarWhereWithAggregatesInput[]
    OR?: EmployeeScalarWhereWithAggregatesInput[]
    NOT?: EmployeeScalarWhereWithAggregatesInput | EmployeeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Employee"> | string
    identifier?: StringWithAggregatesFilter<"Employee"> | string
    name?: StringWithAggregatesFilter<"Employee"> | string
    job?: StringWithAggregatesFilter<"Employee"> | string
    nationalId?: StringWithAggregatesFilter<"Employee"> | string
    version?: IntWithAggregatesFilter<"Employee"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Employee"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Employee"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Employee"> | Date | string | null
    status?: EnumEmployeeStatusWithAggregatesFilter<"Employee"> | $Enums.EmployeeStatus
    vendorId?: StringWithAggregatesFilter<"Employee"> | string
  }

  export type WorkingHoursWhereInput = {
    AND?: WorkingHoursWhereInput | WorkingHoursWhereInput[]
    OR?: WorkingHoursWhereInput[]
    NOT?: WorkingHoursWhereInput | WorkingHoursWhereInput[]
    id?: StringFilter<"WorkingHours"> | string
    dayOfWeek?: EnumDayOfWeekFilter<"WorkingHours"> | $Enums.DayOfWeek
    startTime?: StringFilter<"WorkingHours"> | string
    endTime?: StringFilter<"WorkingHours"> | string
    isActive?: BoolFilter<"WorkingHours"> | boolean
    createdAt?: DateTimeFilter<"WorkingHours"> | Date | string
    updatedAt?: DateTimeFilter<"WorkingHours"> | Date | string
    employeeId?: StringFilter<"WorkingHours"> | string
    employee?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
  }

  export type WorkingHoursOrderByWithRelationInput = {
    id?: SortOrder
    dayOfWeek?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    employeeId?: SortOrder
    employee?: EmployeeOrderByWithRelationInput
  }

  export type WorkingHoursWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    employeeId_dayOfWeek?: WorkingHoursEmployeeIdDayOfWeekCompoundUniqueInput
    AND?: WorkingHoursWhereInput | WorkingHoursWhereInput[]
    OR?: WorkingHoursWhereInput[]
    NOT?: WorkingHoursWhereInput | WorkingHoursWhereInput[]
    dayOfWeek?: EnumDayOfWeekFilter<"WorkingHours"> | $Enums.DayOfWeek
    startTime?: StringFilter<"WorkingHours"> | string
    endTime?: StringFilter<"WorkingHours"> | string
    isActive?: BoolFilter<"WorkingHours"> | boolean
    createdAt?: DateTimeFilter<"WorkingHours"> | Date | string
    updatedAt?: DateTimeFilter<"WorkingHours"> | Date | string
    employeeId?: StringFilter<"WorkingHours"> | string
    employee?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
  }, "id" | "employeeId_dayOfWeek">

  export type WorkingHoursOrderByWithAggregationInput = {
    id?: SortOrder
    dayOfWeek?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    employeeId?: SortOrder
    _count?: WorkingHoursCountOrderByAggregateInput
    _max?: WorkingHoursMaxOrderByAggregateInput
    _min?: WorkingHoursMinOrderByAggregateInput
  }

  export type WorkingHoursScalarWhereWithAggregatesInput = {
    AND?: WorkingHoursScalarWhereWithAggregatesInput | WorkingHoursScalarWhereWithAggregatesInput[]
    OR?: WorkingHoursScalarWhereWithAggregatesInput[]
    NOT?: WorkingHoursScalarWhereWithAggregatesInput | WorkingHoursScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WorkingHours"> | string
    dayOfWeek?: EnumDayOfWeekWithAggregatesFilter<"WorkingHours"> | $Enums.DayOfWeek
    startTime?: StringWithAggregatesFilter<"WorkingHours"> | string
    endTime?: StringWithAggregatesFilter<"WorkingHours"> | string
    isActive?: BoolWithAggregatesFilter<"WorkingHours"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"WorkingHours"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"WorkingHours"> | Date | string
    employeeId?: StringWithAggregatesFilter<"WorkingHours"> | string
  }

  export type AlertWhereInput = {
    AND?: AlertWhereInput | AlertWhereInput[]
    OR?: AlertWhereInput[]
    NOT?: AlertWhereInput | AlertWhereInput[]
    id?: StringFilter<"Alert"> | string
    text?: StringFilter<"Alert"> | string
    severity?: StringFilter<"Alert"> | string
    isResolved?: BoolFilter<"Alert"> | boolean
    resolvedAt?: DateTimeNullableFilter<"Alert"> | Date | string | null
    createdAt?: DateTimeFilter<"Alert"> | Date | string
    updatedAt?: DateTimeFilter<"Alert"> | Date | string
    employeeId?: StringNullableFilter<"Alert"> | string | null
    userId?: StringNullableFilter<"Alert"> | string | null
    activityId?: StringNullableFilter<"Alert"> | string | null
    employee?: XOR<EmployeeNullableScalarRelationFilter, EmployeeWhereInput> | null
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    activity?: XOR<ActivityNullableScalarRelationFilter, ActivityWhereInput> | null
  }

  export type AlertOrderByWithRelationInput = {
    id?: SortOrder
    text?: SortOrder
    severity?: SortOrder
    isResolved?: SortOrder
    resolvedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    employeeId?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    activityId?: SortOrderInput | SortOrder
    employee?: EmployeeOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    activity?: ActivityOrderByWithRelationInput
  }

  export type AlertWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AlertWhereInput | AlertWhereInput[]
    OR?: AlertWhereInput[]
    NOT?: AlertWhereInput | AlertWhereInput[]
    text?: StringFilter<"Alert"> | string
    severity?: StringFilter<"Alert"> | string
    isResolved?: BoolFilter<"Alert"> | boolean
    resolvedAt?: DateTimeNullableFilter<"Alert"> | Date | string | null
    createdAt?: DateTimeFilter<"Alert"> | Date | string
    updatedAt?: DateTimeFilter<"Alert"> | Date | string
    employeeId?: StringNullableFilter<"Alert"> | string | null
    userId?: StringNullableFilter<"Alert"> | string | null
    activityId?: StringNullableFilter<"Alert"> | string | null
    employee?: XOR<EmployeeNullableScalarRelationFilter, EmployeeWhereInput> | null
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    activity?: XOR<ActivityNullableScalarRelationFilter, ActivityWhereInput> | null
  }, "id">

  export type AlertOrderByWithAggregationInput = {
    id?: SortOrder
    text?: SortOrder
    severity?: SortOrder
    isResolved?: SortOrder
    resolvedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    employeeId?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    activityId?: SortOrderInput | SortOrder
    _count?: AlertCountOrderByAggregateInput
    _max?: AlertMaxOrderByAggregateInput
    _min?: AlertMinOrderByAggregateInput
  }

  export type AlertScalarWhereWithAggregatesInput = {
    AND?: AlertScalarWhereWithAggregatesInput | AlertScalarWhereWithAggregatesInput[]
    OR?: AlertScalarWhereWithAggregatesInput[]
    NOT?: AlertScalarWhereWithAggregatesInput | AlertScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Alert"> | string
    text?: StringWithAggregatesFilter<"Alert"> | string
    severity?: StringWithAggregatesFilter<"Alert"> | string
    isResolved?: BoolWithAggregatesFilter<"Alert"> | boolean
    resolvedAt?: DateTimeNullableWithAggregatesFilter<"Alert"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Alert"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Alert"> | Date | string
    employeeId?: StringNullableWithAggregatesFilter<"Alert"> | string | null
    userId?: StringNullableWithAggregatesFilter<"Alert"> | string | null
    activityId?: StringNullableWithAggregatesFilter<"Alert"> | string | null
  }

  export type ActivityWhereInput = {
    AND?: ActivityWhereInput | ActivityWhereInput[]
    OR?: ActivityWhereInput[]
    NOT?: ActivityWhereInput | ActivityWhereInput[]
    id?: StringFilter<"Activity"> | string
    type?: EnumActivityTypeFilter<"Activity"> | $Enums.ActivityType
    status?: EnumAccessStatusFilter<"Activity"> | $Enums.AccessStatus
    denialReason?: StringNullableFilter<"Activity"> | string | null
    scannedAt?: DateTimeFilter<"Activity"> | Date | string
    createdAt?: DateTimeFilter<"Activity"> | Date | string
    updatedAt?: DateTimeFilter<"Activity"> | Date | string
    employeeId?: StringFilter<"Activity"> | string
    scannerId?: StringNullableFilter<"Activity"> | string | null
    gateId?: StringNullableFilter<"Activity"> | string | null
    employee?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
    scanner?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    gate?: XOR<GateNullableScalarRelationFilter, GateWhereInput> | null
    alerts?: AlertListRelationFilter
  }

  export type ActivityOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    status?: SortOrder
    denialReason?: SortOrderInput | SortOrder
    scannedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    employeeId?: SortOrder
    scannerId?: SortOrderInput | SortOrder
    gateId?: SortOrderInput | SortOrder
    employee?: EmployeeOrderByWithRelationInput
    scanner?: UserOrderByWithRelationInput
    gate?: GateOrderByWithRelationInput
    alerts?: AlertOrderByRelationAggregateInput
  }

  export type ActivityWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ActivityWhereInput | ActivityWhereInput[]
    OR?: ActivityWhereInput[]
    NOT?: ActivityWhereInput | ActivityWhereInput[]
    type?: EnumActivityTypeFilter<"Activity"> | $Enums.ActivityType
    status?: EnumAccessStatusFilter<"Activity"> | $Enums.AccessStatus
    denialReason?: StringNullableFilter<"Activity"> | string | null
    scannedAt?: DateTimeFilter<"Activity"> | Date | string
    createdAt?: DateTimeFilter<"Activity"> | Date | string
    updatedAt?: DateTimeFilter<"Activity"> | Date | string
    employeeId?: StringFilter<"Activity"> | string
    scannerId?: StringNullableFilter<"Activity"> | string | null
    gateId?: StringNullableFilter<"Activity"> | string | null
    employee?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
    scanner?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    gate?: XOR<GateNullableScalarRelationFilter, GateWhereInput> | null
    alerts?: AlertListRelationFilter
  }, "id">

  export type ActivityOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    status?: SortOrder
    denialReason?: SortOrderInput | SortOrder
    scannedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    employeeId?: SortOrder
    scannerId?: SortOrderInput | SortOrder
    gateId?: SortOrderInput | SortOrder
    _count?: ActivityCountOrderByAggregateInput
    _max?: ActivityMaxOrderByAggregateInput
    _min?: ActivityMinOrderByAggregateInput
  }

  export type ActivityScalarWhereWithAggregatesInput = {
    AND?: ActivityScalarWhereWithAggregatesInput | ActivityScalarWhereWithAggregatesInput[]
    OR?: ActivityScalarWhereWithAggregatesInput[]
    NOT?: ActivityScalarWhereWithAggregatesInput | ActivityScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Activity"> | string
    type?: EnumActivityTypeWithAggregatesFilter<"Activity"> | $Enums.ActivityType
    status?: EnumAccessStatusWithAggregatesFilter<"Activity"> | $Enums.AccessStatus
    denialReason?: StringNullableWithAggregatesFilter<"Activity"> | string | null
    scannedAt?: DateTimeWithAggregatesFilter<"Activity"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"Activity"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Activity"> | Date | string
    employeeId?: StringWithAggregatesFilter<"Activity"> | string
    scannerId?: StringNullableWithAggregatesFilter<"Activity"> | string | null
    gateId?: StringNullableWithAggregatesFilter<"Activity"> | string | null
  }

  export type AttachmentWhereInput = {
    AND?: AttachmentWhereInput | AttachmentWhereInput[]
    OR?: AttachmentWhereInput[]
    NOT?: AttachmentWhereInput | AttachmentWhereInput[]
    id?: StringFilter<"Attachment"> | string
    url?: StringFilter<"Attachment"> | string
    key?: StringNullableFilter<"Attachment"> | string | null
    name?: StringNullableFilter<"Attachment"> | string | null
    mimeType?: StringNullableFilter<"Attachment"> | string | null
    size?: IntNullableFilter<"Attachment"> | number | null
    description?: StringNullableFilter<"Attachment"> | string | null
    createdAt?: DateTimeFilter<"Attachment"> | Date | string
    updatedAt?: DateTimeFilter<"Attachment"> | Date | string
    vendorAttachments?: VendorAttachmentListRelationFilter
    employeeAttachments?: EmployeeAttachmentListRelationFilter
  }

  export type AttachmentOrderByWithRelationInput = {
    id?: SortOrder
    url?: SortOrder
    key?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    mimeType?: SortOrderInput | SortOrder
    size?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    vendorAttachments?: VendorAttachmentOrderByRelationAggregateInput
    employeeAttachments?: EmployeeAttachmentOrderByRelationAggregateInput
  }

  export type AttachmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AttachmentWhereInput | AttachmentWhereInput[]
    OR?: AttachmentWhereInput[]
    NOT?: AttachmentWhereInput | AttachmentWhereInput[]
    url?: StringFilter<"Attachment"> | string
    key?: StringNullableFilter<"Attachment"> | string | null
    name?: StringNullableFilter<"Attachment"> | string | null
    mimeType?: StringNullableFilter<"Attachment"> | string | null
    size?: IntNullableFilter<"Attachment"> | number | null
    description?: StringNullableFilter<"Attachment"> | string | null
    createdAt?: DateTimeFilter<"Attachment"> | Date | string
    updatedAt?: DateTimeFilter<"Attachment"> | Date | string
    vendorAttachments?: VendorAttachmentListRelationFilter
    employeeAttachments?: EmployeeAttachmentListRelationFilter
  }, "id">

  export type AttachmentOrderByWithAggregationInput = {
    id?: SortOrder
    url?: SortOrder
    key?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    mimeType?: SortOrderInput | SortOrder
    size?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AttachmentCountOrderByAggregateInput
    _avg?: AttachmentAvgOrderByAggregateInput
    _max?: AttachmentMaxOrderByAggregateInput
    _min?: AttachmentMinOrderByAggregateInput
    _sum?: AttachmentSumOrderByAggregateInput
  }

  export type AttachmentScalarWhereWithAggregatesInput = {
    AND?: AttachmentScalarWhereWithAggregatesInput | AttachmentScalarWhereWithAggregatesInput[]
    OR?: AttachmentScalarWhereWithAggregatesInput[]
    NOT?: AttachmentScalarWhereWithAggregatesInput | AttachmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Attachment"> | string
    url?: StringWithAggregatesFilter<"Attachment"> | string
    key?: StringNullableWithAggregatesFilter<"Attachment"> | string | null
    name?: StringNullableWithAggregatesFilter<"Attachment"> | string | null
    mimeType?: StringNullableWithAggregatesFilter<"Attachment"> | string | null
    size?: IntNullableWithAggregatesFilter<"Attachment"> | number | null
    description?: StringNullableWithAggregatesFilter<"Attachment"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Attachment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Attachment"> | Date | string
  }

  export type VendorAttachmentWhereInput = {
    AND?: VendorAttachmentWhereInput | VendorAttachmentWhereInput[]
    OR?: VendorAttachmentWhereInput[]
    NOT?: VendorAttachmentWhereInput | VendorAttachmentWhereInput[]
    id?: StringFilter<"VendorAttachment"> | string
    vendorId?: StringFilter<"VendorAttachment"> | string
    attachmentId?: StringFilter<"VendorAttachment"> | string
    createdAt?: DateTimeFilter<"VendorAttachment"> | Date | string
    updatedAt?: DateTimeFilter<"VendorAttachment"> | Date | string
    vendor?: XOR<VendorScalarRelationFilter, VendorWhereInput>
    attachment?: XOR<AttachmentScalarRelationFilter, AttachmentWhereInput>
  }

  export type VendorAttachmentOrderByWithRelationInput = {
    id?: SortOrder
    vendorId?: SortOrder
    attachmentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    vendor?: VendorOrderByWithRelationInput
    attachment?: AttachmentOrderByWithRelationInput
  }

  export type VendorAttachmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    vendorId_attachmentId?: VendorAttachmentVendorIdAttachmentIdCompoundUniqueInput
    AND?: VendorAttachmentWhereInput | VendorAttachmentWhereInput[]
    OR?: VendorAttachmentWhereInput[]
    NOT?: VendorAttachmentWhereInput | VendorAttachmentWhereInput[]
    vendorId?: StringFilter<"VendorAttachment"> | string
    attachmentId?: StringFilter<"VendorAttachment"> | string
    createdAt?: DateTimeFilter<"VendorAttachment"> | Date | string
    updatedAt?: DateTimeFilter<"VendorAttachment"> | Date | string
    vendor?: XOR<VendorScalarRelationFilter, VendorWhereInput>
    attachment?: XOR<AttachmentScalarRelationFilter, AttachmentWhereInput>
  }, "id" | "vendorId_attachmentId">

  export type VendorAttachmentOrderByWithAggregationInput = {
    id?: SortOrder
    vendorId?: SortOrder
    attachmentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: VendorAttachmentCountOrderByAggregateInput
    _max?: VendorAttachmentMaxOrderByAggregateInput
    _min?: VendorAttachmentMinOrderByAggregateInput
  }

  export type VendorAttachmentScalarWhereWithAggregatesInput = {
    AND?: VendorAttachmentScalarWhereWithAggregatesInput | VendorAttachmentScalarWhereWithAggregatesInput[]
    OR?: VendorAttachmentScalarWhereWithAggregatesInput[]
    NOT?: VendorAttachmentScalarWhereWithAggregatesInput | VendorAttachmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"VendorAttachment"> | string
    vendorId?: StringWithAggregatesFilter<"VendorAttachment"> | string
    attachmentId?: StringWithAggregatesFilter<"VendorAttachment"> | string
    createdAt?: DateTimeWithAggregatesFilter<"VendorAttachment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"VendorAttachment"> | Date | string
  }

  export type EmployeeAttachmentWhereInput = {
    AND?: EmployeeAttachmentWhereInput | EmployeeAttachmentWhereInput[]
    OR?: EmployeeAttachmentWhereInput[]
    NOT?: EmployeeAttachmentWhereInput | EmployeeAttachmentWhereInput[]
    id?: StringFilter<"EmployeeAttachment"> | string
    type?: EnumEmployeeAttachmentTypeFilter<"EmployeeAttachment"> | $Enums.EmployeeAttachmentType
    employeeId?: StringFilter<"EmployeeAttachment"> | string
    attachmentId?: StringFilter<"EmployeeAttachment"> | string
    createdAt?: DateTimeFilter<"EmployeeAttachment"> | Date | string
    updatedAt?: DateTimeFilter<"EmployeeAttachment"> | Date | string
    employee?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
    attachment?: XOR<AttachmentScalarRelationFilter, AttachmentWhereInput>
  }

  export type EmployeeAttachmentOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    employeeId?: SortOrder
    attachmentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    employee?: EmployeeOrderByWithRelationInput
    attachment?: AttachmentOrderByWithRelationInput
  }

  export type EmployeeAttachmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    employeeId_attachmentId?: EmployeeAttachmentEmployeeIdAttachmentIdCompoundUniqueInput
    AND?: EmployeeAttachmentWhereInput | EmployeeAttachmentWhereInput[]
    OR?: EmployeeAttachmentWhereInput[]
    NOT?: EmployeeAttachmentWhereInput | EmployeeAttachmentWhereInput[]
    type?: EnumEmployeeAttachmentTypeFilter<"EmployeeAttachment"> | $Enums.EmployeeAttachmentType
    employeeId?: StringFilter<"EmployeeAttachment"> | string
    attachmentId?: StringFilter<"EmployeeAttachment"> | string
    createdAt?: DateTimeFilter<"EmployeeAttachment"> | Date | string
    updatedAt?: DateTimeFilter<"EmployeeAttachment"> | Date | string
    employee?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
    attachment?: XOR<AttachmentScalarRelationFilter, AttachmentWhereInput>
  }, "id" | "employeeId_attachmentId">

  export type EmployeeAttachmentOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    employeeId?: SortOrder
    attachmentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EmployeeAttachmentCountOrderByAggregateInput
    _max?: EmployeeAttachmentMaxOrderByAggregateInput
    _min?: EmployeeAttachmentMinOrderByAggregateInput
  }

  export type EmployeeAttachmentScalarWhereWithAggregatesInput = {
    AND?: EmployeeAttachmentScalarWhereWithAggregatesInput | EmployeeAttachmentScalarWhereWithAggregatesInput[]
    OR?: EmployeeAttachmentScalarWhereWithAggregatesInput[]
    NOT?: EmployeeAttachmentScalarWhereWithAggregatesInput | EmployeeAttachmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EmployeeAttachment"> | string
    type?: EnumEmployeeAttachmentTypeWithAggregatesFilter<"EmployeeAttachment"> | $Enums.EmployeeAttachmentType
    employeeId?: StringWithAggregatesFilter<"EmployeeAttachment"> | string
    attachmentId?: StringWithAggregatesFilter<"EmployeeAttachment"> | string
    createdAt?: DateTimeWithAggregatesFilter<"EmployeeAttachment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"EmployeeAttachment"> | Date | string
  }

  export type EmployeePermissionWhereInput = {
    AND?: EmployeePermissionWhereInput | EmployeePermissionWhereInput[]
    OR?: EmployeePermissionWhereInput[]
    NOT?: EmployeePermissionWhereInput | EmployeePermissionWhereInput[]
    id?: StringFilter<"EmployeePermission"> | string
    employeeId?: StringFilter<"EmployeePermission"> | string
    permissionId?: StringFilter<"EmployeePermission"> | string
    grantedAt?: DateTimeFilter<"EmployeePermission"> | Date | string
    expiresAt?: DateTimeNullableFilter<"EmployeePermission"> | Date | string | null
    createdAt?: DateTimeFilter<"EmployeePermission"> | Date | string
    updatedAt?: DateTimeFilter<"EmployeePermission"> | Date | string
    employee?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
    permission?: XOR<PermissionScalarRelationFilter, PermissionWhereInput>
  }

  export type EmployeePermissionOrderByWithRelationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    permissionId?: SortOrder
    grantedAt?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    employee?: EmployeeOrderByWithRelationInput
    permission?: PermissionOrderByWithRelationInput
  }

  export type EmployeePermissionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    employeeId_permissionId?: EmployeePermissionEmployeeIdPermissionIdCompoundUniqueInput
    AND?: EmployeePermissionWhereInput | EmployeePermissionWhereInput[]
    OR?: EmployeePermissionWhereInput[]
    NOT?: EmployeePermissionWhereInput | EmployeePermissionWhereInput[]
    employeeId?: StringFilter<"EmployeePermission"> | string
    permissionId?: StringFilter<"EmployeePermission"> | string
    grantedAt?: DateTimeFilter<"EmployeePermission"> | Date | string
    expiresAt?: DateTimeNullableFilter<"EmployeePermission"> | Date | string | null
    createdAt?: DateTimeFilter<"EmployeePermission"> | Date | string
    updatedAt?: DateTimeFilter<"EmployeePermission"> | Date | string
    employee?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
    permission?: XOR<PermissionScalarRelationFilter, PermissionWhereInput>
  }, "id" | "employeeId_permissionId">

  export type EmployeePermissionOrderByWithAggregationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    permissionId?: SortOrder
    grantedAt?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EmployeePermissionCountOrderByAggregateInput
    _max?: EmployeePermissionMaxOrderByAggregateInput
    _min?: EmployeePermissionMinOrderByAggregateInput
  }

  export type EmployeePermissionScalarWhereWithAggregatesInput = {
    AND?: EmployeePermissionScalarWhereWithAggregatesInput | EmployeePermissionScalarWhereWithAggregatesInput[]
    OR?: EmployeePermissionScalarWhereWithAggregatesInput[]
    NOT?: EmployeePermissionScalarWhereWithAggregatesInput | EmployeePermissionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EmployeePermission"> | string
    employeeId?: StringWithAggregatesFilter<"EmployeePermission"> | string
    permissionId?: StringWithAggregatesFilter<"EmployeePermission"> | string
    grantedAt?: DateTimeWithAggregatesFilter<"EmployeePermission"> | Date | string
    expiresAt?: DateTimeNullableWithAggregatesFilter<"EmployeePermission"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"EmployeePermission"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"EmployeePermission"> | Date | string
  }

  export type VendorGateWhereInput = {
    AND?: VendorGateWhereInput | VendorGateWhereInput[]
    OR?: VendorGateWhereInput[]
    NOT?: VendorGateWhereInput | VendorGateWhereInput[]
    id?: StringFilter<"VendorGate"> | string
    vendorId?: StringFilter<"VendorGate"> | string
    gateId?: StringFilter<"VendorGate"> | string
    createdAt?: DateTimeFilter<"VendorGate"> | Date | string
    vendor?: XOR<VendorScalarRelationFilter, VendorWhereInput>
    gate?: XOR<GateScalarRelationFilter, GateWhereInput>
  }

  export type VendorGateOrderByWithRelationInput = {
    id?: SortOrder
    vendorId?: SortOrder
    gateId?: SortOrder
    createdAt?: SortOrder
    vendor?: VendorOrderByWithRelationInput
    gate?: GateOrderByWithRelationInput
  }

  export type VendorGateWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    vendorId_gateId?: VendorGateVendorIdGateIdCompoundUniqueInput
    AND?: VendorGateWhereInput | VendorGateWhereInput[]
    OR?: VendorGateWhereInput[]
    NOT?: VendorGateWhereInput | VendorGateWhereInput[]
    vendorId?: StringFilter<"VendorGate"> | string
    gateId?: StringFilter<"VendorGate"> | string
    createdAt?: DateTimeFilter<"VendorGate"> | Date | string
    vendor?: XOR<VendorScalarRelationFilter, VendorWhereInput>
    gate?: XOR<GateScalarRelationFilter, GateWhereInput>
  }, "id" | "vendorId_gateId">

  export type VendorGateOrderByWithAggregationInput = {
    id?: SortOrder
    vendorId?: SortOrder
    gateId?: SortOrder
    createdAt?: SortOrder
    _count?: VendorGateCountOrderByAggregateInput
    _max?: VendorGateMaxOrderByAggregateInput
    _min?: VendorGateMinOrderByAggregateInput
  }

  export type VendorGateScalarWhereWithAggregatesInput = {
    AND?: VendorGateScalarWhereWithAggregatesInput | VendorGateScalarWhereWithAggregatesInput[]
    OR?: VendorGateScalarWhereWithAggregatesInput[]
    NOT?: VendorGateScalarWhereWithAggregatesInput | VendorGateScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"VendorGate"> | string
    vendorId?: StringWithAggregatesFilter<"VendorGate"> | string
    gateId?: StringWithAggregatesFilter<"VendorGate"> | string
    createdAt?: DateTimeWithAggregatesFilter<"VendorGate"> | Date | string
  }

  export type VendorZoneWhereInput = {
    AND?: VendorZoneWhereInput | VendorZoneWhereInput[]
    OR?: VendorZoneWhereInput[]
    NOT?: VendorZoneWhereInput | VendorZoneWhereInput[]
    id?: StringFilter<"VendorZone"> | string
    vendorId?: StringFilter<"VendorZone"> | string
    zoneId?: StringFilter<"VendorZone"> | string
    createdAt?: DateTimeFilter<"VendorZone"> | Date | string
    vendor?: XOR<VendorScalarRelationFilter, VendorWhereInput>
    zone?: XOR<ZoneScalarRelationFilter, ZoneWhereInput>
  }

  export type VendorZoneOrderByWithRelationInput = {
    id?: SortOrder
    vendorId?: SortOrder
    zoneId?: SortOrder
    createdAt?: SortOrder
    vendor?: VendorOrderByWithRelationInput
    zone?: ZoneOrderByWithRelationInput
  }

  export type VendorZoneWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    vendorId_zoneId?: VendorZoneVendorIdZoneIdCompoundUniqueInput
    AND?: VendorZoneWhereInput | VendorZoneWhereInput[]
    OR?: VendorZoneWhereInput[]
    NOT?: VendorZoneWhereInput | VendorZoneWhereInput[]
    vendorId?: StringFilter<"VendorZone"> | string
    zoneId?: StringFilter<"VendorZone"> | string
    createdAt?: DateTimeFilter<"VendorZone"> | Date | string
    vendor?: XOR<VendorScalarRelationFilter, VendorWhereInput>
    zone?: XOR<ZoneScalarRelationFilter, ZoneWhereInput>
  }, "id" | "vendorId_zoneId">

  export type VendorZoneOrderByWithAggregationInput = {
    id?: SortOrder
    vendorId?: SortOrder
    zoneId?: SortOrder
    createdAt?: SortOrder
    _count?: VendorZoneCountOrderByAggregateInput
    _max?: VendorZoneMaxOrderByAggregateInput
    _min?: VendorZoneMinOrderByAggregateInput
  }

  export type VendorZoneScalarWhereWithAggregatesInput = {
    AND?: VendorZoneScalarWhereWithAggregatesInput | VendorZoneScalarWhereWithAggregatesInput[]
    OR?: VendorZoneScalarWhereWithAggregatesInput[]
    NOT?: VendorZoneScalarWhereWithAggregatesInput | VendorZoneScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"VendorZone"> | string
    vendorId?: StringWithAggregatesFilter<"VendorZone"> | string
    zoneId?: StringWithAggregatesFilter<"VendorZone"> | string
    createdAt?: DateTimeWithAggregatesFilter<"VendorZone"> | Date | string
  }

  export type EmployeeGateWhereInput = {
    AND?: EmployeeGateWhereInput | EmployeeGateWhereInput[]
    OR?: EmployeeGateWhereInput[]
    NOT?: EmployeeGateWhereInput | EmployeeGateWhereInput[]
    id?: StringFilter<"EmployeeGate"> | string
    employeeId?: StringFilter<"EmployeeGate"> | string
    gateId?: StringFilter<"EmployeeGate"> | string
    createdAt?: DateTimeFilter<"EmployeeGate"> | Date | string
    employee?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
    gate?: XOR<GateScalarRelationFilter, GateWhereInput>
  }

  export type EmployeeGateOrderByWithRelationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    gateId?: SortOrder
    createdAt?: SortOrder
    employee?: EmployeeOrderByWithRelationInput
    gate?: GateOrderByWithRelationInput
  }

  export type EmployeeGateWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    employeeId_gateId?: EmployeeGateEmployeeIdGateIdCompoundUniqueInput
    AND?: EmployeeGateWhereInput | EmployeeGateWhereInput[]
    OR?: EmployeeGateWhereInput[]
    NOT?: EmployeeGateWhereInput | EmployeeGateWhereInput[]
    employeeId?: StringFilter<"EmployeeGate"> | string
    gateId?: StringFilter<"EmployeeGate"> | string
    createdAt?: DateTimeFilter<"EmployeeGate"> | Date | string
    employee?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
    gate?: XOR<GateScalarRelationFilter, GateWhereInput>
  }, "id" | "employeeId_gateId">

  export type EmployeeGateOrderByWithAggregationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    gateId?: SortOrder
    createdAt?: SortOrder
    _count?: EmployeeGateCountOrderByAggregateInput
    _max?: EmployeeGateMaxOrderByAggregateInput
    _min?: EmployeeGateMinOrderByAggregateInput
  }

  export type EmployeeGateScalarWhereWithAggregatesInput = {
    AND?: EmployeeGateScalarWhereWithAggregatesInput | EmployeeGateScalarWhereWithAggregatesInput[]
    OR?: EmployeeGateScalarWhereWithAggregatesInput[]
    NOT?: EmployeeGateScalarWhereWithAggregatesInput | EmployeeGateScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EmployeeGate"> | string
    employeeId?: StringWithAggregatesFilter<"EmployeeGate"> | string
    gateId?: StringWithAggregatesFilter<"EmployeeGate"> | string
    createdAt?: DateTimeWithAggregatesFilter<"EmployeeGate"> | Date | string
  }

  export type EmployeeZoneWhereInput = {
    AND?: EmployeeZoneWhereInput | EmployeeZoneWhereInput[]
    OR?: EmployeeZoneWhereInput[]
    NOT?: EmployeeZoneWhereInput | EmployeeZoneWhereInput[]
    id?: StringFilter<"EmployeeZone"> | string
    employeeId?: StringFilter<"EmployeeZone"> | string
    zoneId?: StringFilter<"EmployeeZone"> | string
    createdAt?: DateTimeFilter<"EmployeeZone"> | Date | string
    employee?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
    zone?: XOR<ZoneScalarRelationFilter, ZoneWhereInput>
  }

  export type EmployeeZoneOrderByWithRelationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    zoneId?: SortOrder
    createdAt?: SortOrder
    employee?: EmployeeOrderByWithRelationInput
    zone?: ZoneOrderByWithRelationInput
  }

  export type EmployeeZoneWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    employeeId_zoneId?: EmployeeZoneEmployeeIdZoneIdCompoundUniqueInput
    AND?: EmployeeZoneWhereInput | EmployeeZoneWhereInput[]
    OR?: EmployeeZoneWhereInput[]
    NOT?: EmployeeZoneWhereInput | EmployeeZoneWhereInput[]
    employeeId?: StringFilter<"EmployeeZone"> | string
    zoneId?: StringFilter<"EmployeeZone"> | string
    createdAt?: DateTimeFilter<"EmployeeZone"> | Date | string
    employee?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
    zone?: XOR<ZoneScalarRelationFilter, ZoneWhereInput>
  }, "id" | "employeeId_zoneId">

  export type EmployeeZoneOrderByWithAggregationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    zoneId?: SortOrder
    createdAt?: SortOrder
    _count?: EmployeeZoneCountOrderByAggregateInput
    _max?: EmployeeZoneMaxOrderByAggregateInput
    _min?: EmployeeZoneMinOrderByAggregateInput
  }

  export type EmployeeZoneScalarWhereWithAggregatesInput = {
    AND?: EmployeeZoneScalarWhereWithAggregatesInput | EmployeeZoneScalarWhereWithAggregatesInput[]
    OR?: EmployeeZoneScalarWhereWithAggregatesInput[]
    NOT?: EmployeeZoneScalarWhereWithAggregatesInput | EmployeeZoneScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EmployeeZone"> | string
    employeeId?: StringWithAggregatesFilter<"EmployeeZone"> | string
    zoneId?: StringWithAggregatesFilter<"EmployeeZone"> | string
    createdAt?: DateTimeWithAggregatesFilter<"EmployeeZone"> | Date | string
  }

  export type EmployeeAllowedDateWhereInput = {
    AND?: EmployeeAllowedDateWhereInput | EmployeeAllowedDateWhereInput[]
    OR?: EmployeeAllowedDateWhereInput[]
    NOT?: EmployeeAllowedDateWhereInput | EmployeeAllowedDateWhereInput[]
    id?: StringFilter<"EmployeeAllowedDate"> | string
    employeeId?: StringFilter<"EmployeeAllowedDate"> | string
    date?: DateTimeFilter<"EmployeeAllowedDate"> | Date | string
    createdAt?: DateTimeFilter<"EmployeeAllowedDate"> | Date | string
    updatedAt?: DateTimeFilter<"EmployeeAllowedDate"> | Date | string
    employee?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
  }

  export type EmployeeAllowedDateOrderByWithRelationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    date?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    employee?: EmployeeOrderByWithRelationInput
  }

  export type EmployeeAllowedDateWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    employeeId_date?: EmployeeAllowedDateEmployeeIdDateCompoundUniqueInput
    AND?: EmployeeAllowedDateWhereInput | EmployeeAllowedDateWhereInput[]
    OR?: EmployeeAllowedDateWhereInput[]
    NOT?: EmployeeAllowedDateWhereInput | EmployeeAllowedDateWhereInput[]
    employeeId?: StringFilter<"EmployeeAllowedDate"> | string
    date?: DateTimeFilter<"EmployeeAllowedDate"> | Date | string
    createdAt?: DateTimeFilter<"EmployeeAllowedDate"> | Date | string
    updatedAt?: DateTimeFilter<"EmployeeAllowedDate"> | Date | string
    employee?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
  }, "id" | "employeeId_date">

  export type EmployeeAllowedDateOrderByWithAggregationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    date?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EmployeeAllowedDateCountOrderByAggregateInput
    _max?: EmployeeAllowedDateMaxOrderByAggregateInput
    _min?: EmployeeAllowedDateMinOrderByAggregateInput
  }

  export type EmployeeAllowedDateScalarWhereWithAggregatesInput = {
    AND?: EmployeeAllowedDateScalarWhereWithAggregatesInput | EmployeeAllowedDateScalarWhereWithAggregatesInput[]
    OR?: EmployeeAllowedDateScalarWhereWithAggregatesInput[]
    NOT?: EmployeeAllowedDateScalarWhereWithAggregatesInput | EmployeeAllowedDateScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EmployeeAllowedDate"> | string
    employeeId?: StringWithAggregatesFilter<"EmployeeAllowedDate"> | string
    date?: DateTimeWithAggregatesFilter<"EmployeeAllowedDate"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"EmployeeAllowedDate"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"EmployeeAllowedDate"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    name?: string | null
    username?: string | null
    email?: string | null
    role: $Enums.Role
    password?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    activities?: ActivityCreateNestedManyWithoutScannerInput
    alerts?: AlertCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    name?: string | null
    username?: string | null
    email?: string | null
    role: $Enums.Role
    password?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    activities?: ActivityUncheckedCreateNestedManyWithoutScannerInput
    alerts?: AlertUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    password?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activities?: ActivityUpdateManyWithoutScannerNestedInput
    alerts?: AlertUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    password?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activities?: ActivityUncheckedUpdateManyWithoutScannerNestedInput
    alerts?: AlertUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    name?: string | null
    username?: string | null
    email?: string | null
    role: $Enums.Role
    password?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    password?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    password?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorCreateInput = {
    id?: string
    name: string
    description?: string | null
    phoneNumber?: string | null
    allowedStaffCount: number
    accessToken?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    employees?: EmployeeCreateNestedManyWithoutVendorInput
    vendorAttachments?: VendorAttachmentCreateNestedManyWithoutVendorInput
    gates?: VendorGateCreateNestedManyWithoutVendorInput
    zones?: VendorZoneCreateNestedManyWithoutVendorInput
  }

  export type VendorUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    phoneNumber?: string | null
    allowedStaffCount: number
    accessToken?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    employees?: EmployeeUncheckedCreateNestedManyWithoutVendorInput
    vendorAttachments?: VendorAttachmentUncheckedCreateNestedManyWithoutVendorInput
    gates?: VendorGateUncheckedCreateNestedManyWithoutVendorInput
    zones?: VendorZoneUncheckedCreateNestedManyWithoutVendorInput
  }

  export type VendorUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    allowedStaffCount?: IntFieldUpdateOperationsInput | number
    accessToken?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employees?: EmployeeUpdateManyWithoutVendorNestedInput
    vendorAttachments?: VendorAttachmentUpdateManyWithoutVendorNestedInput
    gates?: VendorGateUpdateManyWithoutVendorNestedInput
    zones?: VendorZoneUpdateManyWithoutVendorNestedInput
  }

  export type VendorUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    allowedStaffCount?: IntFieldUpdateOperationsInput | number
    accessToken?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employees?: EmployeeUncheckedUpdateManyWithoutVendorNestedInput
    vendorAttachments?: VendorAttachmentUncheckedUpdateManyWithoutVendorNestedInput
    gates?: VendorGateUncheckedUpdateManyWithoutVendorNestedInput
    zones?: VendorZoneUncheckedUpdateManyWithoutVendorNestedInput
  }

  export type VendorCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    phoneNumber?: string | null
    allowedStaffCount: number
    accessToken?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type VendorUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    allowedStaffCount?: IntFieldUpdateOperationsInput | number
    accessToken?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type VendorUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    allowedStaffCount?: IntFieldUpdateOperationsInput | number
    accessToken?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ZoneCreateInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    vendors?: VendorZoneCreateNestedManyWithoutZoneInput
    employees?: EmployeeZoneCreateNestedManyWithoutZoneInput
  }

  export type ZoneUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    vendors?: VendorZoneUncheckedCreateNestedManyWithoutZoneInput
    employees?: EmployeeZoneUncheckedCreateNestedManyWithoutZoneInput
  }

  export type ZoneUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vendors?: VendorZoneUpdateManyWithoutZoneNestedInput
    employees?: EmployeeZoneUpdateManyWithoutZoneNestedInput
  }

  export type ZoneUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vendors?: VendorZoneUncheckedUpdateManyWithoutZoneNestedInput
    employees?: EmployeeZoneUncheckedUpdateManyWithoutZoneNestedInput
  }

  export type ZoneCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type ZoneUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ZoneUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type GateCreateInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    vendors?: VendorGateCreateNestedManyWithoutGateInput
    employees?: EmployeeGateCreateNestedManyWithoutGateInput
    activities?: ActivityCreateNestedManyWithoutGateInput
  }

  export type GateUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    vendors?: VendorGateUncheckedCreateNestedManyWithoutGateInput
    employees?: EmployeeGateUncheckedCreateNestedManyWithoutGateInput
    activities?: ActivityUncheckedCreateNestedManyWithoutGateInput
  }

  export type GateUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vendors?: VendorGateUpdateManyWithoutGateNestedInput
    employees?: EmployeeGateUpdateManyWithoutGateNestedInput
    activities?: ActivityUpdateManyWithoutGateNestedInput
  }

  export type GateUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vendors?: VendorGateUncheckedUpdateManyWithoutGateNestedInput
    employees?: EmployeeGateUncheckedUpdateManyWithoutGateNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutGateNestedInput
  }

  export type GateCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type GateUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type GateUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PermissionCreateInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    employeePermissions?: EmployeePermissionCreateNestedManyWithoutPermissionInput
  }

  export type PermissionUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    employeePermissions?: EmployeePermissionUncheckedCreateNestedManyWithoutPermissionInput
  }

  export type PermissionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employeePermissions?: EmployeePermissionUpdateManyWithoutPermissionNestedInput
  }

  export type PermissionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employeePermissions?: EmployeePermissionUncheckedUpdateManyWithoutPermissionNestedInput
  }

  export type PermissionCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type PermissionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PermissionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EmployeeCreateInput = {
    id?: string
    identifier?: string
    name: string
    job: string
    nationalId: string
    version?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    status?: $Enums.EmployeeStatus
    vendor: VendorCreateNestedOneWithoutEmployeesInput
    gates?: EmployeeGateCreateNestedManyWithoutEmployeeInput
    zones?: EmployeeZoneCreateNestedManyWithoutEmployeeInput
    activities?: ActivityCreateNestedManyWithoutEmployeeInput
    workingHours?: WorkingHoursCreateNestedManyWithoutEmployeeInput
    employeeAttachments?: EmployeeAttachmentCreateNestedManyWithoutEmployeeInput
    employeePermissions?: EmployeePermissionCreateNestedManyWithoutEmployeeInput
    alerts?: AlertCreateNestedManyWithoutEmployeeInput
    allowedDates?: EmployeeAllowedDateCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateInput = {
    id?: string
    identifier?: string
    name: string
    job: string
    nationalId: string
    version?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    status?: $Enums.EmployeeStatus
    vendorId: string
    gates?: EmployeeGateUncheckedCreateNestedManyWithoutEmployeeInput
    zones?: EmployeeZoneUncheckedCreateNestedManyWithoutEmployeeInput
    activities?: ActivityUncheckedCreateNestedManyWithoutEmployeeInput
    workingHours?: WorkingHoursUncheckedCreateNestedManyWithoutEmployeeInput
    employeeAttachments?: EmployeeAttachmentUncheckedCreateNestedManyWithoutEmployeeInput
    employeePermissions?: EmployeePermissionUncheckedCreateNestedManyWithoutEmployeeInput
    alerts?: AlertUncheckedCreateNestedManyWithoutEmployeeInput
    allowedDates?: EmployeeAllowedDateUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    job?: StringFieldUpdateOperationsInput | string
    nationalId?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumEmployeeStatusFieldUpdateOperationsInput | $Enums.EmployeeStatus
    vendor?: VendorUpdateOneRequiredWithoutEmployeesNestedInput
    gates?: EmployeeGateUpdateManyWithoutEmployeeNestedInput
    zones?: EmployeeZoneUpdateManyWithoutEmployeeNestedInput
    activities?: ActivityUpdateManyWithoutEmployeeNestedInput
    workingHours?: WorkingHoursUpdateManyWithoutEmployeeNestedInput
    employeeAttachments?: EmployeeAttachmentUpdateManyWithoutEmployeeNestedInput
    employeePermissions?: EmployeePermissionUpdateManyWithoutEmployeeNestedInput
    alerts?: AlertUpdateManyWithoutEmployeeNestedInput
    allowedDates?: EmployeeAllowedDateUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    job?: StringFieldUpdateOperationsInput | string
    nationalId?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumEmployeeStatusFieldUpdateOperationsInput | $Enums.EmployeeStatus
    vendorId?: StringFieldUpdateOperationsInput | string
    gates?: EmployeeGateUncheckedUpdateManyWithoutEmployeeNestedInput
    zones?: EmployeeZoneUncheckedUpdateManyWithoutEmployeeNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutEmployeeNestedInput
    workingHours?: WorkingHoursUncheckedUpdateManyWithoutEmployeeNestedInput
    employeeAttachments?: EmployeeAttachmentUncheckedUpdateManyWithoutEmployeeNestedInput
    employeePermissions?: EmployeePermissionUncheckedUpdateManyWithoutEmployeeNestedInput
    alerts?: AlertUncheckedUpdateManyWithoutEmployeeNestedInput
    allowedDates?: EmployeeAllowedDateUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeCreateManyInput = {
    id?: string
    identifier?: string
    name: string
    job: string
    nationalId: string
    version?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    status?: $Enums.EmployeeStatus
    vendorId: string
  }

  export type EmployeeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    job?: StringFieldUpdateOperationsInput | string
    nationalId?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumEmployeeStatusFieldUpdateOperationsInput | $Enums.EmployeeStatus
  }

  export type EmployeeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    job?: StringFieldUpdateOperationsInput | string
    nationalId?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumEmployeeStatusFieldUpdateOperationsInput | $Enums.EmployeeStatus
    vendorId?: StringFieldUpdateOperationsInput | string
  }

  export type WorkingHoursCreateInput = {
    id?: string
    dayOfWeek: $Enums.DayOfWeek
    startTime: string
    endTime: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    employee: EmployeeCreateNestedOneWithoutWorkingHoursInput
  }

  export type WorkingHoursUncheckedCreateInput = {
    id?: string
    dayOfWeek: $Enums.DayOfWeek
    startTime: string
    endTime: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    employeeId: string
  }

  export type WorkingHoursUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: EnumDayOfWeekFieldUpdateOperationsInput | $Enums.DayOfWeek
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: EmployeeUpdateOneRequiredWithoutWorkingHoursNestedInput
  }

  export type WorkingHoursUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: EnumDayOfWeekFieldUpdateOperationsInput | $Enums.DayOfWeek
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employeeId?: StringFieldUpdateOperationsInput | string
  }

  export type WorkingHoursCreateManyInput = {
    id?: string
    dayOfWeek: $Enums.DayOfWeek
    startTime: string
    endTime: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    employeeId: string
  }

  export type WorkingHoursUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: EnumDayOfWeekFieldUpdateOperationsInput | $Enums.DayOfWeek
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkingHoursUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: EnumDayOfWeekFieldUpdateOperationsInput | $Enums.DayOfWeek
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employeeId?: StringFieldUpdateOperationsInput | string
  }

  export type AlertCreateInput = {
    id?: string
    text: string
    severity?: string
    isResolved?: boolean
    resolvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    employee?: EmployeeCreateNestedOneWithoutAlertsInput
    user?: UserCreateNestedOneWithoutAlertsInput
    activity?: ActivityCreateNestedOneWithoutAlertsInput
  }

  export type AlertUncheckedCreateInput = {
    id?: string
    text: string
    severity?: string
    isResolved?: boolean
    resolvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    employeeId?: string | null
    userId?: string | null
    activityId?: string | null
  }

  export type AlertUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    isResolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: EmployeeUpdateOneWithoutAlertsNestedInput
    user?: UserUpdateOneWithoutAlertsNestedInput
    activity?: ActivityUpdateOneWithoutAlertsNestedInput
  }

  export type AlertUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    isResolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    activityId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AlertCreateManyInput = {
    id?: string
    text: string
    severity?: string
    isResolved?: boolean
    resolvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    employeeId?: string | null
    userId?: string | null
    activityId?: string | null
  }

  export type AlertUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    isResolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AlertUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    isResolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    activityId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ActivityCreateInput = {
    id?: string
    type?: $Enums.ActivityType
    status: $Enums.AccessStatus
    denialReason?: string | null
    scannedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    employee: EmployeeCreateNestedOneWithoutActivitiesInput
    scanner?: UserCreateNestedOneWithoutActivitiesInput
    gate?: GateCreateNestedOneWithoutActivitiesInput
    alerts?: AlertCreateNestedManyWithoutActivityInput
  }

  export type ActivityUncheckedCreateInput = {
    id?: string
    type?: $Enums.ActivityType
    status: $Enums.AccessStatus
    denialReason?: string | null
    scannedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    employeeId: string
    scannerId?: string | null
    gateId?: string | null
    alerts?: AlertUncheckedCreateNestedManyWithoutActivityInput
  }

  export type ActivityUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    status?: EnumAccessStatusFieldUpdateOperationsInput | $Enums.AccessStatus
    denialReason?: NullableStringFieldUpdateOperationsInput | string | null
    scannedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: EmployeeUpdateOneRequiredWithoutActivitiesNestedInput
    scanner?: UserUpdateOneWithoutActivitiesNestedInput
    gate?: GateUpdateOneWithoutActivitiesNestedInput
    alerts?: AlertUpdateManyWithoutActivityNestedInput
  }

  export type ActivityUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    status?: EnumAccessStatusFieldUpdateOperationsInput | $Enums.AccessStatus
    denialReason?: NullableStringFieldUpdateOperationsInput | string | null
    scannedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employeeId?: StringFieldUpdateOperationsInput | string
    scannerId?: NullableStringFieldUpdateOperationsInput | string | null
    gateId?: NullableStringFieldUpdateOperationsInput | string | null
    alerts?: AlertUncheckedUpdateManyWithoutActivityNestedInput
  }

  export type ActivityCreateManyInput = {
    id?: string
    type?: $Enums.ActivityType
    status: $Enums.AccessStatus
    denialReason?: string | null
    scannedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    employeeId: string
    scannerId?: string | null
    gateId?: string | null
  }

  export type ActivityUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    status?: EnumAccessStatusFieldUpdateOperationsInput | $Enums.AccessStatus
    denialReason?: NullableStringFieldUpdateOperationsInput | string | null
    scannedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    status?: EnumAccessStatusFieldUpdateOperationsInput | $Enums.AccessStatus
    denialReason?: NullableStringFieldUpdateOperationsInput | string | null
    scannedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employeeId?: StringFieldUpdateOperationsInput | string
    scannerId?: NullableStringFieldUpdateOperationsInput | string | null
    gateId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AttachmentCreateInput = {
    id?: string
    url: string
    key?: string | null
    name?: string | null
    mimeType?: string | null
    size?: number | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    vendorAttachments?: VendorAttachmentCreateNestedManyWithoutAttachmentInput
    employeeAttachments?: EmployeeAttachmentCreateNestedManyWithoutAttachmentInput
  }

  export type AttachmentUncheckedCreateInput = {
    id?: string
    url: string
    key?: string | null
    name?: string | null
    mimeType?: string | null
    size?: number | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    vendorAttachments?: VendorAttachmentUncheckedCreateNestedManyWithoutAttachmentInput
    employeeAttachments?: EmployeeAttachmentUncheckedCreateNestedManyWithoutAttachmentInput
  }

  export type AttachmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    key?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vendorAttachments?: VendorAttachmentUpdateManyWithoutAttachmentNestedInput
    employeeAttachments?: EmployeeAttachmentUpdateManyWithoutAttachmentNestedInput
  }

  export type AttachmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    key?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vendorAttachments?: VendorAttachmentUncheckedUpdateManyWithoutAttachmentNestedInput
    employeeAttachments?: EmployeeAttachmentUncheckedUpdateManyWithoutAttachmentNestedInput
  }

  export type AttachmentCreateManyInput = {
    id?: string
    url: string
    key?: string | null
    name?: string | null
    mimeType?: string | null
    size?: number | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AttachmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    key?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttachmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    key?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorAttachmentCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    vendor: VendorCreateNestedOneWithoutVendorAttachmentsInput
    attachment: AttachmentCreateNestedOneWithoutVendorAttachmentsInput
  }

  export type VendorAttachmentUncheckedCreateInput = {
    id?: string
    vendorId: string
    attachmentId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VendorAttachmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vendor?: VendorUpdateOneRequiredWithoutVendorAttachmentsNestedInput
    attachment?: AttachmentUpdateOneRequiredWithoutVendorAttachmentsNestedInput
  }

  export type VendorAttachmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendorId?: StringFieldUpdateOperationsInput | string
    attachmentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorAttachmentCreateManyInput = {
    id?: string
    vendorId: string
    attachmentId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VendorAttachmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorAttachmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendorId?: StringFieldUpdateOperationsInput | string
    attachmentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeAttachmentCreateInput = {
    id?: string
    type: $Enums.EmployeeAttachmentType
    createdAt?: Date | string
    updatedAt?: Date | string
    employee: EmployeeCreateNestedOneWithoutEmployeeAttachmentsInput
    attachment: AttachmentCreateNestedOneWithoutEmployeeAttachmentsInput
  }

  export type EmployeeAttachmentUncheckedCreateInput = {
    id?: string
    type: $Enums.EmployeeAttachmentType
    employeeId: string
    attachmentId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmployeeAttachmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumEmployeeAttachmentTypeFieldUpdateOperationsInput | $Enums.EmployeeAttachmentType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: EmployeeUpdateOneRequiredWithoutEmployeeAttachmentsNestedInput
    attachment?: AttachmentUpdateOneRequiredWithoutEmployeeAttachmentsNestedInput
  }

  export type EmployeeAttachmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumEmployeeAttachmentTypeFieldUpdateOperationsInput | $Enums.EmployeeAttachmentType
    employeeId?: StringFieldUpdateOperationsInput | string
    attachmentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeAttachmentCreateManyInput = {
    id?: string
    type: $Enums.EmployeeAttachmentType
    employeeId: string
    attachmentId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmployeeAttachmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumEmployeeAttachmentTypeFieldUpdateOperationsInput | $Enums.EmployeeAttachmentType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeAttachmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumEmployeeAttachmentTypeFieldUpdateOperationsInput | $Enums.EmployeeAttachmentType
    employeeId?: StringFieldUpdateOperationsInput | string
    attachmentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeePermissionCreateInput = {
    id?: string
    grantedAt?: Date | string
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    employee: EmployeeCreateNestedOneWithoutEmployeePermissionsInput
    permission: PermissionCreateNestedOneWithoutEmployeePermissionsInput
  }

  export type EmployeePermissionUncheckedCreateInput = {
    id?: string
    employeeId: string
    permissionId: string
    grantedAt?: Date | string
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmployeePermissionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: EmployeeUpdateOneRequiredWithoutEmployeePermissionsNestedInput
    permission?: PermissionUpdateOneRequiredWithoutEmployeePermissionsNestedInput
  }

  export type EmployeePermissionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    permissionId?: StringFieldUpdateOperationsInput | string
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeePermissionCreateManyInput = {
    id?: string
    employeeId: string
    permissionId: string
    grantedAt?: Date | string
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmployeePermissionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeePermissionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    permissionId?: StringFieldUpdateOperationsInput | string
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorGateCreateInput = {
    id?: string
    createdAt?: Date | string
    vendor: VendorCreateNestedOneWithoutGatesInput
    gate: GateCreateNestedOneWithoutVendorsInput
  }

  export type VendorGateUncheckedCreateInput = {
    id?: string
    vendorId: string
    gateId: string
    createdAt?: Date | string
  }

  export type VendorGateUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vendor?: VendorUpdateOneRequiredWithoutGatesNestedInput
    gate?: GateUpdateOneRequiredWithoutVendorsNestedInput
  }

  export type VendorGateUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendorId?: StringFieldUpdateOperationsInput | string
    gateId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorGateCreateManyInput = {
    id?: string
    vendorId: string
    gateId: string
    createdAt?: Date | string
  }

  export type VendorGateUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorGateUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendorId?: StringFieldUpdateOperationsInput | string
    gateId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorZoneCreateInput = {
    id?: string
    createdAt?: Date | string
    vendor: VendorCreateNestedOneWithoutZonesInput
    zone: ZoneCreateNestedOneWithoutVendorsInput
  }

  export type VendorZoneUncheckedCreateInput = {
    id?: string
    vendorId: string
    zoneId: string
    createdAt?: Date | string
  }

  export type VendorZoneUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vendor?: VendorUpdateOneRequiredWithoutZonesNestedInput
    zone?: ZoneUpdateOneRequiredWithoutVendorsNestedInput
  }

  export type VendorZoneUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendorId?: StringFieldUpdateOperationsInput | string
    zoneId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorZoneCreateManyInput = {
    id?: string
    vendorId: string
    zoneId: string
    createdAt?: Date | string
  }

  export type VendorZoneUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorZoneUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendorId?: StringFieldUpdateOperationsInput | string
    zoneId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeGateCreateInput = {
    id?: string
    createdAt?: Date | string
    employee: EmployeeCreateNestedOneWithoutGatesInput
    gate: GateCreateNestedOneWithoutEmployeesInput
  }

  export type EmployeeGateUncheckedCreateInput = {
    id?: string
    employeeId: string
    gateId: string
    createdAt?: Date | string
  }

  export type EmployeeGateUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: EmployeeUpdateOneRequiredWithoutGatesNestedInput
    gate?: GateUpdateOneRequiredWithoutEmployeesNestedInput
  }

  export type EmployeeGateUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    gateId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeGateCreateManyInput = {
    id?: string
    employeeId: string
    gateId: string
    createdAt?: Date | string
  }

  export type EmployeeGateUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeGateUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    gateId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeZoneCreateInput = {
    id?: string
    createdAt?: Date | string
    employee: EmployeeCreateNestedOneWithoutZonesInput
    zone: ZoneCreateNestedOneWithoutEmployeesInput
  }

  export type EmployeeZoneUncheckedCreateInput = {
    id?: string
    employeeId: string
    zoneId: string
    createdAt?: Date | string
  }

  export type EmployeeZoneUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: EmployeeUpdateOneRequiredWithoutZonesNestedInput
    zone?: ZoneUpdateOneRequiredWithoutEmployeesNestedInput
  }

  export type EmployeeZoneUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    zoneId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeZoneCreateManyInput = {
    id?: string
    employeeId: string
    zoneId: string
    createdAt?: Date | string
  }

  export type EmployeeZoneUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeZoneUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    zoneId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeAllowedDateCreateInput = {
    id?: string
    date: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    employee: EmployeeCreateNestedOneWithoutAllowedDatesInput
  }

  export type EmployeeAllowedDateUncheckedCreateInput = {
    id?: string
    employeeId: string
    date: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmployeeAllowedDateUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: EmployeeUpdateOneRequiredWithoutAllowedDatesNestedInput
  }

  export type EmployeeAllowedDateUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeAllowedDateCreateManyInput = {
    id?: string
    employeeId: string
    date: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmployeeAllowedDateUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeAllowedDateUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type EnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type ActivityListRelationFilter = {
    every?: ActivityWhereInput
    some?: ActivityWhereInput
    none?: ActivityWhereInput
  }

  export type AlertListRelationFilter = {
    every?: AlertWhereInput
    some?: AlertWhereInput
    none?: AlertWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type ActivityOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AlertOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    username?: SortOrder
    email?: SortOrder
    role?: SortOrder
    password?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    username?: SortOrder
    email?: SortOrder
    role?: SortOrder
    password?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    username?: SortOrder
    email?: SortOrder
    role?: SortOrder
    password?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type EnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type EmployeeListRelationFilter = {
    every?: EmployeeWhereInput
    some?: EmployeeWhereInput
    none?: EmployeeWhereInput
  }

  export type VendorAttachmentListRelationFilter = {
    every?: VendorAttachmentWhereInput
    some?: VendorAttachmentWhereInput
    none?: VendorAttachmentWhereInput
  }

  export type VendorGateListRelationFilter = {
    every?: VendorGateWhereInput
    some?: VendorGateWhereInput
    none?: VendorGateWhereInput
  }

  export type VendorZoneListRelationFilter = {
    every?: VendorZoneWhereInput
    some?: VendorZoneWhereInput
    none?: VendorZoneWhereInput
  }

  export type EmployeeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VendorAttachmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VendorGateOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VendorZoneOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VendorCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    phoneNumber?: SortOrder
    allowedStaffCount?: SortOrder
    accessToken?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type VendorAvgOrderByAggregateInput = {
    allowedStaffCount?: SortOrder
  }

  export type VendorMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    phoneNumber?: SortOrder
    allowedStaffCount?: SortOrder
    accessToken?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type VendorMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    phoneNumber?: SortOrder
    allowedStaffCount?: SortOrder
    accessToken?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type VendorSumOrderByAggregateInput = {
    allowedStaffCount?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type EmployeeZoneListRelationFilter = {
    every?: EmployeeZoneWhereInput
    some?: EmployeeZoneWhereInput
    none?: EmployeeZoneWhereInput
  }

  export type EmployeeZoneOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ZoneCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type ZoneMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type ZoneMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type EmployeeGateListRelationFilter = {
    every?: EmployeeGateWhereInput
    some?: EmployeeGateWhereInput
    none?: EmployeeGateWhereInput
  }

  export type EmployeeGateOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GateCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type GateMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type GateMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type EmployeePermissionListRelationFilter = {
    every?: EmployeePermissionWhereInput
    some?: EmployeePermissionWhereInput
    none?: EmployeePermissionWhereInput
  }

  export type EmployeePermissionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PermissionCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type PermissionMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type PermissionMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type EnumEmployeeStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.EmployeeStatus | EnumEmployeeStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EmployeeStatus[] | ListEnumEmployeeStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.EmployeeStatus[] | ListEnumEmployeeStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumEmployeeStatusFilter<$PrismaModel> | $Enums.EmployeeStatus
  }

  export type VendorScalarRelationFilter = {
    is?: VendorWhereInput
    isNot?: VendorWhereInput
  }

  export type WorkingHoursListRelationFilter = {
    every?: WorkingHoursWhereInput
    some?: WorkingHoursWhereInput
    none?: WorkingHoursWhereInput
  }

  export type EmployeeAttachmentListRelationFilter = {
    every?: EmployeeAttachmentWhereInput
    some?: EmployeeAttachmentWhereInput
    none?: EmployeeAttachmentWhereInput
  }

  export type EmployeeAllowedDateListRelationFilter = {
    every?: EmployeeAllowedDateWhereInput
    some?: EmployeeAllowedDateWhereInput
    none?: EmployeeAllowedDateWhereInput
  }

  export type WorkingHoursOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EmployeeAttachmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EmployeeAllowedDateOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EmployeeIdentifierDeletedAtCompoundUniqueInput = {
    identifier: string
    deletedAt: Date | string
  }

  export type EmployeeCountOrderByAggregateInput = {
    id?: SortOrder
    identifier?: SortOrder
    name?: SortOrder
    job?: SortOrder
    nationalId?: SortOrder
    version?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
    status?: SortOrder
    vendorId?: SortOrder
  }

  export type EmployeeAvgOrderByAggregateInput = {
    version?: SortOrder
  }

  export type EmployeeMaxOrderByAggregateInput = {
    id?: SortOrder
    identifier?: SortOrder
    name?: SortOrder
    job?: SortOrder
    nationalId?: SortOrder
    version?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
    status?: SortOrder
    vendorId?: SortOrder
  }

  export type EmployeeMinOrderByAggregateInput = {
    id?: SortOrder
    identifier?: SortOrder
    name?: SortOrder
    job?: SortOrder
    nationalId?: SortOrder
    version?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
    status?: SortOrder
    vendorId?: SortOrder
  }

  export type EmployeeSumOrderByAggregateInput = {
    version?: SortOrder
  }

  export type EnumEmployeeStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EmployeeStatus | EnumEmployeeStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EmployeeStatus[] | ListEnumEmployeeStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.EmployeeStatus[] | ListEnumEmployeeStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumEmployeeStatusWithAggregatesFilter<$PrismaModel> | $Enums.EmployeeStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEmployeeStatusFilter<$PrismaModel>
    _max?: NestedEnumEmployeeStatusFilter<$PrismaModel>
  }

  export type EnumDayOfWeekFilter<$PrismaModel = never> = {
    equals?: $Enums.DayOfWeek | EnumDayOfWeekFieldRefInput<$PrismaModel>
    in?: $Enums.DayOfWeek[] | ListEnumDayOfWeekFieldRefInput<$PrismaModel>
    notIn?: $Enums.DayOfWeek[] | ListEnumDayOfWeekFieldRefInput<$PrismaModel>
    not?: NestedEnumDayOfWeekFilter<$PrismaModel> | $Enums.DayOfWeek
  }

  export type EmployeeScalarRelationFilter = {
    is?: EmployeeWhereInput
    isNot?: EmployeeWhereInput
  }

  export type WorkingHoursEmployeeIdDayOfWeekCompoundUniqueInput = {
    employeeId: string
    dayOfWeek: $Enums.DayOfWeek
  }

  export type WorkingHoursCountOrderByAggregateInput = {
    id?: SortOrder
    dayOfWeek?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    employeeId?: SortOrder
  }

  export type WorkingHoursMaxOrderByAggregateInput = {
    id?: SortOrder
    dayOfWeek?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    employeeId?: SortOrder
  }

  export type WorkingHoursMinOrderByAggregateInput = {
    id?: SortOrder
    dayOfWeek?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    employeeId?: SortOrder
  }

  export type EnumDayOfWeekWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DayOfWeek | EnumDayOfWeekFieldRefInput<$PrismaModel>
    in?: $Enums.DayOfWeek[] | ListEnumDayOfWeekFieldRefInput<$PrismaModel>
    notIn?: $Enums.DayOfWeek[] | ListEnumDayOfWeekFieldRefInput<$PrismaModel>
    not?: NestedEnumDayOfWeekWithAggregatesFilter<$PrismaModel> | $Enums.DayOfWeek
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDayOfWeekFilter<$PrismaModel>
    _max?: NestedEnumDayOfWeekFilter<$PrismaModel>
  }

  export type EmployeeNullableScalarRelationFilter = {
    is?: EmployeeWhereInput | null
    isNot?: EmployeeWhereInput | null
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type ActivityNullableScalarRelationFilter = {
    is?: ActivityWhereInput | null
    isNot?: ActivityWhereInput | null
  }

  export type AlertCountOrderByAggregateInput = {
    id?: SortOrder
    text?: SortOrder
    severity?: SortOrder
    isResolved?: SortOrder
    resolvedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    employeeId?: SortOrder
    userId?: SortOrder
    activityId?: SortOrder
  }

  export type AlertMaxOrderByAggregateInput = {
    id?: SortOrder
    text?: SortOrder
    severity?: SortOrder
    isResolved?: SortOrder
    resolvedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    employeeId?: SortOrder
    userId?: SortOrder
    activityId?: SortOrder
  }

  export type AlertMinOrderByAggregateInput = {
    id?: SortOrder
    text?: SortOrder
    severity?: SortOrder
    isResolved?: SortOrder
    resolvedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    employeeId?: SortOrder
    userId?: SortOrder
    activityId?: SortOrder
  }

  export type EnumActivityTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ActivityType | EnumActivityTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ActivityType[] | ListEnumActivityTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ActivityType[] | ListEnumActivityTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumActivityTypeFilter<$PrismaModel> | $Enums.ActivityType
  }

  export type EnumAccessStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AccessStatus | EnumAccessStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AccessStatus[] | ListEnumAccessStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccessStatus[] | ListEnumAccessStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAccessStatusFilter<$PrismaModel> | $Enums.AccessStatus
  }

  export type GateNullableScalarRelationFilter = {
    is?: GateWhereInput | null
    isNot?: GateWhereInput | null
  }

  export type ActivityCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    status?: SortOrder
    denialReason?: SortOrder
    scannedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    employeeId?: SortOrder
    scannerId?: SortOrder
    gateId?: SortOrder
  }

  export type ActivityMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    status?: SortOrder
    denialReason?: SortOrder
    scannedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    employeeId?: SortOrder
    scannerId?: SortOrder
    gateId?: SortOrder
  }

  export type ActivityMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    status?: SortOrder
    denialReason?: SortOrder
    scannedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    employeeId?: SortOrder
    scannerId?: SortOrder
    gateId?: SortOrder
  }

  export type EnumActivityTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ActivityType | EnumActivityTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ActivityType[] | ListEnumActivityTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ActivityType[] | ListEnumActivityTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumActivityTypeWithAggregatesFilter<$PrismaModel> | $Enums.ActivityType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumActivityTypeFilter<$PrismaModel>
    _max?: NestedEnumActivityTypeFilter<$PrismaModel>
  }

  export type EnumAccessStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AccessStatus | EnumAccessStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AccessStatus[] | ListEnumAccessStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccessStatus[] | ListEnumAccessStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAccessStatusWithAggregatesFilter<$PrismaModel> | $Enums.AccessStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAccessStatusFilter<$PrismaModel>
    _max?: NestedEnumAccessStatusFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type AttachmentCountOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    key?: SortOrder
    name?: SortOrder
    mimeType?: SortOrder
    size?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AttachmentAvgOrderByAggregateInput = {
    size?: SortOrder
  }

  export type AttachmentMaxOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    key?: SortOrder
    name?: SortOrder
    mimeType?: SortOrder
    size?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AttachmentMinOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    key?: SortOrder
    name?: SortOrder
    mimeType?: SortOrder
    size?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AttachmentSumOrderByAggregateInput = {
    size?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type AttachmentScalarRelationFilter = {
    is?: AttachmentWhereInput
    isNot?: AttachmentWhereInput
  }

  export type VendorAttachmentVendorIdAttachmentIdCompoundUniqueInput = {
    vendorId: string
    attachmentId: string
  }

  export type VendorAttachmentCountOrderByAggregateInput = {
    id?: SortOrder
    vendorId?: SortOrder
    attachmentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VendorAttachmentMaxOrderByAggregateInput = {
    id?: SortOrder
    vendorId?: SortOrder
    attachmentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VendorAttachmentMinOrderByAggregateInput = {
    id?: SortOrder
    vendorId?: SortOrder
    attachmentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumEmployeeAttachmentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.EmployeeAttachmentType | EnumEmployeeAttachmentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EmployeeAttachmentType[] | ListEnumEmployeeAttachmentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.EmployeeAttachmentType[] | ListEnumEmployeeAttachmentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumEmployeeAttachmentTypeFilter<$PrismaModel> | $Enums.EmployeeAttachmentType
  }

  export type EmployeeAttachmentEmployeeIdAttachmentIdCompoundUniqueInput = {
    employeeId: string
    attachmentId: string
  }

  export type EmployeeAttachmentCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    employeeId?: SortOrder
    attachmentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmployeeAttachmentMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    employeeId?: SortOrder
    attachmentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmployeeAttachmentMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    employeeId?: SortOrder
    attachmentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumEmployeeAttachmentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EmployeeAttachmentType | EnumEmployeeAttachmentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EmployeeAttachmentType[] | ListEnumEmployeeAttachmentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.EmployeeAttachmentType[] | ListEnumEmployeeAttachmentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumEmployeeAttachmentTypeWithAggregatesFilter<$PrismaModel> | $Enums.EmployeeAttachmentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEmployeeAttachmentTypeFilter<$PrismaModel>
    _max?: NestedEnumEmployeeAttachmentTypeFilter<$PrismaModel>
  }

  export type PermissionScalarRelationFilter = {
    is?: PermissionWhereInput
    isNot?: PermissionWhereInput
  }

  export type EmployeePermissionEmployeeIdPermissionIdCompoundUniqueInput = {
    employeeId: string
    permissionId: string
  }

  export type EmployeePermissionCountOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    permissionId?: SortOrder
    grantedAt?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmployeePermissionMaxOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    permissionId?: SortOrder
    grantedAt?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmployeePermissionMinOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    permissionId?: SortOrder
    grantedAt?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GateScalarRelationFilter = {
    is?: GateWhereInput
    isNot?: GateWhereInput
  }

  export type VendorGateVendorIdGateIdCompoundUniqueInput = {
    vendorId: string
    gateId: string
  }

  export type VendorGateCountOrderByAggregateInput = {
    id?: SortOrder
    vendorId?: SortOrder
    gateId?: SortOrder
    createdAt?: SortOrder
  }

  export type VendorGateMaxOrderByAggregateInput = {
    id?: SortOrder
    vendorId?: SortOrder
    gateId?: SortOrder
    createdAt?: SortOrder
  }

  export type VendorGateMinOrderByAggregateInput = {
    id?: SortOrder
    vendorId?: SortOrder
    gateId?: SortOrder
    createdAt?: SortOrder
  }

  export type ZoneScalarRelationFilter = {
    is?: ZoneWhereInput
    isNot?: ZoneWhereInput
  }

  export type VendorZoneVendorIdZoneIdCompoundUniqueInput = {
    vendorId: string
    zoneId: string
  }

  export type VendorZoneCountOrderByAggregateInput = {
    id?: SortOrder
    vendorId?: SortOrder
    zoneId?: SortOrder
    createdAt?: SortOrder
  }

  export type VendorZoneMaxOrderByAggregateInput = {
    id?: SortOrder
    vendorId?: SortOrder
    zoneId?: SortOrder
    createdAt?: SortOrder
  }

  export type VendorZoneMinOrderByAggregateInput = {
    id?: SortOrder
    vendorId?: SortOrder
    zoneId?: SortOrder
    createdAt?: SortOrder
  }

  export type EmployeeGateEmployeeIdGateIdCompoundUniqueInput = {
    employeeId: string
    gateId: string
  }

  export type EmployeeGateCountOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    gateId?: SortOrder
    createdAt?: SortOrder
  }

  export type EmployeeGateMaxOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    gateId?: SortOrder
    createdAt?: SortOrder
  }

  export type EmployeeGateMinOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    gateId?: SortOrder
    createdAt?: SortOrder
  }

  export type EmployeeZoneEmployeeIdZoneIdCompoundUniqueInput = {
    employeeId: string
    zoneId: string
  }

  export type EmployeeZoneCountOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    zoneId?: SortOrder
    createdAt?: SortOrder
  }

  export type EmployeeZoneMaxOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    zoneId?: SortOrder
    createdAt?: SortOrder
  }

  export type EmployeeZoneMinOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    zoneId?: SortOrder
    createdAt?: SortOrder
  }

  export type EmployeeAllowedDateEmployeeIdDateCompoundUniqueInput = {
    employeeId: string
    date: Date | string
  }

  export type EmployeeAllowedDateCountOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    date?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmployeeAllowedDateMaxOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    date?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmployeeAllowedDateMinOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    date?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ActivityCreateNestedManyWithoutScannerInput = {
    create?: XOR<ActivityCreateWithoutScannerInput, ActivityUncheckedCreateWithoutScannerInput> | ActivityCreateWithoutScannerInput[] | ActivityUncheckedCreateWithoutScannerInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutScannerInput | ActivityCreateOrConnectWithoutScannerInput[]
    createMany?: ActivityCreateManyScannerInputEnvelope
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
  }

  export type AlertCreateNestedManyWithoutUserInput = {
    create?: XOR<AlertCreateWithoutUserInput, AlertUncheckedCreateWithoutUserInput> | AlertCreateWithoutUserInput[] | AlertUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AlertCreateOrConnectWithoutUserInput | AlertCreateOrConnectWithoutUserInput[]
    createMany?: AlertCreateManyUserInputEnvelope
    connect?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
  }

  export type ActivityUncheckedCreateNestedManyWithoutScannerInput = {
    create?: XOR<ActivityCreateWithoutScannerInput, ActivityUncheckedCreateWithoutScannerInput> | ActivityCreateWithoutScannerInput[] | ActivityUncheckedCreateWithoutScannerInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutScannerInput | ActivityCreateOrConnectWithoutScannerInput[]
    createMany?: ActivityCreateManyScannerInputEnvelope
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
  }

  export type AlertUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AlertCreateWithoutUserInput, AlertUncheckedCreateWithoutUserInput> | AlertCreateWithoutUserInput[] | AlertUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AlertCreateOrConnectWithoutUserInput | AlertCreateOrConnectWithoutUserInput[]
    createMany?: AlertCreateManyUserInputEnvelope
    connect?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type EnumRoleFieldUpdateOperationsInput = {
    set?: $Enums.Role
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type ActivityUpdateManyWithoutScannerNestedInput = {
    create?: XOR<ActivityCreateWithoutScannerInput, ActivityUncheckedCreateWithoutScannerInput> | ActivityCreateWithoutScannerInput[] | ActivityUncheckedCreateWithoutScannerInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutScannerInput | ActivityCreateOrConnectWithoutScannerInput[]
    upsert?: ActivityUpsertWithWhereUniqueWithoutScannerInput | ActivityUpsertWithWhereUniqueWithoutScannerInput[]
    createMany?: ActivityCreateManyScannerInputEnvelope
    set?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    disconnect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    delete?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    update?: ActivityUpdateWithWhereUniqueWithoutScannerInput | ActivityUpdateWithWhereUniqueWithoutScannerInput[]
    updateMany?: ActivityUpdateManyWithWhereWithoutScannerInput | ActivityUpdateManyWithWhereWithoutScannerInput[]
    deleteMany?: ActivityScalarWhereInput | ActivityScalarWhereInput[]
  }

  export type AlertUpdateManyWithoutUserNestedInput = {
    create?: XOR<AlertCreateWithoutUserInput, AlertUncheckedCreateWithoutUserInput> | AlertCreateWithoutUserInput[] | AlertUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AlertCreateOrConnectWithoutUserInput | AlertCreateOrConnectWithoutUserInput[]
    upsert?: AlertUpsertWithWhereUniqueWithoutUserInput | AlertUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AlertCreateManyUserInputEnvelope
    set?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
    disconnect?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
    delete?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
    connect?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
    update?: AlertUpdateWithWhereUniqueWithoutUserInput | AlertUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AlertUpdateManyWithWhereWithoutUserInput | AlertUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AlertScalarWhereInput | AlertScalarWhereInput[]
  }

  export type ActivityUncheckedUpdateManyWithoutScannerNestedInput = {
    create?: XOR<ActivityCreateWithoutScannerInput, ActivityUncheckedCreateWithoutScannerInput> | ActivityCreateWithoutScannerInput[] | ActivityUncheckedCreateWithoutScannerInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutScannerInput | ActivityCreateOrConnectWithoutScannerInput[]
    upsert?: ActivityUpsertWithWhereUniqueWithoutScannerInput | ActivityUpsertWithWhereUniqueWithoutScannerInput[]
    createMany?: ActivityCreateManyScannerInputEnvelope
    set?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    disconnect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    delete?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    update?: ActivityUpdateWithWhereUniqueWithoutScannerInput | ActivityUpdateWithWhereUniqueWithoutScannerInput[]
    updateMany?: ActivityUpdateManyWithWhereWithoutScannerInput | ActivityUpdateManyWithWhereWithoutScannerInput[]
    deleteMany?: ActivityScalarWhereInput | ActivityScalarWhereInput[]
  }

  export type AlertUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AlertCreateWithoutUserInput, AlertUncheckedCreateWithoutUserInput> | AlertCreateWithoutUserInput[] | AlertUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AlertCreateOrConnectWithoutUserInput | AlertCreateOrConnectWithoutUserInput[]
    upsert?: AlertUpsertWithWhereUniqueWithoutUserInput | AlertUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AlertCreateManyUserInputEnvelope
    set?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
    disconnect?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
    delete?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
    connect?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
    update?: AlertUpdateWithWhereUniqueWithoutUserInput | AlertUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AlertUpdateManyWithWhereWithoutUserInput | AlertUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AlertScalarWhereInput | AlertScalarWhereInput[]
  }

  export type EmployeeCreateNestedManyWithoutVendorInput = {
    create?: XOR<EmployeeCreateWithoutVendorInput, EmployeeUncheckedCreateWithoutVendorInput> | EmployeeCreateWithoutVendorInput[] | EmployeeUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutVendorInput | EmployeeCreateOrConnectWithoutVendorInput[]
    createMany?: EmployeeCreateManyVendorInputEnvelope
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
  }

  export type VendorAttachmentCreateNestedManyWithoutVendorInput = {
    create?: XOR<VendorAttachmentCreateWithoutVendorInput, VendorAttachmentUncheckedCreateWithoutVendorInput> | VendorAttachmentCreateWithoutVendorInput[] | VendorAttachmentUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: VendorAttachmentCreateOrConnectWithoutVendorInput | VendorAttachmentCreateOrConnectWithoutVendorInput[]
    createMany?: VendorAttachmentCreateManyVendorInputEnvelope
    connect?: VendorAttachmentWhereUniqueInput | VendorAttachmentWhereUniqueInput[]
  }

  export type VendorGateCreateNestedManyWithoutVendorInput = {
    create?: XOR<VendorGateCreateWithoutVendorInput, VendorGateUncheckedCreateWithoutVendorInput> | VendorGateCreateWithoutVendorInput[] | VendorGateUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: VendorGateCreateOrConnectWithoutVendorInput | VendorGateCreateOrConnectWithoutVendorInput[]
    createMany?: VendorGateCreateManyVendorInputEnvelope
    connect?: VendorGateWhereUniqueInput | VendorGateWhereUniqueInput[]
  }

  export type VendorZoneCreateNestedManyWithoutVendorInput = {
    create?: XOR<VendorZoneCreateWithoutVendorInput, VendorZoneUncheckedCreateWithoutVendorInput> | VendorZoneCreateWithoutVendorInput[] | VendorZoneUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: VendorZoneCreateOrConnectWithoutVendorInput | VendorZoneCreateOrConnectWithoutVendorInput[]
    createMany?: VendorZoneCreateManyVendorInputEnvelope
    connect?: VendorZoneWhereUniqueInput | VendorZoneWhereUniqueInput[]
  }

  export type EmployeeUncheckedCreateNestedManyWithoutVendorInput = {
    create?: XOR<EmployeeCreateWithoutVendorInput, EmployeeUncheckedCreateWithoutVendorInput> | EmployeeCreateWithoutVendorInput[] | EmployeeUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutVendorInput | EmployeeCreateOrConnectWithoutVendorInput[]
    createMany?: EmployeeCreateManyVendorInputEnvelope
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
  }

  export type VendorAttachmentUncheckedCreateNestedManyWithoutVendorInput = {
    create?: XOR<VendorAttachmentCreateWithoutVendorInput, VendorAttachmentUncheckedCreateWithoutVendorInput> | VendorAttachmentCreateWithoutVendorInput[] | VendorAttachmentUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: VendorAttachmentCreateOrConnectWithoutVendorInput | VendorAttachmentCreateOrConnectWithoutVendorInput[]
    createMany?: VendorAttachmentCreateManyVendorInputEnvelope
    connect?: VendorAttachmentWhereUniqueInput | VendorAttachmentWhereUniqueInput[]
  }

  export type VendorGateUncheckedCreateNestedManyWithoutVendorInput = {
    create?: XOR<VendorGateCreateWithoutVendorInput, VendorGateUncheckedCreateWithoutVendorInput> | VendorGateCreateWithoutVendorInput[] | VendorGateUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: VendorGateCreateOrConnectWithoutVendorInput | VendorGateCreateOrConnectWithoutVendorInput[]
    createMany?: VendorGateCreateManyVendorInputEnvelope
    connect?: VendorGateWhereUniqueInput | VendorGateWhereUniqueInput[]
  }

  export type VendorZoneUncheckedCreateNestedManyWithoutVendorInput = {
    create?: XOR<VendorZoneCreateWithoutVendorInput, VendorZoneUncheckedCreateWithoutVendorInput> | VendorZoneCreateWithoutVendorInput[] | VendorZoneUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: VendorZoneCreateOrConnectWithoutVendorInput | VendorZoneCreateOrConnectWithoutVendorInput[]
    createMany?: VendorZoneCreateManyVendorInputEnvelope
    connect?: VendorZoneWhereUniqueInput | VendorZoneWhereUniqueInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type EmployeeUpdateManyWithoutVendorNestedInput = {
    create?: XOR<EmployeeCreateWithoutVendorInput, EmployeeUncheckedCreateWithoutVendorInput> | EmployeeCreateWithoutVendorInput[] | EmployeeUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutVendorInput | EmployeeCreateOrConnectWithoutVendorInput[]
    upsert?: EmployeeUpsertWithWhereUniqueWithoutVendorInput | EmployeeUpsertWithWhereUniqueWithoutVendorInput[]
    createMany?: EmployeeCreateManyVendorInputEnvelope
    set?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    disconnect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    delete?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    update?: EmployeeUpdateWithWhereUniqueWithoutVendorInput | EmployeeUpdateWithWhereUniqueWithoutVendorInput[]
    updateMany?: EmployeeUpdateManyWithWhereWithoutVendorInput | EmployeeUpdateManyWithWhereWithoutVendorInput[]
    deleteMany?: EmployeeScalarWhereInput | EmployeeScalarWhereInput[]
  }

  export type VendorAttachmentUpdateManyWithoutVendorNestedInput = {
    create?: XOR<VendorAttachmentCreateWithoutVendorInput, VendorAttachmentUncheckedCreateWithoutVendorInput> | VendorAttachmentCreateWithoutVendorInput[] | VendorAttachmentUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: VendorAttachmentCreateOrConnectWithoutVendorInput | VendorAttachmentCreateOrConnectWithoutVendorInput[]
    upsert?: VendorAttachmentUpsertWithWhereUniqueWithoutVendorInput | VendorAttachmentUpsertWithWhereUniqueWithoutVendorInput[]
    createMany?: VendorAttachmentCreateManyVendorInputEnvelope
    set?: VendorAttachmentWhereUniqueInput | VendorAttachmentWhereUniqueInput[]
    disconnect?: VendorAttachmentWhereUniqueInput | VendorAttachmentWhereUniqueInput[]
    delete?: VendorAttachmentWhereUniqueInput | VendorAttachmentWhereUniqueInput[]
    connect?: VendorAttachmentWhereUniqueInput | VendorAttachmentWhereUniqueInput[]
    update?: VendorAttachmentUpdateWithWhereUniqueWithoutVendorInput | VendorAttachmentUpdateWithWhereUniqueWithoutVendorInput[]
    updateMany?: VendorAttachmentUpdateManyWithWhereWithoutVendorInput | VendorAttachmentUpdateManyWithWhereWithoutVendorInput[]
    deleteMany?: VendorAttachmentScalarWhereInput | VendorAttachmentScalarWhereInput[]
  }

  export type VendorGateUpdateManyWithoutVendorNestedInput = {
    create?: XOR<VendorGateCreateWithoutVendorInput, VendorGateUncheckedCreateWithoutVendorInput> | VendorGateCreateWithoutVendorInput[] | VendorGateUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: VendorGateCreateOrConnectWithoutVendorInput | VendorGateCreateOrConnectWithoutVendorInput[]
    upsert?: VendorGateUpsertWithWhereUniqueWithoutVendorInput | VendorGateUpsertWithWhereUniqueWithoutVendorInput[]
    createMany?: VendorGateCreateManyVendorInputEnvelope
    set?: VendorGateWhereUniqueInput | VendorGateWhereUniqueInput[]
    disconnect?: VendorGateWhereUniqueInput | VendorGateWhereUniqueInput[]
    delete?: VendorGateWhereUniqueInput | VendorGateWhereUniqueInput[]
    connect?: VendorGateWhereUniqueInput | VendorGateWhereUniqueInput[]
    update?: VendorGateUpdateWithWhereUniqueWithoutVendorInput | VendorGateUpdateWithWhereUniqueWithoutVendorInput[]
    updateMany?: VendorGateUpdateManyWithWhereWithoutVendorInput | VendorGateUpdateManyWithWhereWithoutVendorInput[]
    deleteMany?: VendorGateScalarWhereInput | VendorGateScalarWhereInput[]
  }

  export type VendorZoneUpdateManyWithoutVendorNestedInput = {
    create?: XOR<VendorZoneCreateWithoutVendorInput, VendorZoneUncheckedCreateWithoutVendorInput> | VendorZoneCreateWithoutVendorInput[] | VendorZoneUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: VendorZoneCreateOrConnectWithoutVendorInput | VendorZoneCreateOrConnectWithoutVendorInput[]
    upsert?: VendorZoneUpsertWithWhereUniqueWithoutVendorInput | VendorZoneUpsertWithWhereUniqueWithoutVendorInput[]
    createMany?: VendorZoneCreateManyVendorInputEnvelope
    set?: VendorZoneWhereUniqueInput | VendorZoneWhereUniqueInput[]
    disconnect?: VendorZoneWhereUniqueInput | VendorZoneWhereUniqueInput[]
    delete?: VendorZoneWhereUniqueInput | VendorZoneWhereUniqueInput[]
    connect?: VendorZoneWhereUniqueInput | VendorZoneWhereUniqueInput[]
    update?: VendorZoneUpdateWithWhereUniqueWithoutVendorInput | VendorZoneUpdateWithWhereUniqueWithoutVendorInput[]
    updateMany?: VendorZoneUpdateManyWithWhereWithoutVendorInput | VendorZoneUpdateManyWithWhereWithoutVendorInput[]
    deleteMany?: VendorZoneScalarWhereInput | VendorZoneScalarWhereInput[]
  }

  export type EmployeeUncheckedUpdateManyWithoutVendorNestedInput = {
    create?: XOR<EmployeeCreateWithoutVendorInput, EmployeeUncheckedCreateWithoutVendorInput> | EmployeeCreateWithoutVendorInput[] | EmployeeUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutVendorInput | EmployeeCreateOrConnectWithoutVendorInput[]
    upsert?: EmployeeUpsertWithWhereUniqueWithoutVendorInput | EmployeeUpsertWithWhereUniqueWithoutVendorInput[]
    createMany?: EmployeeCreateManyVendorInputEnvelope
    set?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    disconnect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    delete?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    update?: EmployeeUpdateWithWhereUniqueWithoutVendorInput | EmployeeUpdateWithWhereUniqueWithoutVendorInput[]
    updateMany?: EmployeeUpdateManyWithWhereWithoutVendorInput | EmployeeUpdateManyWithWhereWithoutVendorInput[]
    deleteMany?: EmployeeScalarWhereInput | EmployeeScalarWhereInput[]
  }

  export type VendorAttachmentUncheckedUpdateManyWithoutVendorNestedInput = {
    create?: XOR<VendorAttachmentCreateWithoutVendorInput, VendorAttachmentUncheckedCreateWithoutVendorInput> | VendorAttachmentCreateWithoutVendorInput[] | VendorAttachmentUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: VendorAttachmentCreateOrConnectWithoutVendorInput | VendorAttachmentCreateOrConnectWithoutVendorInput[]
    upsert?: VendorAttachmentUpsertWithWhereUniqueWithoutVendorInput | VendorAttachmentUpsertWithWhereUniqueWithoutVendorInput[]
    createMany?: VendorAttachmentCreateManyVendorInputEnvelope
    set?: VendorAttachmentWhereUniqueInput | VendorAttachmentWhereUniqueInput[]
    disconnect?: VendorAttachmentWhereUniqueInput | VendorAttachmentWhereUniqueInput[]
    delete?: VendorAttachmentWhereUniqueInput | VendorAttachmentWhereUniqueInput[]
    connect?: VendorAttachmentWhereUniqueInput | VendorAttachmentWhereUniqueInput[]
    update?: VendorAttachmentUpdateWithWhereUniqueWithoutVendorInput | VendorAttachmentUpdateWithWhereUniqueWithoutVendorInput[]
    updateMany?: VendorAttachmentUpdateManyWithWhereWithoutVendorInput | VendorAttachmentUpdateManyWithWhereWithoutVendorInput[]
    deleteMany?: VendorAttachmentScalarWhereInput | VendorAttachmentScalarWhereInput[]
  }

  export type VendorGateUncheckedUpdateManyWithoutVendorNestedInput = {
    create?: XOR<VendorGateCreateWithoutVendorInput, VendorGateUncheckedCreateWithoutVendorInput> | VendorGateCreateWithoutVendorInput[] | VendorGateUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: VendorGateCreateOrConnectWithoutVendorInput | VendorGateCreateOrConnectWithoutVendorInput[]
    upsert?: VendorGateUpsertWithWhereUniqueWithoutVendorInput | VendorGateUpsertWithWhereUniqueWithoutVendorInput[]
    createMany?: VendorGateCreateManyVendorInputEnvelope
    set?: VendorGateWhereUniqueInput | VendorGateWhereUniqueInput[]
    disconnect?: VendorGateWhereUniqueInput | VendorGateWhereUniqueInput[]
    delete?: VendorGateWhereUniqueInput | VendorGateWhereUniqueInput[]
    connect?: VendorGateWhereUniqueInput | VendorGateWhereUniqueInput[]
    update?: VendorGateUpdateWithWhereUniqueWithoutVendorInput | VendorGateUpdateWithWhereUniqueWithoutVendorInput[]
    updateMany?: VendorGateUpdateManyWithWhereWithoutVendorInput | VendorGateUpdateManyWithWhereWithoutVendorInput[]
    deleteMany?: VendorGateScalarWhereInput | VendorGateScalarWhereInput[]
  }

  export type VendorZoneUncheckedUpdateManyWithoutVendorNestedInput = {
    create?: XOR<VendorZoneCreateWithoutVendorInput, VendorZoneUncheckedCreateWithoutVendorInput> | VendorZoneCreateWithoutVendorInput[] | VendorZoneUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: VendorZoneCreateOrConnectWithoutVendorInput | VendorZoneCreateOrConnectWithoutVendorInput[]
    upsert?: VendorZoneUpsertWithWhereUniqueWithoutVendorInput | VendorZoneUpsertWithWhereUniqueWithoutVendorInput[]
    createMany?: VendorZoneCreateManyVendorInputEnvelope
    set?: VendorZoneWhereUniqueInput | VendorZoneWhereUniqueInput[]
    disconnect?: VendorZoneWhereUniqueInput | VendorZoneWhereUniqueInput[]
    delete?: VendorZoneWhereUniqueInput | VendorZoneWhereUniqueInput[]
    connect?: VendorZoneWhereUniqueInput | VendorZoneWhereUniqueInput[]
    update?: VendorZoneUpdateWithWhereUniqueWithoutVendorInput | VendorZoneUpdateWithWhereUniqueWithoutVendorInput[]
    updateMany?: VendorZoneUpdateManyWithWhereWithoutVendorInput | VendorZoneUpdateManyWithWhereWithoutVendorInput[]
    deleteMany?: VendorZoneScalarWhereInput | VendorZoneScalarWhereInput[]
  }

  export type VendorZoneCreateNestedManyWithoutZoneInput = {
    create?: XOR<VendorZoneCreateWithoutZoneInput, VendorZoneUncheckedCreateWithoutZoneInput> | VendorZoneCreateWithoutZoneInput[] | VendorZoneUncheckedCreateWithoutZoneInput[]
    connectOrCreate?: VendorZoneCreateOrConnectWithoutZoneInput | VendorZoneCreateOrConnectWithoutZoneInput[]
    createMany?: VendorZoneCreateManyZoneInputEnvelope
    connect?: VendorZoneWhereUniqueInput | VendorZoneWhereUniqueInput[]
  }

  export type EmployeeZoneCreateNestedManyWithoutZoneInput = {
    create?: XOR<EmployeeZoneCreateWithoutZoneInput, EmployeeZoneUncheckedCreateWithoutZoneInput> | EmployeeZoneCreateWithoutZoneInput[] | EmployeeZoneUncheckedCreateWithoutZoneInput[]
    connectOrCreate?: EmployeeZoneCreateOrConnectWithoutZoneInput | EmployeeZoneCreateOrConnectWithoutZoneInput[]
    createMany?: EmployeeZoneCreateManyZoneInputEnvelope
    connect?: EmployeeZoneWhereUniqueInput | EmployeeZoneWhereUniqueInput[]
  }

  export type VendorZoneUncheckedCreateNestedManyWithoutZoneInput = {
    create?: XOR<VendorZoneCreateWithoutZoneInput, VendorZoneUncheckedCreateWithoutZoneInput> | VendorZoneCreateWithoutZoneInput[] | VendorZoneUncheckedCreateWithoutZoneInput[]
    connectOrCreate?: VendorZoneCreateOrConnectWithoutZoneInput | VendorZoneCreateOrConnectWithoutZoneInput[]
    createMany?: VendorZoneCreateManyZoneInputEnvelope
    connect?: VendorZoneWhereUniqueInput | VendorZoneWhereUniqueInput[]
  }

  export type EmployeeZoneUncheckedCreateNestedManyWithoutZoneInput = {
    create?: XOR<EmployeeZoneCreateWithoutZoneInput, EmployeeZoneUncheckedCreateWithoutZoneInput> | EmployeeZoneCreateWithoutZoneInput[] | EmployeeZoneUncheckedCreateWithoutZoneInput[]
    connectOrCreate?: EmployeeZoneCreateOrConnectWithoutZoneInput | EmployeeZoneCreateOrConnectWithoutZoneInput[]
    createMany?: EmployeeZoneCreateManyZoneInputEnvelope
    connect?: EmployeeZoneWhereUniqueInput | EmployeeZoneWhereUniqueInput[]
  }

  export type VendorZoneUpdateManyWithoutZoneNestedInput = {
    create?: XOR<VendorZoneCreateWithoutZoneInput, VendorZoneUncheckedCreateWithoutZoneInput> | VendorZoneCreateWithoutZoneInput[] | VendorZoneUncheckedCreateWithoutZoneInput[]
    connectOrCreate?: VendorZoneCreateOrConnectWithoutZoneInput | VendorZoneCreateOrConnectWithoutZoneInput[]
    upsert?: VendorZoneUpsertWithWhereUniqueWithoutZoneInput | VendorZoneUpsertWithWhereUniqueWithoutZoneInput[]
    createMany?: VendorZoneCreateManyZoneInputEnvelope
    set?: VendorZoneWhereUniqueInput | VendorZoneWhereUniqueInput[]
    disconnect?: VendorZoneWhereUniqueInput | VendorZoneWhereUniqueInput[]
    delete?: VendorZoneWhereUniqueInput | VendorZoneWhereUniqueInput[]
    connect?: VendorZoneWhereUniqueInput | VendorZoneWhereUniqueInput[]
    update?: VendorZoneUpdateWithWhereUniqueWithoutZoneInput | VendorZoneUpdateWithWhereUniqueWithoutZoneInput[]
    updateMany?: VendorZoneUpdateManyWithWhereWithoutZoneInput | VendorZoneUpdateManyWithWhereWithoutZoneInput[]
    deleteMany?: VendorZoneScalarWhereInput | VendorZoneScalarWhereInput[]
  }

  export type EmployeeZoneUpdateManyWithoutZoneNestedInput = {
    create?: XOR<EmployeeZoneCreateWithoutZoneInput, EmployeeZoneUncheckedCreateWithoutZoneInput> | EmployeeZoneCreateWithoutZoneInput[] | EmployeeZoneUncheckedCreateWithoutZoneInput[]
    connectOrCreate?: EmployeeZoneCreateOrConnectWithoutZoneInput | EmployeeZoneCreateOrConnectWithoutZoneInput[]
    upsert?: EmployeeZoneUpsertWithWhereUniqueWithoutZoneInput | EmployeeZoneUpsertWithWhereUniqueWithoutZoneInput[]
    createMany?: EmployeeZoneCreateManyZoneInputEnvelope
    set?: EmployeeZoneWhereUniqueInput | EmployeeZoneWhereUniqueInput[]
    disconnect?: EmployeeZoneWhereUniqueInput | EmployeeZoneWhereUniqueInput[]
    delete?: EmployeeZoneWhereUniqueInput | EmployeeZoneWhereUniqueInput[]
    connect?: EmployeeZoneWhereUniqueInput | EmployeeZoneWhereUniqueInput[]
    update?: EmployeeZoneUpdateWithWhereUniqueWithoutZoneInput | EmployeeZoneUpdateWithWhereUniqueWithoutZoneInput[]
    updateMany?: EmployeeZoneUpdateManyWithWhereWithoutZoneInput | EmployeeZoneUpdateManyWithWhereWithoutZoneInput[]
    deleteMany?: EmployeeZoneScalarWhereInput | EmployeeZoneScalarWhereInput[]
  }

  export type VendorZoneUncheckedUpdateManyWithoutZoneNestedInput = {
    create?: XOR<VendorZoneCreateWithoutZoneInput, VendorZoneUncheckedCreateWithoutZoneInput> | VendorZoneCreateWithoutZoneInput[] | VendorZoneUncheckedCreateWithoutZoneInput[]
    connectOrCreate?: VendorZoneCreateOrConnectWithoutZoneInput | VendorZoneCreateOrConnectWithoutZoneInput[]
    upsert?: VendorZoneUpsertWithWhereUniqueWithoutZoneInput | VendorZoneUpsertWithWhereUniqueWithoutZoneInput[]
    createMany?: VendorZoneCreateManyZoneInputEnvelope
    set?: VendorZoneWhereUniqueInput | VendorZoneWhereUniqueInput[]
    disconnect?: VendorZoneWhereUniqueInput | VendorZoneWhereUniqueInput[]
    delete?: VendorZoneWhereUniqueInput | VendorZoneWhereUniqueInput[]
    connect?: VendorZoneWhereUniqueInput | VendorZoneWhereUniqueInput[]
    update?: VendorZoneUpdateWithWhereUniqueWithoutZoneInput | VendorZoneUpdateWithWhereUniqueWithoutZoneInput[]
    updateMany?: VendorZoneUpdateManyWithWhereWithoutZoneInput | VendorZoneUpdateManyWithWhereWithoutZoneInput[]
    deleteMany?: VendorZoneScalarWhereInput | VendorZoneScalarWhereInput[]
  }

  export type EmployeeZoneUncheckedUpdateManyWithoutZoneNestedInput = {
    create?: XOR<EmployeeZoneCreateWithoutZoneInput, EmployeeZoneUncheckedCreateWithoutZoneInput> | EmployeeZoneCreateWithoutZoneInput[] | EmployeeZoneUncheckedCreateWithoutZoneInput[]
    connectOrCreate?: EmployeeZoneCreateOrConnectWithoutZoneInput | EmployeeZoneCreateOrConnectWithoutZoneInput[]
    upsert?: EmployeeZoneUpsertWithWhereUniqueWithoutZoneInput | EmployeeZoneUpsertWithWhereUniqueWithoutZoneInput[]
    createMany?: EmployeeZoneCreateManyZoneInputEnvelope
    set?: EmployeeZoneWhereUniqueInput | EmployeeZoneWhereUniqueInput[]
    disconnect?: EmployeeZoneWhereUniqueInput | EmployeeZoneWhereUniqueInput[]
    delete?: EmployeeZoneWhereUniqueInput | EmployeeZoneWhereUniqueInput[]
    connect?: EmployeeZoneWhereUniqueInput | EmployeeZoneWhereUniqueInput[]
    update?: EmployeeZoneUpdateWithWhereUniqueWithoutZoneInput | EmployeeZoneUpdateWithWhereUniqueWithoutZoneInput[]
    updateMany?: EmployeeZoneUpdateManyWithWhereWithoutZoneInput | EmployeeZoneUpdateManyWithWhereWithoutZoneInput[]
    deleteMany?: EmployeeZoneScalarWhereInput | EmployeeZoneScalarWhereInput[]
  }

  export type VendorGateCreateNestedManyWithoutGateInput = {
    create?: XOR<VendorGateCreateWithoutGateInput, VendorGateUncheckedCreateWithoutGateInput> | VendorGateCreateWithoutGateInput[] | VendorGateUncheckedCreateWithoutGateInput[]
    connectOrCreate?: VendorGateCreateOrConnectWithoutGateInput | VendorGateCreateOrConnectWithoutGateInput[]
    createMany?: VendorGateCreateManyGateInputEnvelope
    connect?: VendorGateWhereUniqueInput | VendorGateWhereUniqueInput[]
  }

  export type EmployeeGateCreateNestedManyWithoutGateInput = {
    create?: XOR<EmployeeGateCreateWithoutGateInput, EmployeeGateUncheckedCreateWithoutGateInput> | EmployeeGateCreateWithoutGateInput[] | EmployeeGateUncheckedCreateWithoutGateInput[]
    connectOrCreate?: EmployeeGateCreateOrConnectWithoutGateInput | EmployeeGateCreateOrConnectWithoutGateInput[]
    createMany?: EmployeeGateCreateManyGateInputEnvelope
    connect?: EmployeeGateWhereUniqueInput | EmployeeGateWhereUniqueInput[]
  }

  export type ActivityCreateNestedManyWithoutGateInput = {
    create?: XOR<ActivityCreateWithoutGateInput, ActivityUncheckedCreateWithoutGateInput> | ActivityCreateWithoutGateInput[] | ActivityUncheckedCreateWithoutGateInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutGateInput | ActivityCreateOrConnectWithoutGateInput[]
    createMany?: ActivityCreateManyGateInputEnvelope
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
  }

  export type VendorGateUncheckedCreateNestedManyWithoutGateInput = {
    create?: XOR<VendorGateCreateWithoutGateInput, VendorGateUncheckedCreateWithoutGateInput> | VendorGateCreateWithoutGateInput[] | VendorGateUncheckedCreateWithoutGateInput[]
    connectOrCreate?: VendorGateCreateOrConnectWithoutGateInput | VendorGateCreateOrConnectWithoutGateInput[]
    createMany?: VendorGateCreateManyGateInputEnvelope
    connect?: VendorGateWhereUniqueInput | VendorGateWhereUniqueInput[]
  }

  export type EmployeeGateUncheckedCreateNestedManyWithoutGateInput = {
    create?: XOR<EmployeeGateCreateWithoutGateInput, EmployeeGateUncheckedCreateWithoutGateInput> | EmployeeGateCreateWithoutGateInput[] | EmployeeGateUncheckedCreateWithoutGateInput[]
    connectOrCreate?: EmployeeGateCreateOrConnectWithoutGateInput | EmployeeGateCreateOrConnectWithoutGateInput[]
    createMany?: EmployeeGateCreateManyGateInputEnvelope
    connect?: EmployeeGateWhereUniqueInput | EmployeeGateWhereUniqueInput[]
  }

  export type ActivityUncheckedCreateNestedManyWithoutGateInput = {
    create?: XOR<ActivityCreateWithoutGateInput, ActivityUncheckedCreateWithoutGateInput> | ActivityCreateWithoutGateInput[] | ActivityUncheckedCreateWithoutGateInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutGateInput | ActivityCreateOrConnectWithoutGateInput[]
    createMany?: ActivityCreateManyGateInputEnvelope
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
  }

  export type VendorGateUpdateManyWithoutGateNestedInput = {
    create?: XOR<VendorGateCreateWithoutGateInput, VendorGateUncheckedCreateWithoutGateInput> | VendorGateCreateWithoutGateInput[] | VendorGateUncheckedCreateWithoutGateInput[]
    connectOrCreate?: VendorGateCreateOrConnectWithoutGateInput | VendorGateCreateOrConnectWithoutGateInput[]
    upsert?: VendorGateUpsertWithWhereUniqueWithoutGateInput | VendorGateUpsertWithWhereUniqueWithoutGateInput[]
    createMany?: VendorGateCreateManyGateInputEnvelope
    set?: VendorGateWhereUniqueInput | VendorGateWhereUniqueInput[]
    disconnect?: VendorGateWhereUniqueInput | VendorGateWhereUniqueInput[]
    delete?: VendorGateWhereUniqueInput | VendorGateWhereUniqueInput[]
    connect?: VendorGateWhereUniqueInput | VendorGateWhereUniqueInput[]
    update?: VendorGateUpdateWithWhereUniqueWithoutGateInput | VendorGateUpdateWithWhereUniqueWithoutGateInput[]
    updateMany?: VendorGateUpdateManyWithWhereWithoutGateInput | VendorGateUpdateManyWithWhereWithoutGateInput[]
    deleteMany?: VendorGateScalarWhereInput | VendorGateScalarWhereInput[]
  }

  export type EmployeeGateUpdateManyWithoutGateNestedInput = {
    create?: XOR<EmployeeGateCreateWithoutGateInput, EmployeeGateUncheckedCreateWithoutGateInput> | EmployeeGateCreateWithoutGateInput[] | EmployeeGateUncheckedCreateWithoutGateInput[]
    connectOrCreate?: EmployeeGateCreateOrConnectWithoutGateInput | EmployeeGateCreateOrConnectWithoutGateInput[]
    upsert?: EmployeeGateUpsertWithWhereUniqueWithoutGateInput | EmployeeGateUpsertWithWhereUniqueWithoutGateInput[]
    createMany?: EmployeeGateCreateManyGateInputEnvelope
    set?: EmployeeGateWhereUniqueInput | EmployeeGateWhereUniqueInput[]
    disconnect?: EmployeeGateWhereUniqueInput | EmployeeGateWhereUniqueInput[]
    delete?: EmployeeGateWhereUniqueInput | EmployeeGateWhereUniqueInput[]
    connect?: EmployeeGateWhereUniqueInput | EmployeeGateWhereUniqueInput[]
    update?: EmployeeGateUpdateWithWhereUniqueWithoutGateInput | EmployeeGateUpdateWithWhereUniqueWithoutGateInput[]
    updateMany?: EmployeeGateUpdateManyWithWhereWithoutGateInput | EmployeeGateUpdateManyWithWhereWithoutGateInput[]
    deleteMany?: EmployeeGateScalarWhereInput | EmployeeGateScalarWhereInput[]
  }

  export type ActivityUpdateManyWithoutGateNestedInput = {
    create?: XOR<ActivityCreateWithoutGateInput, ActivityUncheckedCreateWithoutGateInput> | ActivityCreateWithoutGateInput[] | ActivityUncheckedCreateWithoutGateInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutGateInput | ActivityCreateOrConnectWithoutGateInput[]
    upsert?: ActivityUpsertWithWhereUniqueWithoutGateInput | ActivityUpsertWithWhereUniqueWithoutGateInput[]
    createMany?: ActivityCreateManyGateInputEnvelope
    set?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    disconnect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    delete?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    update?: ActivityUpdateWithWhereUniqueWithoutGateInput | ActivityUpdateWithWhereUniqueWithoutGateInput[]
    updateMany?: ActivityUpdateManyWithWhereWithoutGateInput | ActivityUpdateManyWithWhereWithoutGateInput[]
    deleteMany?: ActivityScalarWhereInput | ActivityScalarWhereInput[]
  }

  export type VendorGateUncheckedUpdateManyWithoutGateNestedInput = {
    create?: XOR<VendorGateCreateWithoutGateInput, VendorGateUncheckedCreateWithoutGateInput> | VendorGateCreateWithoutGateInput[] | VendorGateUncheckedCreateWithoutGateInput[]
    connectOrCreate?: VendorGateCreateOrConnectWithoutGateInput | VendorGateCreateOrConnectWithoutGateInput[]
    upsert?: VendorGateUpsertWithWhereUniqueWithoutGateInput | VendorGateUpsertWithWhereUniqueWithoutGateInput[]
    createMany?: VendorGateCreateManyGateInputEnvelope
    set?: VendorGateWhereUniqueInput | VendorGateWhereUniqueInput[]
    disconnect?: VendorGateWhereUniqueInput | VendorGateWhereUniqueInput[]
    delete?: VendorGateWhereUniqueInput | VendorGateWhereUniqueInput[]
    connect?: VendorGateWhereUniqueInput | VendorGateWhereUniqueInput[]
    update?: VendorGateUpdateWithWhereUniqueWithoutGateInput | VendorGateUpdateWithWhereUniqueWithoutGateInput[]
    updateMany?: VendorGateUpdateManyWithWhereWithoutGateInput | VendorGateUpdateManyWithWhereWithoutGateInput[]
    deleteMany?: VendorGateScalarWhereInput | VendorGateScalarWhereInput[]
  }

  export type EmployeeGateUncheckedUpdateManyWithoutGateNestedInput = {
    create?: XOR<EmployeeGateCreateWithoutGateInput, EmployeeGateUncheckedCreateWithoutGateInput> | EmployeeGateCreateWithoutGateInput[] | EmployeeGateUncheckedCreateWithoutGateInput[]
    connectOrCreate?: EmployeeGateCreateOrConnectWithoutGateInput | EmployeeGateCreateOrConnectWithoutGateInput[]
    upsert?: EmployeeGateUpsertWithWhereUniqueWithoutGateInput | EmployeeGateUpsertWithWhereUniqueWithoutGateInput[]
    createMany?: EmployeeGateCreateManyGateInputEnvelope
    set?: EmployeeGateWhereUniqueInput | EmployeeGateWhereUniqueInput[]
    disconnect?: EmployeeGateWhereUniqueInput | EmployeeGateWhereUniqueInput[]
    delete?: EmployeeGateWhereUniqueInput | EmployeeGateWhereUniqueInput[]
    connect?: EmployeeGateWhereUniqueInput | EmployeeGateWhereUniqueInput[]
    update?: EmployeeGateUpdateWithWhereUniqueWithoutGateInput | EmployeeGateUpdateWithWhereUniqueWithoutGateInput[]
    updateMany?: EmployeeGateUpdateManyWithWhereWithoutGateInput | EmployeeGateUpdateManyWithWhereWithoutGateInput[]
    deleteMany?: EmployeeGateScalarWhereInput | EmployeeGateScalarWhereInput[]
  }

  export type ActivityUncheckedUpdateManyWithoutGateNestedInput = {
    create?: XOR<ActivityCreateWithoutGateInput, ActivityUncheckedCreateWithoutGateInput> | ActivityCreateWithoutGateInput[] | ActivityUncheckedCreateWithoutGateInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutGateInput | ActivityCreateOrConnectWithoutGateInput[]
    upsert?: ActivityUpsertWithWhereUniqueWithoutGateInput | ActivityUpsertWithWhereUniqueWithoutGateInput[]
    createMany?: ActivityCreateManyGateInputEnvelope
    set?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    disconnect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    delete?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    update?: ActivityUpdateWithWhereUniqueWithoutGateInput | ActivityUpdateWithWhereUniqueWithoutGateInput[]
    updateMany?: ActivityUpdateManyWithWhereWithoutGateInput | ActivityUpdateManyWithWhereWithoutGateInput[]
    deleteMany?: ActivityScalarWhereInput | ActivityScalarWhereInput[]
  }

  export type EmployeePermissionCreateNestedManyWithoutPermissionInput = {
    create?: XOR<EmployeePermissionCreateWithoutPermissionInput, EmployeePermissionUncheckedCreateWithoutPermissionInput> | EmployeePermissionCreateWithoutPermissionInput[] | EmployeePermissionUncheckedCreateWithoutPermissionInput[]
    connectOrCreate?: EmployeePermissionCreateOrConnectWithoutPermissionInput | EmployeePermissionCreateOrConnectWithoutPermissionInput[]
    createMany?: EmployeePermissionCreateManyPermissionInputEnvelope
    connect?: EmployeePermissionWhereUniqueInput | EmployeePermissionWhereUniqueInput[]
  }

  export type EmployeePermissionUncheckedCreateNestedManyWithoutPermissionInput = {
    create?: XOR<EmployeePermissionCreateWithoutPermissionInput, EmployeePermissionUncheckedCreateWithoutPermissionInput> | EmployeePermissionCreateWithoutPermissionInput[] | EmployeePermissionUncheckedCreateWithoutPermissionInput[]
    connectOrCreate?: EmployeePermissionCreateOrConnectWithoutPermissionInput | EmployeePermissionCreateOrConnectWithoutPermissionInput[]
    createMany?: EmployeePermissionCreateManyPermissionInputEnvelope
    connect?: EmployeePermissionWhereUniqueInput | EmployeePermissionWhereUniqueInput[]
  }

  export type EmployeePermissionUpdateManyWithoutPermissionNestedInput = {
    create?: XOR<EmployeePermissionCreateWithoutPermissionInput, EmployeePermissionUncheckedCreateWithoutPermissionInput> | EmployeePermissionCreateWithoutPermissionInput[] | EmployeePermissionUncheckedCreateWithoutPermissionInput[]
    connectOrCreate?: EmployeePermissionCreateOrConnectWithoutPermissionInput | EmployeePermissionCreateOrConnectWithoutPermissionInput[]
    upsert?: EmployeePermissionUpsertWithWhereUniqueWithoutPermissionInput | EmployeePermissionUpsertWithWhereUniqueWithoutPermissionInput[]
    createMany?: EmployeePermissionCreateManyPermissionInputEnvelope
    set?: EmployeePermissionWhereUniqueInput | EmployeePermissionWhereUniqueInput[]
    disconnect?: EmployeePermissionWhereUniqueInput | EmployeePermissionWhereUniqueInput[]
    delete?: EmployeePermissionWhereUniqueInput | EmployeePermissionWhereUniqueInput[]
    connect?: EmployeePermissionWhereUniqueInput | EmployeePermissionWhereUniqueInput[]
    update?: EmployeePermissionUpdateWithWhereUniqueWithoutPermissionInput | EmployeePermissionUpdateWithWhereUniqueWithoutPermissionInput[]
    updateMany?: EmployeePermissionUpdateManyWithWhereWithoutPermissionInput | EmployeePermissionUpdateManyWithWhereWithoutPermissionInput[]
    deleteMany?: EmployeePermissionScalarWhereInput | EmployeePermissionScalarWhereInput[]
  }

  export type EmployeePermissionUncheckedUpdateManyWithoutPermissionNestedInput = {
    create?: XOR<EmployeePermissionCreateWithoutPermissionInput, EmployeePermissionUncheckedCreateWithoutPermissionInput> | EmployeePermissionCreateWithoutPermissionInput[] | EmployeePermissionUncheckedCreateWithoutPermissionInput[]
    connectOrCreate?: EmployeePermissionCreateOrConnectWithoutPermissionInput | EmployeePermissionCreateOrConnectWithoutPermissionInput[]
    upsert?: EmployeePermissionUpsertWithWhereUniqueWithoutPermissionInput | EmployeePermissionUpsertWithWhereUniqueWithoutPermissionInput[]
    createMany?: EmployeePermissionCreateManyPermissionInputEnvelope
    set?: EmployeePermissionWhereUniqueInput | EmployeePermissionWhereUniqueInput[]
    disconnect?: EmployeePermissionWhereUniqueInput | EmployeePermissionWhereUniqueInput[]
    delete?: EmployeePermissionWhereUniqueInput | EmployeePermissionWhereUniqueInput[]
    connect?: EmployeePermissionWhereUniqueInput | EmployeePermissionWhereUniqueInput[]
    update?: EmployeePermissionUpdateWithWhereUniqueWithoutPermissionInput | EmployeePermissionUpdateWithWhereUniqueWithoutPermissionInput[]
    updateMany?: EmployeePermissionUpdateManyWithWhereWithoutPermissionInput | EmployeePermissionUpdateManyWithWhereWithoutPermissionInput[]
    deleteMany?: EmployeePermissionScalarWhereInput | EmployeePermissionScalarWhereInput[]
  }

  export type VendorCreateNestedOneWithoutEmployeesInput = {
    create?: XOR<VendorCreateWithoutEmployeesInput, VendorUncheckedCreateWithoutEmployeesInput>
    connectOrCreate?: VendorCreateOrConnectWithoutEmployeesInput
    connect?: VendorWhereUniqueInput
  }

  export type EmployeeGateCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<EmployeeGateCreateWithoutEmployeeInput, EmployeeGateUncheckedCreateWithoutEmployeeInput> | EmployeeGateCreateWithoutEmployeeInput[] | EmployeeGateUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: EmployeeGateCreateOrConnectWithoutEmployeeInput | EmployeeGateCreateOrConnectWithoutEmployeeInput[]
    createMany?: EmployeeGateCreateManyEmployeeInputEnvelope
    connect?: EmployeeGateWhereUniqueInput | EmployeeGateWhereUniqueInput[]
  }

  export type EmployeeZoneCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<EmployeeZoneCreateWithoutEmployeeInput, EmployeeZoneUncheckedCreateWithoutEmployeeInput> | EmployeeZoneCreateWithoutEmployeeInput[] | EmployeeZoneUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: EmployeeZoneCreateOrConnectWithoutEmployeeInput | EmployeeZoneCreateOrConnectWithoutEmployeeInput[]
    createMany?: EmployeeZoneCreateManyEmployeeInputEnvelope
    connect?: EmployeeZoneWhereUniqueInput | EmployeeZoneWhereUniqueInput[]
  }

  export type ActivityCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<ActivityCreateWithoutEmployeeInput, ActivityUncheckedCreateWithoutEmployeeInput> | ActivityCreateWithoutEmployeeInput[] | ActivityUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutEmployeeInput | ActivityCreateOrConnectWithoutEmployeeInput[]
    createMany?: ActivityCreateManyEmployeeInputEnvelope
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
  }

  export type WorkingHoursCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<WorkingHoursCreateWithoutEmployeeInput, WorkingHoursUncheckedCreateWithoutEmployeeInput> | WorkingHoursCreateWithoutEmployeeInput[] | WorkingHoursUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: WorkingHoursCreateOrConnectWithoutEmployeeInput | WorkingHoursCreateOrConnectWithoutEmployeeInput[]
    createMany?: WorkingHoursCreateManyEmployeeInputEnvelope
    connect?: WorkingHoursWhereUniqueInput | WorkingHoursWhereUniqueInput[]
  }

  export type EmployeeAttachmentCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<EmployeeAttachmentCreateWithoutEmployeeInput, EmployeeAttachmentUncheckedCreateWithoutEmployeeInput> | EmployeeAttachmentCreateWithoutEmployeeInput[] | EmployeeAttachmentUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: EmployeeAttachmentCreateOrConnectWithoutEmployeeInput | EmployeeAttachmentCreateOrConnectWithoutEmployeeInput[]
    createMany?: EmployeeAttachmentCreateManyEmployeeInputEnvelope
    connect?: EmployeeAttachmentWhereUniqueInput | EmployeeAttachmentWhereUniqueInput[]
  }

  export type EmployeePermissionCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<EmployeePermissionCreateWithoutEmployeeInput, EmployeePermissionUncheckedCreateWithoutEmployeeInput> | EmployeePermissionCreateWithoutEmployeeInput[] | EmployeePermissionUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: EmployeePermissionCreateOrConnectWithoutEmployeeInput | EmployeePermissionCreateOrConnectWithoutEmployeeInput[]
    createMany?: EmployeePermissionCreateManyEmployeeInputEnvelope
    connect?: EmployeePermissionWhereUniqueInput | EmployeePermissionWhereUniqueInput[]
  }

  export type AlertCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<AlertCreateWithoutEmployeeInput, AlertUncheckedCreateWithoutEmployeeInput> | AlertCreateWithoutEmployeeInput[] | AlertUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: AlertCreateOrConnectWithoutEmployeeInput | AlertCreateOrConnectWithoutEmployeeInput[]
    createMany?: AlertCreateManyEmployeeInputEnvelope
    connect?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
  }

  export type EmployeeAllowedDateCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<EmployeeAllowedDateCreateWithoutEmployeeInput, EmployeeAllowedDateUncheckedCreateWithoutEmployeeInput> | EmployeeAllowedDateCreateWithoutEmployeeInput[] | EmployeeAllowedDateUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: EmployeeAllowedDateCreateOrConnectWithoutEmployeeInput | EmployeeAllowedDateCreateOrConnectWithoutEmployeeInput[]
    createMany?: EmployeeAllowedDateCreateManyEmployeeInputEnvelope
    connect?: EmployeeAllowedDateWhereUniqueInput | EmployeeAllowedDateWhereUniqueInput[]
  }

  export type EmployeeGateUncheckedCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<EmployeeGateCreateWithoutEmployeeInput, EmployeeGateUncheckedCreateWithoutEmployeeInput> | EmployeeGateCreateWithoutEmployeeInput[] | EmployeeGateUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: EmployeeGateCreateOrConnectWithoutEmployeeInput | EmployeeGateCreateOrConnectWithoutEmployeeInput[]
    createMany?: EmployeeGateCreateManyEmployeeInputEnvelope
    connect?: EmployeeGateWhereUniqueInput | EmployeeGateWhereUniqueInput[]
  }

  export type EmployeeZoneUncheckedCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<EmployeeZoneCreateWithoutEmployeeInput, EmployeeZoneUncheckedCreateWithoutEmployeeInput> | EmployeeZoneCreateWithoutEmployeeInput[] | EmployeeZoneUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: EmployeeZoneCreateOrConnectWithoutEmployeeInput | EmployeeZoneCreateOrConnectWithoutEmployeeInput[]
    createMany?: EmployeeZoneCreateManyEmployeeInputEnvelope
    connect?: EmployeeZoneWhereUniqueInput | EmployeeZoneWhereUniqueInput[]
  }

  export type ActivityUncheckedCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<ActivityCreateWithoutEmployeeInput, ActivityUncheckedCreateWithoutEmployeeInput> | ActivityCreateWithoutEmployeeInput[] | ActivityUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutEmployeeInput | ActivityCreateOrConnectWithoutEmployeeInput[]
    createMany?: ActivityCreateManyEmployeeInputEnvelope
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
  }

  export type WorkingHoursUncheckedCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<WorkingHoursCreateWithoutEmployeeInput, WorkingHoursUncheckedCreateWithoutEmployeeInput> | WorkingHoursCreateWithoutEmployeeInput[] | WorkingHoursUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: WorkingHoursCreateOrConnectWithoutEmployeeInput | WorkingHoursCreateOrConnectWithoutEmployeeInput[]
    createMany?: WorkingHoursCreateManyEmployeeInputEnvelope
    connect?: WorkingHoursWhereUniqueInput | WorkingHoursWhereUniqueInput[]
  }

  export type EmployeeAttachmentUncheckedCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<EmployeeAttachmentCreateWithoutEmployeeInput, EmployeeAttachmentUncheckedCreateWithoutEmployeeInput> | EmployeeAttachmentCreateWithoutEmployeeInput[] | EmployeeAttachmentUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: EmployeeAttachmentCreateOrConnectWithoutEmployeeInput | EmployeeAttachmentCreateOrConnectWithoutEmployeeInput[]
    createMany?: EmployeeAttachmentCreateManyEmployeeInputEnvelope
    connect?: EmployeeAttachmentWhereUniqueInput | EmployeeAttachmentWhereUniqueInput[]
  }

  export type EmployeePermissionUncheckedCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<EmployeePermissionCreateWithoutEmployeeInput, EmployeePermissionUncheckedCreateWithoutEmployeeInput> | EmployeePermissionCreateWithoutEmployeeInput[] | EmployeePermissionUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: EmployeePermissionCreateOrConnectWithoutEmployeeInput | EmployeePermissionCreateOrConnectWithoutEmployeeInput[]
    createMany?: EmployeePermissionCreateManyEmployeeInputEnvelope
    connect?: EmployeePermissionWhereUniqueInput | EmployeePermissionWhereUniqueInput[]
  }

  export type AlertUncheckedCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<AlertCreateWithoutEmployeeInput, AlertUncheckedCreateWithoutEmployeeInput> | AlertCreateWithoutEmployeeInput[] | AlertUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: AlertCreateOrConnectWithoutEmployeeInput | AlertCreateOrConnectWithoutEmployeeInput[]
    createMany?: AlertCreateManyEmployeeInputEnvelope
    connect?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
  }

  export type EmployeeAllowedDateUncheckedCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<EmployeeAllowedDateCreateWithoutEmployeeInput, EmployeeAllowedDateUncheckedCreateWithoutEmployeeInput> | EmployeeAllowedDateCreateWithoutEmployeeInput[] | EmployeeAllowedDateUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: EmployeeAllowedDateCreateOrConnectWithoutEmployeeInput | EmployeeAllowedDateCreateOrConnectWithoutEmployeeInput[]
    createMany?: EmployeeAllowedDateCreateManyEmployeeInputEnvelope
    connect?: EmployeeAllowedDateWhereUniqueInput | EmployeeAllowedDateWhereUniqueInput[]
  }

  export type EnumEmployeeStatusFieldUpdateOperationsInput = {
    set?: $Enums.EmployeeStatus
  }

  export type VendorUpdateOneRequiredWithoutEmployeesNestedInput = {
    create?: XOR<VendorCreateWithoutEmployeesInput, VendorUncheckedCreateWithoutEmployeesInput>
    connectOrCreate?: VendorCreateOrConnectWithoutEmployeesInput
    upsert?: VendorUpsertWithoutEmployeesInput
    connect?: VendorWhereUniqueInput
    update?: XOR<XOR<VendorUpdateToOneWithWhereWithoutEmployeesInput, VendorUpdateWithoutEmployeesInput>, VendorUncheckedUpdateWithoutEmployeesInput>
  }

  export type EmployeeGateUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<EmployeeGateCreateWithoutEmployeeInput, EmployeeGateUncheckedCreateWithoutEmployeeInput> | EmployeeGateCreateWithoutEmployeeInput[] | EmployeeGateUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: EmployeeGateCreateOrConnectWithoutEmployeeInput | EmployeeGateCreateOrConnectWithoutEmployeeInput[]
    upsert?: EmployeeGateUpsertWithWhereUniqueWithoutEmployeeInput | EmployeeGateUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: EmployeeGateCreateManyEmployeeInputEnvelope
    set?: EmployeeGateWhereUniqueInput | EmployeeGateWhereUniqueInput[]
    disconnect?: EmployeeGateWhereUniqueInput | EmployeeGateWhereUniqueInput[]
    delete?: EmployeeGateWhereUniqueInput | EmployeeGateWhereUniqueInput[]
    connect?: EmployeeGateWhereUniqueInput | EmployeeGateWhereUniqueInput[]
    update?: EmployeeGateUpdateWithWhereUniqueWithoutEmployeeInput | EmployeeGateUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: EmployeeGateUpdateManyWithWhereWithoutEmployeeInput | EmployeeGateUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: EmployeeGateScalarWhereInput | EmployeeGateScalarWhereInput[]
  }

  export type EmployeeZoneUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<EmployeeZoneCreateWithoutEmployeeInput, EmployeeZoneUncheckedCreateWithoutEmployeeInput> | EmployeeZoneCreateWithoutEmployeeInput[] | EmployeeZoneUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: EmployeeZoneCreateOrConnectWithoutEmployeeInput | EmployeeZoneCreateOrConnectWithoutEmployeeInput[]
    upsert?: EmployeeZoneUpsertWithWhereUniqueWithoutEmployeeInput | EmployeeZoneUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: EmployeeZoneCreateManyEmployeeInputEnvelope
    set?: EmployeeZoneWhereUniqueInput | EmployeeZoneWhereUniqueInput[]
    disconnect?: EmployeeZoneWhereUniqueInput | EmployeeZoneWhereUniqueInput[]
    delete?: EmployeeZoneWhereUniqueInput | EmployeeZoneWhereUniqueInput[]
    connect?: EmployeeZoneWhereUniqueInput | EmployeeZoneWhereUniqueInput[]
    update?: EmployeeZoneUpdateWithWhereUniqueWithoutEmployeeInput | EmployeeZoneUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: EmployeeZoneUpdateManyWithWhereWithoutEmployeeInput | EmployeeZoneUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: EmployeeZoneScalarWhereInput | EmployeeZoneScalarWhereInput[]
  }

  export type ActivityUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<ActivityCreateWithoutEmployeeInput, ActivityUncheckedCreateWithoutEmployeeInput> | ActivityCreateWithoutEmployeeInput[] | ActivityUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutEmployeeInput | ActivityCreateOrConnectWithoutEmployeeInput[]
    upsert?: ActivityUpsertWithWhereUniqueWithoutEmployeeInput | ActivityUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: ActivityCreateManyEmployeeInputEnvelope
    set?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    disconnect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    delete?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    update?: ActivityUpdateWithWhereUniqueWithoutEmployeeInput | ActivityUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: ActivityUpdateManyWithWhereWithoutEmployeeInput | ActivityUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: ActivityScalarWhereInput | ActivityScalarWhereInput[]
  }

  export type WorkingHoursUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<WorkingHoursCreateWithoutEmployeeInput, WorkingHoursUncheckedCreateWithoutEmployeeInput> | WorkingHoursCreateWithoutEmployeeInput[] | WorkingHoursUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: WorkingHoursCreateOrConnectWithoutEmployeeInput | WorkingHoursCreateOrConnectWithoutEmployeeInput[]
    upsert?: WorkingHoursUpsertWithWhereUniqueWithoutEmployeeInput | WorkingHoursUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: WorkingHoursCreateManyEmployeeInputEnvelope
    set?: WorkingHoursWhereUniqueInput | WorkingHoursWhereUniqueInput[]
    disconnect?: WorkingHoursWhereUniqueInput | WorkingHoursWhereUniqueInput[]
    delete?: WorkingHoursWhereUniqueInput | WorkingHoursWhereUniqueInput[]
    connect?: WorkingHoursWhereUniqueInput | WorkingHoursWhereUniqueInput[]
    update?: WorkingHoursUpdateWithWhereUniqueWithoutEmployeeInput | WorkingHoursUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: WorkingHoursUpdateManyWithWhereWithoutEmployeeInput | WorkingHoursUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: WorkingHoursScalarWhereInput | WorkingHoursScalarWhereInput[]
  }

  export type EmployeeAttachmentUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<EmployeeAttachmentCreateWithoutEmployeeInput, EmployeeAttachmentUncheckedCreateWithoutEmployeeInput> | EmployeeAttachmentCreateWithoutEmployeeInput[] | EmployeeAttachmentUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: EmployeeAttachmentCreateOrConnectWithoutEmployeeInput | EmployeeAttachmentCreateOrConnectWithoutEmployeeInput[]
    upsert?: EmployeeAttachmentUpsertWithWhereUniqueWithoutEmployeeInput | EmployeeAttachmentUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: EmployeeAttachmentCreateManyEmployeeInputEnvelope
    set?: EmployeeAttachmentWhereUniqueInput | EmployeeAttachmentWhereUniqueInput[]
    disconnect?: EmployeeAttachmentWhereUniqueInput | EmployeeAttachmentWhereUniqueInput[]
    delete?: EmployeeAttachmentWhereUniqueInput | EmployeeAttachmentWhereUniqueInput[]
    connect?: EmployeeAttachmentWhereUniqueInput | EmployeeAttachmentWhereUniqueInput[]
    update?: EmployeeAttachmentUpdateWithWhereUniqueWithoutEmployeeInput | EmployeeAttachmentUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: EmployeeAttachmentUpdateManyWithWhereWithoutEmployeeInput | EmployeeAttachmentUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: EmployeeAttachmentScalarWhereInput | EmployeeAttachmentScalarWhereInput[]
  }

  export type EmployeePermissionUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<EmployeePermissionCreateWithoutEmployeeInput, EmployeePermissionUncheckedCreateWithoutEmployeeInput> | EmployeePermissionCreateWithoutEmployeeInput[] | EmployeePermissionUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: EmployeePermissionCreateOrConnectWithoutEmployeeInput | EmployeePermissionCreateOrConnectWithoutEmployeeInput[]
    upsert?: EmployeePermissionUpsertWithWhereUniqueWithoutEmployeeInput | EmployeePermissionUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: EmployeePermissionCreateManyEmployeeInputEnvelope
    set?: EmployeePermissionWhereUniqueInput | EmployeePermissionWhereUniqueInput[]
    disconnect?: EmployeePermissionWhereUniqueInput | EmployeePermissionWhereUniqueInput[]
    delete?: EmployeePermissionWhereUniqueInput | EmployeePermissionWhereUniqueInput[]
    connect?: EmployeePermissionWhereUniqueInput | EmployeePermissionWhereUniqueInput[]
    update?: EmployeePermissionUpdateWithWhereUniqueWithoutEmployeeInput | EmployeePermissionUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: EmployeePermissionUpdateManyWithWhereWithoutEmployeeInput | EmployeePermissionUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: EmployeePermissionScalarWhereInput | EmployeePermissionScalarWhereInput[]
  }

  export type AlertUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<AlertCreateWithoutEmployeeInput, AlertUncheckedCreateWithoutEmployeeInput> | AlertCreateWithoutEmployeeInput[] | AlertUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: AlertCreateOrConnectWithoutEmployeeInput | AlertCreateOrConnectWithoutEmployeeInput[]
    upsert?: AlertUpsertWithWhereUniqueWithoutEmployeeInput | AlertUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: AlertCreateManyEmployeeInputEnvelope
    set?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
    disconnect?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
    delete?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
    connect?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
    update?: AlertUpdateWithWhereUniqueWithoutEmployeeInput | AlertUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: AlertUpdateManyWithWhereWithoutEmployeeInput | AlertUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: AlertScalarWhereInput | AlertScalarWhereInput[]
  }

  export type EmployeeAllowedDateUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<EmployeeAllowedDateCreateWithoutEmployeeInput, EmployeeAllowedDateUncheckedCreateWithoutEmployeeInput> | EmployeeAllowedDateCreateWithoutEmployeeInput[] | EmployeeAllowedDateUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: EmployeeAllowedDateCreateOrConnectWithoutEmployeeInput | EmployeeAllowedDateCreateOrConnectWithoutEmployeeInput[]
    upsert?: EmployeeAllowedDateUpsertWithWhereUniqueWithoutEmployeeInput | EmployeeAllowedDateUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: EmployeeAllowedDateCreateManyEmployeeInputEnvelope
    set?: EmployeeAllowedDateWhereUniqueInput | EmployeeAllowedDateWhereUniqueInput[]
    disconnect?: EmployeeAllowedDateWhereUniqueInput | EmployeeAllowedDateWhereUniqueInput[]
    delete?: EmployeeAllowedDateWhereUniqueInput | EmployeeAllowedDateWhereUniqueInput[]
    connect?: EmployeeAllowedDateWhereUniqueInput | EmployeeAllowedDateWhereUniqueInput[]
    update?: EmployeeAllowedDateUpdateWithWhereUniqueWithoutEmployeeInput | EmployeeAllowedDateUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: EmployeeAllowedDateUpdateManyWithWhereWithoutEmployeeInput | EmployeeAllowedDateUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: EmployeeAllowedDateScalarWhereInput | EmployeeAllowedDateScalarWhereInput[]
  }

  export type EmployeeGateUncheckedUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<EmployeeGateCreateWithoutEmployeeInput, EmployeeGateUncheckedCreateWithoutEmployeeInput> | EmployeeGateCreateWithoutEmployeeInput[] | EmployeeGateUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: EmployeeGateCreateOrConnectWithoutEmployeeInput | EmployeeGateCreateOrConnectWithoutEmployeeInput[]
    upsert?: EmployeeGateUpsertWithWhereUniqueWithoutEmployeeInput | EmployeeGateUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: EmployeeGateCreateManyEmployeeInputEnvelope
    set?: EmployeeGateWhereUniqueInput | EmployeeGateWhereUniqueInput[]
    disconnect?: EmployeeGateWhereUniqueInput | EmployeeGateWhereUniqueInput[]
    delete?: EmployeeGateWhereUniqueInput | EmployeeGateWhereUniqueInput[]
    connect?: EmployeeGateWhereUniqueInput | EmployeeGateWhereUniqueInput[]
    update?: EmployeeGateUpdateWithWhereUniqueWithoutEmployeeInput | EmployeeGateUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: EmployeeGateUpdateManyWithWhereWithoutEmployeeInput | EmployeeGateUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: EmployeeGateScalarWhereInput | EmployeeGateScalarWhereInput[]
  }

  export type EmployeeZoneUncheckedUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<EmployeeZoneCreateWithoutEmployeeInput, EmployeeZoneUncheckedCreateWithoutEmployeeInput> | EmployeeZoneCreateWithoutEmployeeInput[] | EmployeeZoneUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: EmployeeZoneCreateOrConnectWithoutEmployeeInput | EmployeeZoneCreateOrConnectWithoutEmployeeInput[]
    upsert?: EmployeeZoneUpsertWithWhereUniqueWithoutEmployeeInput | EmployeeZoneUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: EmployeeZoneCreateManyEmployeeInputEnvelope
    set?: EmployeeZoneWhereUniqueInput | EmployeeZoneWhereUniqueInput[]
    disconnect?: EmployeeZoneWhereUniqueInput | EmployeeZoneWhereUniqueInput[]
    delete?: EmployeeZoneWhereUniqueInput | EmployeeZoneWhereUniqueInput[]
    connect?: EmployeeZoneWhereUniqueInput | EmployeeZoneWhereUniqueInput[]
    update?: EmployeeZoneUpdateWithWhereUniqueWithoutEmployeeInput | EmployeeZoneUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: EmployeeZoneUpdateManyWithWhereWithoutEmployeeInput | EmployeeZoneUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: EmployeeZoneScalarWhereInput | EmployeeZoneScalarWhereInput[]
  }

  export type ActivityUncheckedUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<ActivityCreateWithoutEmployeeInput, ActivityUncheckedCreateWithoutEmployeeInput> | ActivityCreateWithoutEmployeeInput[] | ActivityUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutEmployeeInput | ActivityCreateOrConnectWithoutEmployeeInput[]
    upsert?: ActivityUpsertWithWhereUniqueWithoutEmployeeInput | ActivityUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: ActivityCreateManyEmployeeInputEnvelope
    set?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    disconnect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    delete?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    update?: ActivityUpdateWithWhereUniqueWithoutEmployeeInput | ActivityUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: ActivityUpdateManyWithWhereWithoutEmployeeInput | ActivityUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: ActivityScalarWhereInput | ActivityScalarWhereInput[]
  }

  export type WorkingHoursUncheckedUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<WorkingHoursCreateWithoutEmployeeInput, WorkingHoursUncheckedCreateWithoutEmployeeInput> | WorkingHoursCreateWithoutEmployeeInput[] | WorkingHoursUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: WorkingHoursCreateOrConnectWithoutEmployeeInput | WorkingHoursCreateOrConnectWithoutEmployeeInput[]
    upsert?: WorkingHoursUpsertWithWhereUniqueWithoutEmployeeInput | WorkingHoursUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: WorkingHoursCreateManyEmployeeInputEnvelope
    set?: WorkingHoursWhereUniqueInput | WorkingHoursWhereUniqueInput[]
    disconnect?: WorkingHoursWhereUniqueInput | WorkingHoursWhereUniqueInput[]
    delete?: WorkingHoursWhereUniqueInput | WorkingHoursWhereUniqueInput[]
    connect?: WorkingHoursWhereUniqueInput | WorkingHoursWhereUniqueInput[]
    update?: WorkingHoursUpdateWithWhereUniqueWithoutEmployeeInput | WorkingHoursUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: WorkingHoursUpdateManyWithWhereWithoutEmployeeInput | WorkingHoursUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: WorkingHoursScalarWhereInput | WorkingHoursScalarWhereInput[]
  }

  export type EmployeeAttachmentUncheckedUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<EmployeeAttachmentCreateWithoutEmployeeInput, EmployeeAttachmentUncheckedCreateWithoutEmployeeInput> | EmployeeAttachmentCreateWithoutEmployeeInput[] | EmployeeAttachmentUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: EmployeeAttachmentCreateOrConnectWithoutEmployeeInput | EmployeeAttachmentCreateOrConnectWithoutEmployeeInput[]
    upsert?: EmployeeAttachmentUpsertWithWhereUniqueWithoutEmployeeInput | EmployeeAttachmentUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: EmployeeAttachmentCreateManyEmployeeInputEnvelope
    set?: EmployeeAttachmentWhereUniqueInput | EmployeeAttachmentWhereUniqueInput[]
    disconnect?: EmployeeAttachmentWhereUniqueInput | EmployeeAttachmentWhereUniqueInput[]
    delete?: EmployeeAttachmentWhereUniqueInput | EmployeeAttachmentWhereUniqueInput[]
    connect?: EmployeeAttachmentWhereUniqueInput | EmployeeAttachmentWhereUniqueInput[]
    update?: EmployeeAttachmentUpdateWithWhereUniqueWithoutEmployeeInput | EmployeeAttachmentUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: EmployeeAttachmentUpdateManyWithWhereWithoutEmployeeInput | EmployeeAttachmentUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: EmployeeAttachmentScalarWhereInput | EmployeeAttachmentScalarWhereInput[]
  }

  export type EmployeePermissionUncheckedUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<EmployeePermissionCreateWithoutEmployeeInput, EmployeePermissionUncheckedCreateWithoutEmployeeInput> | EmployeePermissionCreateWithoutEmployeeInput[] | EmployeePermissionUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: EmployeePermissionCreateOrConnectWithoutEmployeeInput | EmployeePermissionCreateOrConnectWithoutEmployeeInput[]
    upsert?: EmployeePermissionUpsertWithWhereUniqueWithoutEmployeeInput | EmployeePermissionUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: EmployeePermissionCreateManyEmployeeInputEnvelope
    set?: EmployeePermissionWhereUniqueInput | EmployeePermissionWhereUniqueInput[]
    disconnect?: EmployeePermissionWhereUniqueInput | EmployeePermissionWhereUniqueInput[]
    delete?: EmployeePermissionWhereUniqueInput | EmployeePermissionWhereUniqueInput[]
    connect?: EmployeePermissionWhereUniqueInput | EmployeePermissionWhereUniqueInput[]
    update?: EmployeePermissionUpdateWithWhereUniqueWithoutEmployeeInput | EmployeePermissionUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: EmployeePermissionUpdateManyWithWhereWithoutEmployeeInput | EmployeePermissionUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: EmployeePermissionScalarWhereInput | EmployeePermissionScalarWhereInput[]
  }

  export type AlertUncheckedUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<AlertCreateWithoutEmployeeInput, AlertUncheckedCreateWithoutEmployeeInput> | AlertCreateWithoutEmployeeInput[] | AlertUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: AlertCreateOrConnectWithoutEmployeeInput | AlertCreateOrConnectWithoutEmployeeInput[]
    upsert?: AlertUpsertWithWhereUniqueWithoutEmployeeInput | AlertUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: AlertCreateManyEmployeeInputEnvelope
    set?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
    disconnect?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
    delete?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
    connect?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
    update?: AlertUpdateWithWhereUniqueWithoutEmployeeInput | AlertUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: AlertUpdateManyWithWhereWithoutEmployeeInput | AlertUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: AlertScalarWhereInput | AlertScalarWhereInput[]
  }

  export type EmployeeAllowedDateUncheckedUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<EmployeeAllowedDateCreateWithoutEmployeeInput, EmployeeAllowedDateUncheckedCreateWithoutEmployeeInput> | EmployeeAllowedDateCreateWithoutEmployeeInput[] | EmployeeAllowedDateUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: EmployeeAllowedDateCreateOrConnectWithoutEmployeeInput | EmployeeAllowedDateCreateOrConnectWithoutEmployeeInput[]
    upsert?: EmployeeAllowedDateUpsertWithWhereUniqueWithoutEmployeeInput | EmployeeAllowedDateUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: EmployeeAllowedDateCreateManyEmployeeInputEnvelope
    set?: EmployeeAllowedDateWhereUniqueInput | EmployeeAllowedDateWhereUniqueInput[]
    disconnect?: EmployeeAllowedDateWhereUniqueInput | EmployeeAllowedDateWhereUniqueInput[]
    delete?: EmployeeAllowedDateWhereUniqueInput | EmployeeAllowedDateWhereUniqueInput[]
    connect?: EmployeeAllowedDateWhereUniqueInput | EmployeeAllowedDateWhereUniqueInput[]
    update?: EmployeeAllowedDateUpdateWithWhereUniqueWithoutEmployeeInput | EmployeeAllowedDateUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: EmployeeAllowedDateUpdateManyWithWhereWithoutEmployeeInput | EmployeeAllowedDateUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: EmployeeAllowedDateScalarWhereInput | EmployeeAllowedDateScalarWhereInput[]
  }

  export type EmployeeCreateNestedOneWithoutWorkingHoursInput = {
    create?: XOR<EmployeeCreateWithoutWorkingHoursInput, EmployeeUncheckedCreateWithoutWorkingHoursInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutWorkingHoursInput
    connect?: EmployeeWhereUniqueInput
  }

  export type EnumDayOfWeekFieldUpdateOperationsInput = {
    set?: $Enums.DayOfWeek
  }

  export type EmployeeUpdateOneRequiredWithoutWorkingHoursNestedInput = {
    create?: XOR<EmployeeCreateWithoutWorkingHoursInput, EmployeeUncheckedCreateWithoutWorkingHoursInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutWorkingHoursInput
    upsert?: EmployeeUpsertWithoutWorkingHoursInput
    connect?: EmployeeWhereUniqueInput
    update?: XOR<XOR<EmployeeUpdateToOneWithWhereWithoutWorkingHoursInput, EmployeeUpdateWithoutWorkingHoursInput>, EmployeeUncheckedUpdateWithoutWorkingHoursInput>
  }

  export type EmployeeCreateNestedOneWithoutAlertsInput = {
    create?: XOR<EmployeeCreateWithoutAlertsInput, EmployeeUncheckedCreateWithoutAlertsInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutAlertsInput
    connect?: EmployeeWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutAlertsInput = {
    create?: XOR<UserCreateWithoutAlertsInput, UserUncheckedCreateWithoutAlertsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAlertsInput
    connect?: UserWhereUniqueInput
  }

  export type ActivityCreateNestedOneWithoutAlertsInput = {
    create?: XOR<ActivityCreateWithoutAlertsInput, ActivityUncheckedCreateWithoutAlertsInput>
    connectOrCreate?: ActivityCreateOrConnectWithoutAlertsInput
    connect?: ActivityWhereUniqueInput
  }

  export type EmployeeUpdateOneWithoutAlertsNestedInput = {
    create?: XOR<EmployeeCreateWithoutAlertsInput, EmployeeUncheckedCreateWithoutAlertsInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutAlertsInput
    upsert?: EmployeeUpsertWithoutAlertsInput
    disconnect?: EmployeeWhereInput | boolean
    delete?: EmployeeWhereInput | boolean
    connect?: EmployeeWhereUniqueInput
    update?: XOR<XOR<EmployeeUpdateToOneWithWhereWithoutAlertsInput, EmployeeUpdateWithoutAlertsInput>, EmployeeUncheckedUpdateWithoutAlertsInput>
  }

  export type UserUpdateOneWithoutAlertsNestedInput = {
    create?: XOR<UserCreateWithoutAlertsInput, UserUncheckedCreateWithoutAlertsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAlertsInput
    upsert?: UserUpsertWithoutAlertsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAlertsInput, UserUpdateWithoutAlertsInput>, UserUncheckedUpdateWithoutAlertsInput>
  }

  export type ActivityUpdateOneWithoutAlertsNestedInput = {
    create?: XOR<ActivityCreateWithoutAlertsInput, ActivityUncheckedCreateWithoutAlertsInput>
    connectOrCreate?: ActivityCreateOrConnectWithoutAlertsInput
    upsert?: ActivityUpsertWithoutAlertsInput
    disconnect?: ActivityWhereInput | boolean
    delete?: ActivityWhereInput | boolean
    connect?: ActivityWhereUniqueInput
    update?: XOR<XOR<ActivityUpdateToOneWithWhereWithoutAlertsInput, ActivityUpdateWithoutAlertsInput>, ActivityUncheckedUpdateWithoutAlertsInput>
  }

  export type EmployeeCreateNestedOneWithoutActivitiesInput = {
    create?: XOR<EmployeeCreateWithoutActivitiesInput, EmployeeUncheckedCreateWithoutActivitiesInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutActivitiesInput
    connect?: EmployeeWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutActivitiesInput = {
    create?: XOR<UserCreateWithoutActivitiesInput, UserUncheckedCreateWithoutActivitiesInput>
    connectOrCreate?: UserCreateOrConnectWithoutActivitiesInput
    connect?: UserWhereUniqueInput
  }

  export type GateCreateNestedOneWithoutActivitiesInput = {
    create?: XOR<GateCreateWithoutActivitiesInput, GateUncheckedCreateWithoutActivitiesInput>
    connectOrCreate?: GateCreateOrConnectWithoutActivitiesInput
    connect?: GateWhereUniqueInput
  }

  export type AlertCreateNestedManyWithoutActivityInput = {
    create?: XOR<AlertCreateWithoutActivityInput, AlertUncheckedCreateWithoutActivityInput> | AlertCreateWithoutActivityInput[] | AlertUncheckedCreateWithoutActivityInput[]
    connectOrCreate?: AlertCreateOrConnectWithoutActivityInput | AlertCreateOrConnectWithoutActivityInput[]
    createMany?: AlertCreateManyActivityInputEnvelope
    connect?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
  }

  export type AlertUncheckedCreateNestedManyWithoutActivityInput = {
    create?: XOR<AlertCreateWithoutActivityInput, AlertUncheckedCreateWithoutActivityInput> | AlertCreateWithoutActivityInput[] | AlertUncheckedCreateWithoutActivityInput[]
    connectOrCreate?: AlertCreateOrConnectWithoutActivityInput | AlertCreateOrConnectWithoutActivityInput[]
    createMany?: AlertCreateManyActivityInputEnvelope
    connect?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
  }

  export type EnumActivityTypeFieldUpdateOperationsInput = {
    set?: $Enums.ActivityType
  }

  export type EnumAccessStatusFieldUpdateOperationsInput = {
    set?: $Enums.AccessStatus
  }

  export type EmployeeUpdateOneRequiredWithoutActivitiesNestedInput = {
    create?: XOR<EmployeeCreateWithoutActivitiesInput, EmployeeUncheckedCreateWithoutActivitiesInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutActivitiesInput
    upsert?: EmployeeUpsertWithoutActivitiesInput
    connect?: EmployeeWhereUniqueInput
    update?: XOR<XOR<EmployeeUpdateToOneWithWhereWithoutActivitiesInput, EmployeeUpdateWithoutActivitiesInput>, EmployeeUncheckedUpdateWithoutActivitiesInput>
  }

  export type UserUpdateOneWithoutActivitiesNestedInput = {
    create?: XOR<UserCreateWithoutActivitiesInput, UserUncheckedCreateWithoutActivitiesInput>
    connectOrCreate?: UserCreateOrConnectWithoutActivitiesInput
    upsert?: UserUpsertWithoutActivitiesInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutActivitiesInput, UserUpdateWithoutActivitiesInput>, UserUncheckedUpdateWithoutActivitiesInput>
  }

  export type GateUpdateOneWithoutActivitiesNestedInput = {
    create?: XOR<GateCreateWithoutActivitiesInput, GateUncheckedCreateWithoutActivitiesInput>
    connectOrCreate?: GateCreateOrConnectWithoutActivitiesInput
    upsert?: GateUpsertWithoutActivitiesInput
    disconnect?: GateWhereInput | boolean
    delete?: GateWhereInput | boolean
    connect?: GateWhereUniqueInput
    update?: XOR<XOR<GateUpdateToOneWithWhereWithoutActivitiesInput, GateUpdateWithoutActivitiesInput>, GateUncheckedUpdateWithoutActivitiesInput>
  }

  export type AlertUpdateManyWithoutActivityNestedInput = {
    create?: XOR<AlertCreateWithoutActivityInput, AlertUncheckedCreateWithoutActivityInput> | AlertCreateWithoutActivityInput[] | AlertUncheckedCreateWithoutActivityInput[]
    connectOrCreate?: AlertCreateOrConnectWithoutActivityInput | AlertCreateOrConnectWithoutActivityInput[]
    upsert?: AlertUpsertWithWhereUniqueWithoutActivityInput | AlertUpsertWithWhereUniqueWithoutActivityInput[]
    createMany?: AlertCreateManyActivityInputEnvelope
    set?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
    disconnect?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
    delete?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
    connect?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
    update?: AlertUpdateWithWhereUniqueWithoutActivityInput | AlertUpdateWithWhereUniqueWithoutActivityInput[]
    updateMany?: AlertUpdateManyWithWhereWithoutActivityInput | AlertUpdateManyWithWhereWithoutActivityInput[]
    deleteMany?: AlertScalarWhereInput | AlertScalarWhereInput[]
  }

  export type AlertUncheckedUpdateManyWithoutActivityNestedInput = {
    create?: XOR<AlertCreateWithoutActivityInput, AlertUncheckedCreateWithoutActivityInput> | AlertCreateWithoutActivityInput[] | AlertUncheckedCreateWithoutActivityInput[]
    connectOrCreate?: AlertCreateOrConnectWithoutActivityInput | AlertCreateOrConnectWithoutActivityInput[]
    upsert?: AlertUpsertWithWhereUniqueWithoutActivityInput | AlertUpsertWithWhereUniqueWithoutActivityInput[]
    createMany?: AlertCreateManyActivityInputEnvelope
    set?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
    disconnect?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
    delete?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
    connect?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
    update?: AlertUpdateWithWhereUniqueWithoutActivityInput | AlertUpdateWithWhereUniqueWithoutActivityInput[]
    updateMany?: AlertUpdateManyWithWhereWithoutActivityInput | AlertUpdateManyWithWhereWithoutActivityInput[]
    deleteMany?: AlertScalarWhereInput | AlertScalarWhereInput[]
  }

  export type VendorAttachmentCreateNestedManyWithoutAttachmentInput = {
    create?: XOR<VendorAttachmentCreateWithoutAttachmentInput, VendorAttachmentUncheckedCreateWithoutAttachmentInput> | VendorAttachmentCreateWithoutAttachmentInput[] | VendorAttachmentUncheckedCreateWithoutAttachmentInput[]
    connectOrCreate?: VendorAttachmentCreateOrConnectWithoutAttachmentInput | VendorAttachmentCreateOrConnectWithoutAttachmentInput[]
    createMany?: VendorAttachmentCreateManyAttachmentInputEnvelope
    connect?: VendorAttachmentWhereUniqueInput | VendorAttachmentWhereUniqueInput[]
  }

  export type EmployeeAttachmentCreateNestedManyWithoutAttachmentInput = {
    create?: XOR<EmployeeAttachmentCreateWithoutAttachmentInput, EmployeeAttachmentUncheckedCreateWithoutAttachmentInput> | EmployeeAttachmentCreateWithoutAttachmentInput[] | EmployeeAttachmentUncheckedCreateWithoutAttachmentInput[]
    connectOrCreate?: EmployeeAttachmentCreateOrConnectWithoutAttachmentInput | EmployeeAttachmentCreateOrConnectWithoutAttachmentInput[]
    createMany?: EmployeeAttachmentCreateManyAttachmentInputEnvelope
    connect?: EmployeeAttachmentWhereUniqueInput | EmployeeAttachmentWhereUniqueInput[]
  }

  export type VendorAttachmentUncheckedCreateNestedManyWithoutAttachmentInput = {
    create?: XOR<VendorAttachmentCreateWithoutAttachmentInput, VendorAttachmentUncheckedCreateWithoutAttachmentInput> | VendorAttachmentCreateWithoutAttachmentInput[] | VendorAttachmentUncheckedCreateWithoutAttachmentInput[]
    connectOrCreate?: VendorAttachmentCreateOrConnectWithoutAttachmentInput | VendorAttachmentCreateOrConnectWithoutAttachmentInput[]
    createMany?: VendorAttachmentCreateManyAttachmentInputEnvelope
    connect?: VendorAttachmentWhereUniqueInput | VendorAttachmentWhereUniqueInput[]
  }

  export type EmployeeAttachmentUncheckedCreateNestedManyWithoutAttachmentInput = {
    create?: XOR<EmployeeAttachmentCreateWithoutAttachmentInput, EmployeeAttachmentUncheckedCreateWithoutAttachmentInput> | EmployeeAttachmentCreateWithoutAttachmentInput[] | EmployeeAttachmentUncheckedCreateWithoutAttachmentInput[]
    connectOrCreate?: EmployeeAttachmentCreateOrConnectWithoutAttachmentInput | EmployeeAttachmentCreateOrConnectWithoutAttachmentInput[]
    createMany?: EmployeeAttachmentCreateManyAttachmentInputEnvelope
    connect?: EmployeeAttachmentWhereUniqueInput | EmployeeAttachmentWhereUniqueInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type VendorAttachmentUpdateManyWithoutAttachmentNestedInput = {
    create?: XOR<VendorAttachmentCreateWithoutAttachmentInput, VendorAttachmentUncheckedCreateWithoutAttachmentInput> | VendorAttachmentCreateWithoutAttachmentInput[] | VendorAttachmentUncheckedCreateWithoutAttachmentInput[]
    connectOrCreate?: VendorAttachmentCreateOrConnectWithoutAttachmentInput | VendorAttachmentCreateOrConnectWithoutAttachmentInput[]
    upsert?: VendorAttachmentUpsertWithWhereUniqueWithoutAttachmentInput | VendorAttachmentUpsertWithWhereUniqueWithoutAttachmentInput[]
    createMany?: VendorAttachmentCreateManyAttachmentInputEnvelope
    set?: VendorAttachmentWhereUniqueInput | VendorAttachmentWhereUniqueInput[]
    disconnect?: VendorAttachmentWhereUniqueInput | VendorAttachmentWhereUniqueInput[]
    delete?: VendorAttachmentWhereUniqueInput | VendorAttachmentWhereUniqueInput[]
    connect?: VendorAttachmentWhereUniqueInput | VendorAttachmentWhereUniqueInput[]
    update?: VendorAttachmentUpdateWithWhereUniqueWithoutAttachmentInput | VendorAttachmentUpdateWithWhereUniqueWithoutAttachmentInput[]
    updateMany?: VendorAttachmentUpdateManyWithWhereWithoutAttachmentInput | VendorAttachmentUpdateManyWithWhereWithoutAttachmentInput[]
    deleteMany?: VendorAttachmentScalarWhereInput | VendorAttachmentScalarWhereInput[]
  }

  export type EmployeeAttachmentUpdateManyWithoutAttachmentNestedInput = {
    create?: XOR<EmployeeAttachmentCreateWithoutAttachmentInput, EmployeeAttachmentUncheckedCreateWithoutAttachmentInput> | EmployeeAttachmentCreateWithoutAttachmentInput[] | EmployeeAttachmentUncheckedCreateWithoutAttachmentInput[]
    connectOrCreate?: EmployeeAttachmentCreateOrConnectWithoutAttachmentInput | EmployeeAttachmentCreateOrConnectWithoutAttachmentInput[]
    upsert?: EmployeeAttachmentUpsertWithWhereUniqueWithoutAttachmentInput | EmployeeAttachmentUpsertWithWhereUniqueWithoutAttachmentInput[]
    createMany?: EmployeeAttachmentCreateManyAttachmentInputEnvelope
    set?: EmployeeAttachmentWhereUniqueInput | EmployeeAttachmentWhereUniqueInput[]
    disconnect?: EmployeeAttachmentWhereUniqueInput | EmployeeAttachmentWhereUniqueInput[]
    delete?: EmployeeAttachmentWhereUniqueInput | EmployeeAttachmentWhereUniqueInput[]
    connect?: EmployeeAttachmentWhereUniqueInput | EmployeeAttachmentWhereUniqueInput[]
    update?: EmployeeAttachmentUpdateWithWhereUniqueWithoutAttachmentInput | EmployeeAttachmentUpdateWithWhereUniqueWithoutAttachmentInput[]
    updateMany?: EmployeeAttachmentUpdateManyWithWhereWithoutAttachmentInput | EmployeeAttachmentUpdateManyWithWhereWithoutAttachmentInput[]
    deleteMany?: EmployeeAttachmentScalarWhereInput | EmployeeAttachmentScalarWhereInput[]
  }

  export type VendorAttachmentUncheckedUpdateManyWithoutAttachmentNestedInput = {
    create?: XOR<VendorAttachmentCreateWithoutAttachmentInput, VendorAttachmentUncheckedCreateWithoutAttachmentInput> | VendorAttachmentCreateWithoutAttachmentInput[] | VendorAttachmentUncheckedCreateWithoutAttachmentInput[]
    connectOrCreate?: VendorAttachmentCreateOrConnectWithoutAttachmentInput | VendorAttachmentCreateOrConnectWithoutAttachmentInput[]
    upsert?: VendorAttachmentUpsertWithWhereUniqueWithoutAttachmentInput | VendorAttachmentUpsertWithWhereUniqueWithoutAttachmentInput[]
    createMany?: VendorAttachmentCreateManyAttachmentInputEnvelope
    set?: VendorAttachmentWhereUniqueInput | VendorAttachmentWhereUniqueInput[]
    disconnect?: VendorAttachmentWhereUniqueInput | VendorAttachmentWhereUniqueInput[]
    delete?: VendorAttachmentWhereUniqueInput | VendorAttachmentWhereUniqueInput[]
    connect?: VendorAttachmentWhereUniqueInput | VendorAttachmentWhereUniqueInput[]
    update?: VendorAttachmentUpdateWithWhereUniqueWithoutAttachmentInput | VendorAttachmentUpdateWithWhereUniqueWithoutAttachmentInput[]
    updateMany?: VendorAttachmentUpdateManyWithWhereWithoutAttachmentInput | VendorAttachmentUpdateManyWithWhereWithoutAttachmentInput[]
    deleteMany?: VendorAttachmentScalarWhereInput | VendorAttachmentScalarWhereInput[]
  }

  export type EmployeeAttachmentUncheckedUpdateManyWithoutAttachmentNestedInput = {
    create?: XOR<EmployeeAttachmentCreateWithoutAttachmentInput, EmployeeAttachmentUncheckedCreateWithoutAttachmentInput> | EmployeeAttachmentCreateWithoutAttachmentInput[] | EmployeeAttachmentUncheckedCreateWithoutAttachmentInput[]
    connectOrCreate?: EmployeeAttachmentCreateOrConnectWithoutAttachmentInput | EmployeeAttachmentCreateOrConnectWithoutAttachmentInput[]
    upsert?: EmployeeAttachmentUpsertWithWhereUniqueWithoutAttachmentInput | EmployeeAttachmentUpsertWithWhereUniqueWithoutAttachmentInput[]
    createMany?: EmployeeAttachmentCreateManyAttachmentInputEnvelope
    set?: EmployeeAttachmentWhereUniqueInput | EmployeeAttachmentWhereUniqueInput[]
    disconnect?: EmployeeAttachmentWhereUniqueInput | EmployeeAttachmentWhereUniqueInput[]
    delete?: EmployeeAttachmentWhereUniqueInput | EmployeeAttachmentWhereUniqueInput[]
    connect?: EmployeeAttachmentWhereUniqueInput | EmployeeAttachmentWhereUniqueInput[]
    update?: EmployeeAttachmentUpdateWithWhereUniqueWithoutAttachmentInput | EmployeeAttachmentUpdateWithWhereUniqueWithoutAttachmentInput[]
    updateMany?: EmployeeAttachmentUpdateManyWithWhereWithoutAttachmentInput | EmployeeAttachmentUpdateManyWithWhereWithoutAttachmentInput[]
    deleteMany?: EmployeeAttachmentScalarWhereInput | EmployeeAttachmentScalarWhereInput[]
  }

  export type VendorCreateNestedOneWithoutVendorAttachmentsInput = {
    create?: XOR<VendorCreateWithoutVendorAttachmentsInput, VendorUncheckedCreateWithoutVendorAttachmentsInput>
    connectOrCreate?: VendorCreateOrConnectWithoutVendorAttachmentsInput
    connect?: VendorWhereUniqueInput
  }

  export type AttachmentCreateNestedOneWithoutVendorAttachmentsInput = {
    create?: XOR<AttachmentCreateWithoutVendorAttachmentsInput, AttachmentUncheckedCreateWithoutVendorAttachmentsInput>
    connectOrCreate?: AttachmentCreateOrConnectWithoutVendorAttachmentsInput
    connect?: AttachmentWhereUniqueInput
  }

  export type VendorUpdateOneRequiredWithoutVendorAttachmentsNestedInput = {
    create?: XOR<VendorCreateWithoutVendorAttachmentsInput, VendorUncheckedCreateWithoutVendorAttachmentsInput>
    connectOrCreate?: VendorCreateOrConnectWithoutVendorAttachmentsInput
    upsert?: VendorUpsertWithoutVendorAttachmentsInput
    connect?: VendorWhereUniqueInput
    update?: XOR<XOR<VendorUpdateToOneWithWhereWithoutVendorAttachmentsInput, VendorUpdateWithoutVendorAttachmentsInput>, VendorUncheckedUpdateWithoutVendorAttachmentsInput>
  }

  export type AttachmentUpdateOneRequiredWithoutVendorAttachmentsNestedInput = {
    create?: XOR<AttachmentCreateWithoutVendorAttachmentsInput, AttachmentUncheckedCreateWithoutVendorAttachmentsInput>
    connectOrCreate?: AttachmentCreateOrConnectWithoutVendorAttachmentsInput
    upsert?: AttachmentUpsertWithoutVendorAttachmentsInput
    connect?: AttachmentWhereUniqueInput
    update?: XOR<XOR<AttachmentUpdateToOneWithWhereWithoutVendorAttachmentsInput, AttachmentUpdateWithoutVendorAttachmentsInput>, AttachmentUncheckedUpdateWithoutVendorAttachmentsInput>
  }

  export type EmployeeCreateNestedOneWithoutEmployeeAttachmentsInput = {
    create?: XOR<EmployeeCreateWithoutEmployeeAttachmentsInput, EmployeeUncheckedCreateWithoutEmployeeAttachmentsInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutEmployeeAttachmentsInput
    connect?: EmployeeWhereUniqueInput
  }

  export type AttachmentCreateNestedOneWithoutEmployeeAttachmentsInput = {
    create?: XOR<AttachmentCreateWithoutEmployeeAttachmentsInput, AttachmentUncheckedCreateWithoutEmployeeAttachmentsInput>
    connectOrCreate?: AttachmentCreateOrConnectWithoutEmployeeAttachmentsInput
    connect?: AttachmentWhereUniqueInput
  }

  export type EnumEmployeeAttachmentTypeFieldUpdateOperationsInput = {
    set?: $Enums.EmployeeAttachmentType
  }

  export type EmployeeUpdateOneRequiredWithoutEmployeeAttachmentsNestedInput = {
    create?: XOR<EmployeeCreateWithoutEmployeeAttachmentsInput, EmployeeUncheckedCreateWithoutEmployeeAttachmentsInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutEmployeeAttachmentsInput
    upsert?: EmployeeUpsertWithoutEmployeeAttachmentsInput
    connect?: EmployeeWhereUniqueInput
    update?: XOR<XOR<EmployeeUpdateToOneWithWhereWithoutEmployeeAttachmentsInput, EmployeeUpdateWithoutEmployeeAttachmentsInput>, EmployeeUncheckedUpdateWithoutEmployeeAttachmentsInput>
  }

  export type AttachmentUpdateOneRequiredWithoutEmployeeAttachmentsNestedInput = {
    create?: XOR<AttachmentCreateWithoutEmployeeAttachmentsInput, AttachmentUncheckedCreateWithoutEmployeeAttachmentsInput>
    connectOrCreate?: AttachmentCreateOrConnectWithoutEmployeeAttachmentsInput
    upsert?: AttachmentUpsertWithoutEmployeeAttachmentsInput
    connect?: AttachmentWhereUniqueInput
    update?: XOR<XOR<AttachmentUpdateToOneWithWhereWithoutEmployeeAttachmentsInput, AttachmentUpdateWithoutEmployeeAttachmentsInput>, AttachmentUncheckedUpdateWithoutEmployeeAttachmentsInput>
  }

  export type EmployeeCreateNestedOneWithoutEmployeePermissionsInput = {
    create?: XOR<EmployeeCreateWithoutEmployeePermissionsInput, EmployeeUncheckedCreateWithoutEmployeePermissionsInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutEmployeePermissionsInput
    connect?: EmployeeWhereUniqueInput
  }

  export type PermissionCreateNestedOneWithoutEmployeePermissionsInput = {
    create?: XOR<PermissionCreateWithoutEmployeePermissionsInput, PermissionUncheckedCreateWithoutEmployeePermissionsInput>
    connectOrCreate?: PermissionCreateOrConnectWithoutEmployeePermissionsInput
    connect?: PermissionWhereUniqueInput
  }

  export type EmployeeUpdateOneRequiredWithoutEmployeePermissionsNestedInput = {
    create?: XOR<EmployeeCreateWithoutEmployeePermissionsInput, EmployeeUncheckedCreateWithoutEmployeePermissionsInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutEmployeePermissionsInput
    upsert?: EmployeeUpsertWithoutEmployeePermissionsInput
    connect?: EmployeeWhereUniqueInput
    update?: XOR<XOR<EmployeeUpdateToOneWithWhereWithoutEmployeePermissionsInput, EmployeeUpdateWithoutEmployeePermissionsInput>, EmployeeUncheckedUpdateWithoutEmployeePermissionsInput>
  }

  export type PermissionUpdateOneRequiredWithoutEmployeePermissionsNestedInput = {
    create?: XOR<PermissionCreateWithoutEmployeePermissionsInput, PermissionUncheckedCreateWithoutEmployeePermissionsInput>
    connectOrCreate?: PermissionCreateOrConnectWithoutEmployeePermissionsInput
    upsert?: PermissionUpsertWithoutEmployeePermissionsInput
    connect?: PermissionWhereUniqueInput
    update?: XOR<XOR<PermissionUpdateToOneWithWhereWithoutEmployeePermissionsInput, PermissionUpdateWithoutEmployeePermissionsInput>, PermissionUncheckedUpdateWithoutEmployeePermissionsInput>
  }

  export type VendorCreateNestedOneWithoutGatesInput = {
    create?: XOR<VendorCreateWithoutGatesInput, VendorUncheckedCreateWithoutGatesInput>
    connectOrCreate?: VendorCreateOrConnectWithoutGatesInput
    connect?: VendorWhereUniqueInput
  }

  export type GateCreateNestedOneWithoutVendorsInput = {
    create?: XOR<GateCreateWithoutVendorsInput, GateUncheckedCreateWithoutVendorsInput>
    connectOrCreate?: GateCreateOrConnectWithoutVendorsInput
    connect?: GateWhereUniqueInput
  }

  export type VendorUpdateOneRequiredWithoutGatesNestedInput = {
    create?: XOR<VendorCreateWithoutGatesInput, VendorUncheckedCreateWithoutGatesInput>
    connectOrCreate?: VendorCreateOrConnectWithoutGatesInput
    upsert?: VendorUpsertWithoutGatesInput
    connect?: VendorWhereUniqueInput
    update?: XOR<XOR<VendorUpdateToOneWithWhereWithoutGatesInput, VendorUpdateWithoutGatesInput>, VendorUncheckedUpdateWithoutGatesInput>
  }

  export type GateUpdateOneRequiredWithoutVendorsNestedInput = {
    create?: XOR<GateCreateWithoutVendorsInput, GateUncheckedCreateWithoutVendorsInput>
    connectOrCreate?: GateCreateOrConnectWithoutVendorsInput
    upsert?: GateUpsertWithoutVendorsInput
    connect?: GateWhereUniqueInput
    update?: XOR<XOR<GateUpdateToOneWithWhereWithoutVendorsInput, GateUpdateWithoutVendorsInput>, GateUncheckedUpdateWithoutVendorsInput>
  }

  export type VendorCreateNestedOneWithoutZonesInput = {
    create?: XOR<VendorCreateWithoutZonesInput, VendorUncheckedCreateWithoutZonesInput>
    connectOrCreate?: VendorCreateOrConnectWithoutZonesInput
    connect?: VendorWhereUniqueInput
  }

  export type ZoneCreateNestedOneWithoutVendorsInput = {
    create?: XOR<ZoneCreateWithoutVendorsInput, ZoneUncheckedCreateWithoutVendorsInput>
    connectOrCreate?: ZoneCreateOrConnectWithoutVendorsInput
    connect?: ZoneWhereUniqueInput
  }

  export type VendorUpdateOneRequiredWithoutZonesNestedInput = {
    create?: XOR<VendorCreateWithoutZonesInput, VendorUncheckedCreateWithoutZonesInput>
    connectOrCreate?: VendorCreateOrConnectWithoutZonesInput
    upsert?: VendorUpsertWithoutZonesInput
    connect?: VendorWhereUniqueInput
    update?: XOR<XOR<VendorUpdateToOneWithWhereWithoutZonesInput, VendorUpdateWithoutZonesInput>, VendorUncheckedUpdateWithoutZonesInput>
  }

  export type ZoneUpdateOneRequiredWithoutVendorsNestedInput = {
    create?: XOR<ZoneCreateWithoutVendorsInput, ZoneUncheckedCreateWithoutVendorsInput>
    connectOrCreate?: ZoneCreateOrConnectWithoutVendorsInput
    upsert?: ZoneUpsertWithoutVendorsInput
    connect?: ZoneWhereUniqueInput
    update?: XOR<XOR<ZoneUpdateToOneWithWhereWithoutVendorsInput, ZoneUpdateWithoutVendorsInput>, ZoneUncheckedUpdateWithoutVendorsInput>
  }

  export type EmployeeCreateNestedOneWithoutGatesInput = {
    create?: XOR<EmployeeCreateWithoutGatesInput, EmployeeUncheckedCreateWithoutGatesInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutGatesInput
    connect?: EmployeeWhereUniqueInput
  }

  export type GateCreateNestedOneWithoutEmployeesInput = {
    create?: XOR<GateCreateWithoutEmployeesInput, GateUncheckedCreateWithoutEmployeesInput>
    connectOrCreate?: GateCreateOrConnectWithoutEmployeesInput
    connect?: GateWhereUniqueInput
  }

  export type EmployeeUpdateOneRequiredWithoutGatesNestedInput = {
    create?: XOR<EmployeeCreateWithoutGatesInput, EmployeeUncheckedCreateWithoutGatesInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutGatesInput
    upsert?: EmployeeUpsertWithoutGatesInput
    connect?: EmployeeWhereUniqueInput
    update?: XOR<XOR<EmployeeUpdateToOneWithWhereWithoutGatesInput, EmployeeUpdateWithoutGatesInput>, EmployeeUncheckedUpdateWithoutGatesInput>
  }

  export type GateUpdateOneRequiredWithoutEmployeesNestedInput = {
    create?: XOR<GateCreateWithoutEmployeesInput, GateUncheckedCreateWithoutEmployeesInput>
    connectOrCreate?: GateCreateOrConnectWithoutEmployeesInput
    upsert?: GateUpsertWithoutEmployeesInput
    connect?: GateWhereUniqueInput
    update?: XOR<XOR<GateUpdateToOneWithWhereWithoutEmployeesInput, GateUpdateWithoutEmployeesInput>, GateUncheckedUpdateWithoutEmployeesInput>
  }

  export type EmployeeCreateNestedOneWithoutZonesInput = {
    create?: XOR<EmployeeCreateWithoutZonesInput, EmployeeUncheckedCreateWithoutZonesInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutZonesInput
    connect?: EmployeeWhereUniqueInput
  }

  export type ZoneCreateNestedOneWithoutEmployeesInput = {
    create?: XOR<ZoneCreateWithoutEmployeesInput, ZoneUncheckedCreateWithoutEmployeesInput>
    connectOrCreate?: ZoneCreateOrConnectWithoutEmployeesInput
    connect?: ZoneWhereUniqueInput
  }

  export type EmployeeUpdateOneRequiredWithoutZonesNestedInput = {
    create?: XOR<EmployeeCreateWithoutZonesInput, EmployeeUncheckedCreateWithoutZonesInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutZonesInput
    upsert?: EmployeeUpsertWithoutZonesInput
    connect?: EmployeeWhereUniqueInput
    update?: XOR<XOR<EmployeeUpdateToOneWithWhereWithoutZonesInput, EmployeeUpdateWithoutZonesInput>, EmployeeUncheckedUpdateWithoutZonesInput>
  }

  export type ZoneUpdateOneRequiredWithoutEmployeesNestedInput = {
    create?: XOR<ZoneCreateWithoutEmployeesInput, ZoneUncheckedCreateWithoutEmployeesInput>
    connectOrCreate?: ZoneCreateOrConnectWithoutEmployeesInput
    upsert?: ZoneUpsertWithoutEmployeesInput
    connect?: ZoneWhereUniqueInput
    update?: XOR<XOR<ZoneUpdateToOneWithWhereWithoutEmployeesInput, ZoneUpdateWithoutEmployeesInput>, ZoneUncheckedUpdateWithoutEmployeesInput>
  }

  export type EmployeeCreateNestedOneWithoutAllowedDatesInput = {
    create?: XOR<EmployeeCreateWithoutAllowedDatesInput, EmployeeUncheckedCreateWithoutAllowedDatesInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutAllowedDatesInput
    connect?: EmployeeWhereUniqueInput
  }

  export type EmployeeUpdateOneRequiredWithoutAllowedDatesNestedInput = {
    create?: XOR<EmployeeCreateWithoutAllowedDatesInput, EmployeeUncheckedCreateWithoutAllowedDatesInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutAllowedDatesInput
    upsert?: EmployeeUpsertWithoutAllowedDatesInput
    connect?: EmployeeWhereUniqueInput
    update?: XOR<XOR<EmployeeUpdateToOneWithWhereWithoutAllowedDatesInput, EmployeeUpdateWithoutAllowedDatesInput>, EmployeeUncheckedUpdateWithoutAllowedDatesInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedEnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumEmployeeStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.EmployeeStatus | EnumEmployeeStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EmployeeStatus[] | ListEnumEmployeeStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.EmployeeStatus[] | ListEnumEmployeeStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumEmployeeStatusFilter<$PrismaModel> | $Enums.EmployeeStatus
  }

  export type NestedEnumEmployeeStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EmployeeStatus | EnumEmployeeStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EmployeeStatus[] | ListEnumEmployeeStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.EmployeeStatus[] | ListEnumEmployeeStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumEmployeeStatusWithAggregatesFilter<$PrismaModel> | $Enums.EmployeeStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEmployeeStatusFilter<$PrismaModel>
    _max?: NestedEnumEmployeeStatusFilter<$PrismaModel>
  }

  export type NestedEnumDayOfWeekFilter<$PrismaModel = never> = {
    equals?: $Enums.DayOfWeek | EnumDayOfWeekFieldRefInput<$PrismaModel>
    in?: $Enums.DayOfWeek[] | ListEnumDayOfWeekFieldRefInput<$PrismaModel>
    notIn?: $Enums.DayOfWeek[] | ListEnumDayOfWeekFieldRefInput<$PrismaModel>
    not?: NestedEnumDayOfWeekFilter<$PrismaModel> | $Enums.DayOfWeek
  }

  export type NestedEnumDayOfWeekWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DayOfWeek | EnumDayOfWeekFieldRefInput<$PrismaModel>
    in?: $Enums.DayOfWeek[] | ListEnumDayOfWeekFieldRefInput<$PrismaModel>
    notIn?: $Enums.DayOfWeek[] | ListEnumDayOfWeekFieldRefInput<$PrismaModel>
    not?: NestedEnumDayOfWeekWithAggregatesFilter<$PrismaModel> | $Enums.DayOfWeek
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDayOfWeekFilter<$PrismaModel>
    _max?: NestedEnumDayOfWeekFilter<$PrismaModel>
  }

  export type NestedEnumActivityTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ActivityType | EnumActivityTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ActivityType[] | ListEnumActivityTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ActivityType[] | ListEnumActivityTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumActivityTypeFilter<$PrismaModel> | $Enums.ActivityType
  }

  export type NestedEnumAccessStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AccessStatus | EnumAccessStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AccessStatus[] | ListEnumAccessStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccessStatus[] | ListEnumAccessStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAccessStatusFilter<$PrismaModel> | $Enums.AccessStatus
  }

  export type NestedEnumActivityTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ActivityType | EnumActivityTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ActivityType[] | ListEnumActivityTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ActivityType[] | ListEnumActivityTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumActivityTypeWithAggregatesFilter<$PrismaModel> | $Enums.ActivityType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumActivityTypeFilter<$PrismaModel>
    _max?: NestedEnumActivityTypeFilter<$PrismaModel>
  }

  export type NestedEnumAccessStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AccessStatus | EnumAccessStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AccessStatus[] | ListEnumAccessStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccessStatus[] | ListEnumAccessStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAccessStatusWithAggregatesFilter<$PrismaModel> | $Enums.AccessStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAccessStatusFilter<$PrismaModel>
    _max?: NestedEnumAccessStatusFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumEmployeeAttachmentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.EmployeeAttachmentType | EnumEmployeeAttachmentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EmployeeAttachmentType[] | ListEnumEmployeeAttachmentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.EmployeeAttachmentType[] | ListEnumEmployeeAttachmentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumEmployeeAttachmentTypeFilter<$PrismaModel> | $Enums.EmployeeAttachmentType
  }

  export type NestedEnumEmployeeAttachmentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EmployeeAttachmentType | EnumEmployeeAttachmentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EmployeeAttachmentType[] | ListEnumEmployeeAttachmentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.EmployeeAttachmentType[] | ListEnumEmployeeAttachmentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumEmployeeAttachmentTypeWithAggregatesFilter<$PrismaModel> | $Enums.EmployeeAttachmentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEmployeeAttachmentTypeFilter<$PrismaModel>
    _max?: NestedEnumEmployeeAttachmentTypeFilter<$PrismaModel>
  }

  export type ActivityCreateWithoutScannerInput = {
    id?: string
    type?: $Enums.ActivityType
    status: $Enums.AccessStatus
    denialReason?: string | null
    scannedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    employee: EmployeeCreateNestedOneWithoutActivitiesInput
    gate?: GateCreateNestedOneWithoutActivitiesInput
    alerts?: AlertCreateNestedManyWithoutActivityInput
  }

  export type ActivityUncheckedCreateWithoutScannerInput = {
    id?: string
    type?: $Enums.ActivityType
    status: $Enums.AccessStatus
    denialReason?: string | null
    scannedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    employeeId: string
    gateId?: string | null
    alerts?: AlertUncheckedCreateNestedManyWithoutActivityInput
  }

  export type ActivityCreateOrConnectWithoutScannerInput = {
    where: ActivityWhereUniqueInput
    create: XOR<ActivityCreateWithoutScannerInput, ActivityUncheckedCreateWithoutScannerInput>
  }

  export type ActivityCreateManyScannerInputEnvelope = {
    data: ActivityCreateManyScannerInput | ActivityCreateManyScannerInput[]
    skipDuplicates?: boolean
  }

  export type AlertCreateWithoutUserInput = {
    id?: string
    text: string
    severity?: string
    isResolved?: boolean
    resolvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    employee?: EmployeeCreateNestedOneWithoutAlertsInput
    activity?: ActivityCreateNestedOneWithoutAlertsInput
  }

  export type AlertUncheckedCreateWithoutUserInput = {
    id?: string
    text: string
    severity?: string
    isResolved?: boolean
    resolvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    employeeId?: string | null
    activityId?: string | null
  }

  export type AlertCreateOrConnectWithoutUserInput = {
    where: AlertWhereUniqueInput
    create: XOR<AlertCreateWithoutUserInput, AlertUncheckedCreateWithoutUserInput>
  }

  export type AlertCreateManyUserInputEnvelope = {
    data: AlertCreateManyUserInput | AlertCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ActivityUpsertWithWhereUniqueWithoutScannerInput = {
    where: ActivityWhereUniqueInput
    update: XOR<ActivityUpdateWithoutScannerInput, ActivityUncheckedUpdateWithoutScannerInput>
    create: XOR<ActivityCreateWithoutScannerInput, ActivityUncheckedCreateWithoutScannerInput>
  }

  export type ActivityUpdateWithWhereUniqueWithoutScannerInput = {
    where: ActivityWhereUniqueInput
    data: XOR<ActivityUpdateWithoutScannerInput, ActivityUncheckedUpdateWithoutScannerInput>
  }

  export type ActivityUpdateManyWithWhereWithoutScannerInput = {
    where: ActivityScalarWhereInput
    data: XOR<ActivityUpdateManyMutationInput, ActivityUncheckedUpdateManyWithoutScannerInput>
  }

  export type ActivityScalarWhereInput = {
    AND?: ActivityScalarWhereInput | ActivityScalarWhereInput[]
    OR?: ActivityScalarWhereInput[]
    NOT?: ActivityScalarWhereInput | ActivityScalarWhereInput[]
    id?: StringFilter<"Activity"> | string
    type?: EnumActivityTypeFilter<"Activity"> | $Enums.ActivityType
    status?: EnumAccessStatusFilter<"Activity"> | $Enums.AccessStatus
    denialReason?: StringNullableFilter<"Activity"> | string | null
    scannedAt?: DateTimeFilter<"Activity"> | Date | string
    createdAt?: DateTimeFilter<"Activity"> | Date | string
    updatedAt?: DateTimeFilter<"Activity"> | Date | string
    employeeId?: StringFilter<"Activity"> | string
    scannerId?: StringNullableFilter<"Activity"> | string | null
    gateId?: StringNullableFilter<"Activity"> | string | null
  }

  export type AlertUpsertWithWhereUniqueWithoutUserInput = {
    where: AlertWhereUniqueInput
    update: XOR<AlertUpdateWithoutUserInput, AlertUncheckedUpdateWithoutUserInput>
    create: XOR<AlertCreateWithoutUserInput, AlertUncheckedCreateWithoutUserInput>
  }

  export type AlertUpdateWithWhereUniqueWithoutUserInput = {
    where: AlertWhereUniqueInput
    data: XOR<AlertUpdateWithoutUserInput, AlertUncheckedUpdateWithoutUserInput>
  }

  export type AlertUpdateManyWithWhereWithoutUserInput = {
    where: AlertScalarWhereInput
    data: XOR<AlertUpdateManyMutationInput, AlertUncheckedUpdateManyWithoutUserInput>
  }

  export type AlertScalarWhereInput = {
    AND?: AlertScalarWhereInput | AlertScalarWhereInput[]
    OR?: AlertScalarWhereInput[]
    NOT?: AlertScalarWhereInput | AlertScalarWhereInput[]
    id?: StringFilter<"Alert"> | string
    text?: StringFilter<"Alert"> | string
    severity?: StringFilter<"Alert"> | string
    isResolved?: BoolFilter<"Alert"> | boolean
    resolvedAt?: DateTimeNullableFilter<"Alert"> | Date | string | null
    createdAt?: DateTimeFilter<"Alert"> | Date | string
    updatedAt?: DateTimeFilter<"Alert"> | Date | string
    employeeId?: StringNullableFilter<"Alert"> | string | null
    userId?: StringNullableFilter<"Alert"> | string | null
    activityId?: StringNullableFilter<"Alert"> | string | null
  }

  export type EmployeeCreateWithoutVendorInput = {
    id?: string
    identifier?: string
    name: string
    job: string
    nationalId: string
    version?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    status?: $Enums.EmployeeStatus
    gates?: EmployeeGateCreateNestedManyWithoutEmployeeInput
    zones?: EmployeeZoneCreateNestedManyWithoutEmployeeInput
    activities?: ActivityCreateNestedManyWithoutEmployeeInput
    workingHours?: WorkingHoursCreateNestedManyWithoutEmployeeInput
    employeeAttachments?: EmployeeAttachmentCreateNestedManyWithoutEmployeeInput
    employeePermissions?: EmployeePermissionCreateNestedManyWithoutEmployeeInput
    alerts?: AlertCreateNestedManyWithoutEmployeeInput
    allowedDates?: EmployeeAllowedDateCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutVendorInput = {
    id?: string
    identifier?: string
    name: string
    job: string
    nationalId: string
    version?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    status?: $Enums.EmployeeStatus
    gates?: EmployeeGateUncheckedCreateNestedManyWithoutEmployeeInput
    zones?: EmployeeZoneUncheckedCreateNestedManyWithoutEmployeeInput
    activities?: ActivityUncheckedCreateNestedManyWithoutEmployeeInput
    workingHours?: WorkingHoursUncheckedCreateNestedManyWithoutEmployeeInput
    employeeAttachments?: EmployeeAttachmentUncheckedCreateNestedManyWithoutEmployeeInput
    employeePermissions?: EmployeePermissionUncheckedCreateNestedManyWithoutEmployeeInput
    alerts?: AlertUncheckedCreateNestedManyWithoutEmployeeInput
    allowedDates?: EmployeeAllowedDateUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeCreateOrConnectWithoutVendorInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutVendorInput, EmployeeUncheckedCreateWithoutVendorInput>
  }

  export type EmployeeCreateManyVendorInputEnvelope = {
    data: EmployeeCreateManyVendorInput | EmployeeCreateManyVendorInput[]
    skipDuplicates?: boolean
  }

  export type VendorAttachmentCreateWithoutVendorInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    attachment: AttachmentCreateNestedOneWithoutVendorAttachmentsInput
  }

  export type VendorAttachmentUncheckedCreateWithoutVendorInput = {
    id?: string
    attachmentId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VendorAttachmentCreateOrConnectWithoutVendorInput = {
    where: VendorAttachmentWhereUniqueInput
    create: XOR<VendorAttachmentCreateWithoutVendorInput, VendorAttachmentUncheckedCreateWithoutVendorInput>
  }

  export type VendorAttachmentCreateManyVendorInputEnvelope = {
    data: VendorAttachmentCreateManyVendorInput | VendorAttachmentCreateManyVendorInput[]
    skipDuplicates?: boolean
  }

  export type VendorGateCreateWithoutVendorInput = {
    id?: string
    createdAt?: Date | string
    gate: GateCreateNestedOneWithoutVendorsInput
  }

  export type VendorGateUncheckedCreateWithoutVendorInput = {
    id?: string
    gateId: string
    createdAt?: Date | string
  }

  export type VendorGateCreateOrConnectWithoutVendorInput = {
    where: VendorGateWhereUniqueInput
    create: XOR<VendorGateCreateWithoutVendorInput, VendorGateUncheckedCreateWithoutVendorInput>
  }

  export type VendorGateCreateManyVendorInputEnvelope = {
    data: VendorGateCreateManyVendorInput | VendorGateCreateManyVendorInput[]
    skipDuplicates?: boolean
  }

  export type VendorZoneCreateWithoutVendorInput = {
    id?: string
    createdAt?: Date | string
    zone: ZoneCreateNestedOneWithoutVendorsInput
  }

  export type VendorZoneUncheckedCreateWithoutVendorInput = {
    id?: string
    zoneId: string
    createdAt?: Date | string
  }

  export type VendorZoneCreateOrConnectWithoutVendorInput = {
    where: VendorZoneWhereUniqueInput
    create: XOR<VendorZoneCreateWithoutVendorInput, VendorZoneUncheckedCreateWithoutVendorInput>
  }

  export type VendorZoneCreateManyVendorInputEnvelope = {
    data: VendorZoneCreateManyVendorInput | VendorZoneCreateManyVendorInput[]
    skipDuplicates?: boolean
  }

  export type EmployeeUpsertWithWhereUniqueWithoutVendorInput = {
    where: EmployeeWhereUniqueInput
    update: XOR<EmployeeUpdateWithoutVendorInput, EmployeeUncheckedUpdateWithoutVendorInput>
    create: XOR<EmployeeCreateWithoutVendorInput, EmployeeUncheckedCreateWithoutVendorInput>
  }

  export type EmployeeUpdateWithWhereUniqueWithoutVendorInput = {
    where: EmployeeWhereUniqueInput
    data: XOR<EmployeeUpdateWithoutVendorInput, EmployeeUncheckedUpdateWithoutVendorInput>
  }

  export type EmployeeUpdateManyWithWhereWithoutVendorInput = {
    where: EmployeeScalarWhereInput
    data: XOR<EmployeeUpdateManyMutationInput, EmployeeUncheckedUpdateManyWithoutVendorInput>
  }

  export type EmployeeScalarWhereInput = {
    AND?: EmployeeScalarWhereInput | EmployeeScalarWhereInput[]
    OR?: EmployeeScalarWhereInput[]
    NOT?: EmployeeScalarWhereInput | EmployeeScalarWhereInput[]
    id?: StringFilter<"Employee"> | string
    identifier?: StringFilter<"Employee"> | string
    name?: StringFilter<"Employee"> | string
    job?: StringFilter<"Employee"> | string
    nationalId?: StringFilter<"Employee"> | string
    version?: IntFilter<"Employee"> | number
    createdAt?: DateTimeFilter<"Employee"> | Date | string
    updatedAt?: DateTimeFilter<"Employee"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Employee"> | Date | string | null
    status?: EnumEmployeeStatusFilter<"Employee"> | $Enums.EmployeeStatus
    vendorId?: StringFilter<"Employee"> | string
  }

  export type VendorAttachmentUpsertWithWhereUniqueWithoutVendorInput = {
    where: VendorAttachmentWhereUniqueInput
    update: XOR<VendorAttachmentUpdateWithoutVendorInput, VendorAttachmentUncheckedUpdateWithoutVendorInput>
    create: XOR<VendorAttachmentCreateWithoutVendorInput, VendorAttachmentUncheckedCreateWithoutVendorInput>
  }

  export type VendorAttachmentUpdateWithWhereUniqueWithoutVendorInput = {
    where: VendorAttachmentWhereUniqueInput
    data: XOR<VendorAttachmentUpdateWithoutVendorInput, VendorAttachmentUncheckedUpdateWithoutVendorInput>
  }

  export type VendorAttachmentUpdateManyWithWhereWithoutVendorInput = {
    where: VendorAttachmentScalarWhereInput
    data: XOR<VendorAttachmentUpdateManyMutationInput, VendorAttachmentUncheckedUpdateManyWithoutVendorInput>
  }

  export type VendorAttachmentScalarWhereInput = {
    AND?: VendorAttachmentScalarWhereInput | VendorAttachmentScalarWhereInput[]
    OR?: VendorAttachmentScalarWhereInput[]
    NOT?: VendorAttachmentScalarWhereInput | VendorAttachmentScalarWhereInput[]
    id?: StringFilter<"VendorAttachment"> | string
    vendorId?: StringFilter<"VendorAttachment"> | string
    attachmentId?: StringFilter<"VendorAttachment"> | string
    createdAt?: DateTimeFilter<"VendorAttachment"> | Date | string
    updatedAt?: DateTimeFilter<"VendorAttachment"> | Date | string
  }

  export type VendorGateUpsertWithWhereUniqueWithoutVendorInput = {
    where: VendorGateWhereUniqueInput
    update: XOR<VendorGateUpdateWithoutVendorInput, VendorGateUncheckedUpdateWithoutVendorInput>
    create: XOR<VendorGateCreateWithoutVendorInput, VendorGateUncheckedCreateWithoutVendorInput>
  }

  export type VendorGateUpdateWithWhereUniqueWithoutVendorInput = {
    where: VendorGateWhereUniqueInput
    data: XOR<VendorGateUpdateWithoutVendorInput, VendorGateUncheckedUpdateWithoutVendorInput>
  }

  export type VendorGateUpdateManyWithWhereWithoutVendorInput = {
    where: VendorGateScalarWhereInput
    data: XOR<VendorGateUpdateManyMutationInput, VendorGateUncheckedUpdateManyWithoutVendorInput>
  }

  export type VendorGateScalarWhereInput = {
    AND?: VendorGateScalarWhereInput | VendorGateScalarWhereInput[]
    OR?: VendorGateScalarWhereInput[]
    NOT?: VendorGateScalarWhereInput | VendorGateScalarWhereInput[]
    id?: StringFilter<"VendorGate"> | string
    vendorId?: StringFilter<"VendorGate"> | string
    gateId?: StringFilter<"VendorGate"> | string
    createdAt?: DateTimeFilter<"VendorGate"> | Date | string
  }

  export type VendorZoneUpsertWithWhereUniqueWithoutVendorInput = {
    where: VendorZoneWhereUniqueInput
    update: XOR<VendorZoneUpdateWithoutVendorInput, VendorZoneUncheckedUpdateWithoutVendorInput>
    create: XOR<VendorZoneCreateWithoutVendorInput, VendorZoneUncheckedCreateWithoutVendorInput>
  }

  export type VendorZoneUpdateWithWhereUniqueWithoutVendorInput = {
    where: VendorZoneWhereUniqueInput
    data: XOR<VendorZoneUpdateWithoutVendorInput, VendorZoneUncheckedUpdateWithoutVendorInput>
  }

  export type VendorZoneUpdateManyWithWhereWithoutVendorInput = {
    where: VendorZoneScalarWhereInput
    data: XOR<VendorZoneUpdateManyMutationInput, VendorZoneUncheckedUpdateManyWithoutVendorInput>
  }

  export type VendorZoneScalarWhereInput = {
    AND?: VendorZoneScalarWhereInput | VendorZoneScalarWhereInput[]
    OR?: VendorZoneScalarWhereInput[]
    NOT?: VendorZoneScalarWhereInput | VendorZoneScalarWhereInput[]
    id?: StringFilter<"VendorZone"> | string
    vendorId?: StringFilter<"VendorZone"> | string
    zoneId?: StringFilter<"VendorZone"> | string
    createdAt?: DateTimeFilter<"VendorZone"> | Date | string
  }

  export type VendorZoneCreateWithoutZoneInput = {
    id?: string
    createdAt?: Date | string
    vendor: VendorCreateNestedOneWithoutZonesInput
  }

  export type VendorZoneUncheckedCreateWithoutZoneInput = {
    id?: string
    vendorId: string
    createdAt?: Date | string
  }

  export type VendorZoneCreateOrConnectWithoutZoneInput = {
    where: VendorZoneWhereUniqueInput
    create: XOR<VendorZoneCreateWithoutZoneInput, VendorZoneUncheckedCreateWithoutZoneInput>
  }

  export type VendorZoneCreateManyZoneInputEnvelope = {
    data: VendorZoneCreateManyZoneInput | VendorZoneCreateManyZoneInput[]
    skipDuplicates?: boolean
  }

  export type EmployeeZoneCreateWithoutZoneInput = {
    id?: string
    createdAt?: Date | string
    employee: EmployeeCreateNestedOneWithoutZonesInput
  }

  export type EmployeeZoneUncheckedCreateWithoutZoneInput = {
    id?: string
    employeeId: string
    createdAt?: Date | string
  }

  export type EmployeeZoneCreateOrConnectWithoutZoneInput = {
    where: EmployeeZoneWhereUniqueInput
    create: XOR<EmployeeZoneCreateWithoutZoneInput, EmployeeZoneUncheckedCreateWithoutZoneInput>
  }

  export type EmployeeZoneCreateManyZoneInputEnvelope = {
    data: EmployeeZoneCreateManyZoneInput | EmployeeZoneCreateManyZoneInput[]
    skipDuplicates?: boolean
  }

  export type VendorZoneUpsertWithWhereUniqueWithoutZoneInput = {
    where: VendorZoneWhereUniqueInput
    update: XOR<VendorZoneUpdateWithoutZoneInput, VendorZoneUncheckedUpdateWithoutZoneInput>
    create: XOR<VendorZoneCreateWithoutZoneInput, VendorZoneUncheckedCreateWithoutZoneInput>
  }

  export type VendorZoneUpdateWithWhereUniqueWithoutZoneInput = {
    where: VendorZoneWhereUniqueInput
    data: XOR<VendorZoneUpdateWithoutZoneInput, VendorZoneUncheckedUpdateWithoutZoneInput>
  }

  export type VendorZoneUpdateManyWithWhereWithoutZoneInput = {
    where: VendorZoneScalarWhereInput
    data: XOR<VendorZoneUpdateManyMutationInput, VendorZoneUncheckedUpdateManyWithoutZoneInput>
  }

  export type EmployeeZoneUpsertWithWhereUniqueWithoutZoneInput = {
    where: EmployeeZoneWhereUniqueInput
    update: XOR<EmployeeZoneUpdateWithoutZoneInput, EmployeeZoneUncheckedUpdateWithoutZoneInput>
    create: XOR<EmployeeZoneCreateWithoutZoneInput, EmployeeZoneUncheckedCreateWithoutZoneInput>
  }

  export type EmployeeZoneUpdateWithWhereUniqueWithoutZoneInput = {
    where: EmployeeZoneWhereUniqueInput
    data: XOR<EmployeeZoneUpdateWithoutZoneInput, EmployeeZoneUncheckedUpdateWithoutZoneInput>
  }

  export type EmployeeZoneUpdateManyWithWhereWithoutZoneInput = {
    where: EmployeeZoneScalarWhereInput
    data: XOR<EmployeeZoneUpdateManyMutationInput, EmployeeZoneUncheckedUpdateManyWithoutZoneInput>
  }

  export type EmployeeZoneScalarWhereInput = {
    AND?: EmployeeZoneScalarWhereInput | EmployeeZoneScalarWhereInput[]
    OR?: EmployeeZoneScalarWhereInput[]
    NOT?: EmployeeZoneScalarWhereInput | EmployeeZoneScalarWhereInput[]
    id?: StringFilter<"EmployeeZone"> | string
    employeeId?: StringFilter<"EmployeeZone"> | string
    zoneId?: StringFilter<"EmployeeZone"> | string
    createdAt?: DateTimeFilter<"EmployeeZone"> | Date | string
  }

  export type VendorGateCreateWithoutGateInput = {
    id?: string
    createdAt?: Date | string
    vendor: VendorCreateNestedOneWithoutGatesInput
  }

  export type VendorGateUncheckedCreateWithoutGateInput = {
    id?: string
    vendorId: string
    createdAt?: Date | string
  }

  export type VendorGateCreateOrConnectWithoutGateInput = {
    where: VendorGateWhereUniqueInput
    create: XOR<VendorGateCreateWithoutGateInput, VendorGateUncheckedCreateWithoutGateInput>
  }

  export type VendorGateCreateManyGateInputEnvelope = {
    data: VendorGateCreateManyGateInput | VendorGateCreateManyGateInput[]
    skipDuplicates?: boolean
  }

  export type EmployeeGateCreateWithoutGateInput = {
    id?: string
    createdAt?: Date | string
    employee: EmployeeCreateNestedOneWithoutGatesInput
  }

  export type EmployeeGateUncheckedCreateWithoutGateInput = {
    id?: string
    employeeId: string
    createdAt?: Date | string
  }

  export type EmployeeGateCreateOrConnectWithoutGateInput = {
    where: EmployeeGateWhereUniqueInput
    create: XOR<EmployeeGateCreateWithoutGateInput, EmployeeGateUncheckedCreateWithoutGateInput>
  }

  export type EmployeeGateCreateManyGateInputEnvelope = {
    data: EmployeeGateCreateManyGateInput | EmployeeGateCreateManyGateInput[]
    skipDuplicates?: boolean
  }

  export type ActivityCreateWithoutGateInput = {
    id?: string
    type?: $Enums.ActivityType
    status: $Enums.AccessStatus
    denialReason?: string | null
    scannedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    employee: EmployeeCreateNestedOneWithoutActivitiesInput
    scanner?: UserCreateNestedOneWithoutActivitiesInput
    alerts?: AlertCreateNestedManyWithoutActivityInput
  }

  export type ActivityUncheckedCreateWithoutGateInput = {
    id?: string
    type?: $Enums.ActivityType
    status: $Enums.AccessStatus
    denialReason?: string | null
    scannedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    employeeId: string
    scannerId?: string | null
    alerts?: AlertUncheckedCreateNestedManyWithoutActivityInput
  }

  export type ActivityCreateOrConnectWithoutGateInput = {
    where: ActivityWhereUniqueInput
    create: XOR<ActivityCreateWithoutGateInput, ActivityUncheckedCreateWithoutGateInput>
  }

  export type ActivityCreateManyGateInputEnvelope = {
    data: ActivityCreateManyGateInput | ActivityCreateManyGateInput[]
    skipDuplicates?: boolean
  }

  export type VendorGateUpsertWithWhereUniqueWithoutGateInput = {
    where: VendorGateWhereUniqueInput
    update: XOR<VendorGateUpdateWithoutGateInput, VendorGateUncheckedUpdateWithoutGateInput>
    create: XOR<VendorGateCreateWithoutGateInput, VendorGateUncheckedCreateWithoutGateInput>
  }

  export type VendorGateUpdateWithWhereUniqueWithoutGateInput = {
    where: VendorGateWhereUniqueInput
    data: XOR<VendorGateUpdateWithoutGateInput, VendorGateUncheckedUpdateWithoutGateInput>
  }

  export type VendorGateUpdateManyWithWhereWithoutGateInput = {
    where: VendorGateScalarWhereInput
    data: XOR<VendorGateUpdateManyMutationInput, VendorGateUncheckedUpdateManyWithoutGateInput>
  }

  export type EmployeeGateUpsertWithWhereUniqueWithoutGateInput = {
    where: EmployeeGateWhereUniqueInput
    update: XOR<EmployeeGateUpdateWithoutGateInput, EmployeeGateUncheckedUpdateWithoutGateInput>
    create: XOR<EmployeeGateCreateWithoutGateInput, EmployeeGateUncheckedCreateWithoutGateInput>
  }

  export type EmployeeGateUpdateWithWhereUniqueWithoutGateInput = {
    where: EmployeeGateWhereUniqueInput
    data: XOR<EmployeeGateUpdateWithoutGateInput, EmployeeGateUncheckedUpdateWithoutGateInput>
  }

  export type EmployeeGateUpdateManyWithWhereWithoutGateInput = {
    where: EmployeeGateScalarWhereInput
    data: XOR<EmployeeGateUpdateManyMutationInput, EmployeeGateUncheckedUpdateManyWithoutGateInput>
  }

  export type EmployeeGateScalarWhereInput = {
    AND?: EmployeeGateScalarWhereInput | EmployeeGateScalarWhereInput[]
    OR?: EmployeeGateScalarWhereInput[]
    NOT?: EmployeeGateScalarWhereInput | EmployeeGateScalarWhereInput[]
    id?: StringFilter<"EmployeeGate"> | string
    employeeId?: StringFilter<"EmployeeGate"> | string
    gateId?: StringFilter<"EmployeeGate"> | string
    createdAt?: DateTimeFilter<"EmployeeGate"> | Date | string
  }

  export type ActivityUpsertWithWhereUniqueWithoutGateInput = {
    where: ActivityWhereUniqueInput
    update: XOR<ActivityUpdateWithoutGateInput, ActivityUncheckedUpdateWithoutGateInput>
    create: XOR<ActivityCreateWithoutGateInput, ActivityUncheckedCreateWithoutGateInput>
  }

  export type ActivityUpdateWithWhereUniqueWithoutGateInput = {
    where: ActivityWhereUniqueInput
    data: XOR<ActivityUpdateWithoutGateInput, ActivityUncheckedUpdateWithoutGateInput>
  }

  export type ActivityUpdateManyWithWhereWithoutGateInput = {
    where: ActivityScalarWhereInput
    data: XOR<ActivityUpdateManyMutationInput, ActivityUncheckedUpdateManyWithoutGateInput>
  }

  export type EmployeePermissionCreateWithoutPermissionInput = {
    id?: string
    grantedAt?: Date | string
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    employee: EmployeeCreateNestedOneWithoutEmployeePermissionsInput
  }

  export type EmployeePermissionUncheckedCreateWithoutPermissionInput = {
    id?: string
    employeeId: string
    grantedAt?: Date | string
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmployeePermissionCreateOrConnectWithoutPermissionInput = {
    where: EmployeePermissionWhereUniqueInput
    create: XOR<EmployeePermissionCreateWithoutPermissionInput, EmployeePermissionUncheckedCreateWithoutPermissionInput>
  }

  export type EmployeePermissionCreateManyPermissionInputEnvelope = {
    data: EmployeePermissionCreateManyPermissionInput | EmployeePermissionCreateManyPermissionInput[]
    skipDuplicates?: boolean
  }

  export type EmployeePermissionUpsertWithWhereUniqueWithoutPermissionInput = {
    where: EmployeePermissionWhereUniqueInput
    update: XOR<EmployeePermissionUpdateWithoutPermissionInput, EmployeePermissionUncheckedUpdateWithoutPermissionInput>
    create: XOR<EmployeePermissionCreateWithoutPermissionInput, EmployeePermissionUncheckedCreateWithoutPermissionInput>
  }

  export type EmployeePermissionUpdateWithWhereUniqueWithoutPermissionInput = {
    where: EmployeePermissionWhereUniqueInput
    data: XOR<EmployeePermissionUpdateWithoutPermissionInput, EmployeePermissionUncheckedUpdateWithoutPermissionInput>
  }

  export type EmployeePermissionUpdateManyWithWhereWithoutPermissionInput = {
    where: EmployeePermissionScalarWhereInput
    data: XOR<EmployeePermissionUpdateManyMutationInput, EmployeePermissionUncheckedUpdateManyWithoutPermissionInput>
  }

  export type EmployeePermissionScalarWhereInput = {
    AND?: EmployeePermissionScalarWhereInput | EmployeePermissionScalarWhereInput[]
    OR?: EmployeePermissionScalarWhereInput[]
    NOT?: EmployeePermissionScalarWhereInput | EmployeePermissionScalarWhereInput[]
    id?: StringFilter<"EmployeePermission"> | string
    employeeId?: StringFilter<"EmployeePermission"> | string
    permissionId?: StringFilter<"EmployeePermission"> | string
    grantedAt?: DateTimeFilter<"EmployeePermission"> | Date | string
    expiresAt?: DateTimeNullableFilter<"EmployeePermission"> | Date | string | null
    createdAt?: DateTimeFilter<"EmployeePermission"> | Date | string
    updatedAt?: DateTimeFilter<"EmployeePermission"> | Date | string
  }

  export type VendorCreateWithoutEmployeesInput = {
    id?: string
    name: string
    description?: string | null
    phoneNumber?: string | null
    allowedStaffCount: number
    accessToken?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    vendorAttachments?: VendorAttachmentCreateNestedManyWithoutVendorInput
    gates?: VendorGateCreateNestedManyWithoutVendorInput
    zones?: VendorZoneCreateNestedManyWithoutVendorInput
  }

  export type VendorUncheckedCreateWithoutEmployeesInput = {
    id?: string
    name: string
    description?: string | null
    phoneNumber?: string | null
    allowedStaffCount: number
    accessToken?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    vendorAttachments?: VendorAttachmentUncheckedCreateNestedManyWithoutVendorInput
    gates?: VendorGateUncheckedCreateNestedManyWithoutVendorInput
    zones?: VendorZoneUncheckedCreateNestedManyWithoutVendorInput
  }

  export type VendorCreateOrConnectWithoutEmployeesInput = {
    where: VendorWhereUniqueInput
    create: XOR<VendorCreateWithoutEmployeesInput, VendorUncheckedCreateWithoutEmployeesInput>
  }

  export type EmployeeGateCreateWithoutEmployeeInput = {
    id?: string
    createdAt?: Date | string
    gate: GateCreateNestedOneWithoutEmployeesInput
  }

  export type EmployeeGateUncheckedCreateWithoutEmployeeInput = {
    id?: string
    gateId: string
    createdAt?: Date | string
  }

  export type EmployeeGateCreateOrConnectWithoutEmployeeInput = {
    where: EmployeeGateWhereUniqueInput
    create: XOR<EmployeeGateCreateWithoutEmployeeInput, EmployeeGateUncheckedCreateWithoutEmployeeInput>
  }

  export type EmployeeGateCreateManyEmployeeInputEnvelope = {
    data: EmployeeGateCreateManyEmployeeInput | EmployeeGateCreateManyEmployeeInput[]
    skipDuplicates?: boolean
  }

  export type EmployeeZoneCreateWithoutEmployeeInput = {
    id?: string
    createdAt?: Date | string
    zone: ZoneCreateNestedOneWithoutEmployeesInput
  }

  export type EmployeeZoneUncheckedCreateWithoutEmployeeInput = {
    id?: string
    zoneId: string
    createdAt?: Date | string
  }

  export type EmployeeZoneCreateOrConnectWithoutEmployeeInput = {
    where: EmployeeZoneWhereUniqueInput
    create: XOR<EmployeeZoneCreateWithoutEmployeeInput, EmployeeZoneUncheckedCreateWithoutEmployeeInput>
  }

  export type EmployeeZoneCreateManyEmployeeInputEnvelope = {
    data: EmployeeZoneCreateManyEmployeeInput | EmployeeZoneCreateManyEmployeeInput[]
    skipDuplicates?: boolean
  }

  export type ActivityCreateWithoutEmployeeInput = {
    id?: string
    type?: $Enums.ActivityType
    status: $Enums.AccessStatus
    denialReason?: string | null
    scannedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    scanner?: UserCreateNestedOneWithoutActivitiesInput
    gate?: GateCreateNestedOneWithoutActivitiesInput
    alerts?: AlertCreateNestedManyWithoutActivityInput
  }

  export type ActivityUncheckedCreateWithoutEmployeeInput = {
    id?: string
    type?: $Enums.ActivityType
    status: $Enums.AccessStatus
    denialReason?: string | null
    scannedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    scannerId?: string | null
    gateId?: string | null
    alerts?: AlertUncheckedCreateNestedManyWithoutActivityInput
  }

  export type ActivityCreateOrConnectWithoutEmployeeInput = {
    where: ActivityWhereUniqueInput
    create: XOR<ActivityCreateWithoutEmployeeInput, ActivityUncheckedCreateWithoutEmployeeInput>
  }

  export type ActivityCreateManyEmployeeInputEnvelope = {
    data: ActivityCreateManyEmployeeInput | ActivityCreateManyEmployeeInput[]
    skipDuplicates?: boolean
  }

  export type WorkingHoursCreateWithoutEmployeeInput = {
    id?: string
    dayOfWeek: $Enums.DayOfWeek
    startTime: string
    endTime: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkingHoursUncheckedCreateWithoutEmployeeInput = {
    id?: string
    dayOfWeek: $Enums.DayOfWeek
    startTime: string
    endTime: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkingHoursCreateOrConnectWithoutEmployeeInput = {
    where: WorkingHoursWhereUniqueInput
    create: XOR<WorkingHoursCreateWithoutEmployeeInput, WorkingHoursUncheckedCreateWithoutEmployeeInput>
  }

  export type WorkingHoursCreateManyEmployeeInputEnvelope = {
    data: WorkingHoursCreateManyEmployeeInput | WorkingHoursCreateManyEmployeeInput[]
    skipDuplicates?: boolean
  }

  export type EmployeeAttachmentCreateWithoutEmployeeInput = {
    id?: string
    type: $Enums.EmployeeAttachmentType
    createdAt?: Date | string
    updatedAt?: Date | string
    attachment: AttachmentCreateNestedOneWithoutEmployeeAttachmentsInput
  }

  export type EmployeeAttachmentUncheckedCreateWithoutEmployeeInput = {
    id?: string
    type: $Enums.EmployeeAttachmentType
    attachmentId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmployeeAttachmentCreateOrConnectWithoutEmployeeInput = {
    where: EmployeeAttachmentWhereUniqueInput
    create: XOR<EmployeeAttachmentCreateWithoutEmployeeInput, EmployeeAttachmentUncheckedCreateWithoutEmployeeInput>
  }

  export type EmployeeAttachmentCreateManyEmployeeInputEnvelope = {
    data: EmployeeAttachmentCreateManyEmployeeInput | EmployeeAttachmentCreateManyEmployeeInput[]
    skipDuplicates?: boolean
  }

  export type EmployeePermissionCreateWithoutEmployeeInput = {
    id?: string
    grantedAt?: Date | string
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    permission: PermissionCreateNestedOneWithoutEmployeePermissionsInput
  }

  export type EmployeePermissionUncheckedCreateWithoutEmployeeInput = {
    id?: string
    permissionId: string
    grantedAt?: Date | string
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmployeePermissionCreateOrConnectWithoutEmployeeInput = {
    where: EmployeePermissionWhereUniqueInput
    create: XOR<EmployeePermissionCreateWithoutEmployeeInput, EmployeePermissionUncheckedCreateWithoutEmployeeInput>
  }

  export type EmployeePermissionCreateManyEmployeeInputEnvelope = {
    data: EmployeePermissionCreateManyEmployeeInput | EmployeePermissionCreateManyEmployeeInput[]
    skipDuplicates?: boolean
  }

  export type AlertCreateWithoutEmployeeInput = {
    id?: string
    text: string
    severity?: string
    isResolved?: boolean
    resolvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutAlertsInput
    activity?: ActivityCreateNestedOneWithoutAlertsInput
  }

  export type AlertUncheckedCreateWithoutEmployeeInput = {
    id?: string
    text: string
    severity?: string
    isResolved?: boolean
    resolvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userId?: string | null
    activityId?: string | null
  }

  export type AlertCreateOrConnectWithoutEmployeeInput = {
    where: AlertWhereUniqueInput
    create: XOR<AlertCreateWithoutEmployeeInput, AlertUncheckedCreateWithoutEmployeeInput>
  }

  export type AlertCreateManyEmployeeInputEnvelope = {
    data: AlertCreateManyEmployeeInput | AlertCreateManyEmployeeInput[]
    skipDuplicates?: boolean
  }

  export type EmployeeAllowedDateCreateWithoutEmployeeInput = {
    id?: string
    date: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmployeeAllowedDateUncheckedCreateWithoutEmployeeInput = {
    id?: string
    date: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmployeeAllowedDateCreateOrConnectWithoutEmployeeInput = {
    where: EmployeeAllowedDateWhereUniqueInput
    create: XOR<EmployeeAllowedDateCreateWithoutEmployeeInput, EmployeeAllowedDateUncheckedCreateWithoutEmployeeInput>
  }

  export type EmployeeAllowedDateCreateManyEmployeeInputEnvelope = {
    data: EmployeeAllowedDateCreateManyEmployeeInput | EmployeeAllowedDateCreateManyEmployeeInput[]
    skipDuplicates?: boolean
  }

  export type VendorUpsertWithoutEmployeesInput = {
    update: XOR<VendorUpdateWithoutEmployeesInput, VendorUncheckedUpdateWithoutEmployeesInput>
    create: XOR<VendorCreateWithoutEmployeesInput, VendorUncheckedCreateWithoutEmployeesInput>
    where?: VendorWhereInput
  }

  export type VendorUpdateToOneWithWhereWithoutEmployeesInput = {
    where?: VendorWhereInput
    data: XOR<VendorUpdateWithoutEmployeesInput, VendorUncheckedUpdateWithoutEmployeesInput>
  }

  export type VendorUpdateWithoutEmployeesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    allowedStaffCount?: IntFieldUpdateOperationsInput | number
    accessToken?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vendorAttachments?: VendorAttachmentUpdateManyWithoutVendorNestedInput
    gates?: VendorGateUpdateManyWithoutVendorNestedInput
    zones?: VendorZoneUpdateManyWithoutVendorNestedInput
  }

  export type VendorUncheckedUpdateWithoutEmployeesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    allowedStaffCount?: IntFieldUpdateOperationsInput | number
    accessToken?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vendorAttachments?: VendorAttachmentUncheckedUpdateManyWithoutVendorNestedInput
    gates?: VendorGateUncheckedUpdateManyWithoutVendorNestedInput
    zones?: VendorZoneUncheckedUpdateManyWithoutVendorNestedInput
  }

  export type EmployeeGateUpsertWithWhereUniqueWithoutEmployeeInput = {
    where: EmployeeGateWhereUniqueInput
    update: XOR<EmployeeGateUpdateWithoutEmployeeInput, EmployeeGateUncheckedUpdateWithoutEmployeeInput>
    create: XOR<EmployeeGateCreateWithoutEmployeeInput, EmployeeGateUncheckedCreateWithoutEmployeeInput>
  }

  export type EmployeeGateUpdateWithWhereUniqueWithoutEmployeeInput = {
    where: EmployeeGateWhereUniqueInput
    data: XOR<EmployeeGateUpdateWithoutEmployeeInput, EmployeeGateUncheckedUpdateWithoutEmployeeInput>
  }

  export type EmployeeGateUpdateManyWithWhereWithoutEmployeeInput = {
    where: EmployeeGateScalarWhereInput
    data: XOR<EmployeeGateUpdateManyMutationInput, EmployeeGateUncheckedUpdateManyWithoutEmployeeInput>
  }

  export type EmployeeZoneUpsertWithWhereUniqueWithoutEmployeeInput = {
    where: EmployeeZoneWhereUniqueInput
    update: XOR<EmployeeZoneUpdateWithoutEmployeeInput, EmployeeZoneUncheckedUpdateWithoutEmployeeInput>
    create: XOR<EmployeeZoneCreateWithoutEmployeeInput, EmployeeZoneUncheckedCreateWithoutEmployeeInput>
  }

  export type EmployeeZoneUpdateWithWhereUniqueWithoutEmployeeInput = {
    where: EmployeeZoneWhereUniqueInput
    data: XOR<EmployeeZoneUpdateWithoutEmployeeInput, EmployeeZoneUncheckedUpdateWithoutEmployeeInput>
  }

  export type EmployeeZoneUpdateManyWithWhereWithoutEmployeeInput = {
    where: EmployeeZoneScalarWhereInput
    data: XOR<EmployeeZoneUpdateManyMutationInput, EmployeeZoneUncheckedUpdateManyWithoutEmployeeInput>
  }

  export type ActivityUpsertWithWhereUniqueWithoutEmployeeInput = {
    where: ActivityWhereUniqueInput
    update: XOR<ActivityUpdateWithoutEmployeeInput, ActivityUncheckedUpdateWithoutEmployeeInput>
    create: XOR<ActivityCreateWithoutEmployeeInput, ActivityUncheckedCreateWithoutEmployeeInput>
  }

  export type ActivityUpdateWithWhereUniqueWithoutEmployeeInput = {
    where: ActivityWhereUniqueInput
    data: XOR<ActivityUpdateWithoutEmployeeInput, ActivityUncheckedUpdateWithoutEmployeeInput>
  }

  export type ActivityUpdateManyWithWhereWithoutEmployeeInput = {
    where: ActivityScalarWhereInput
    data: XOR<ActivityUpdateManyMutationInput, ActivityUncheckedUpdateManyWithoutEmployeeInput>
  }

  export type WorkingHoursUpsertWithWhereUniqueWithoutEmployeeInput = {
    where: WorkingHoursWhereUniqueInput
    update: XOR<WorkingHoursUpdateWithoutEmployeeInput, WorkingHoursUncheckedUpdateWithoutEmployeeInput>
    create: XOR<WorkingHoursCreateWithoutEmployeeInput, WorkingHoursUncheckedCreateWithoutEmployeeInput>
  }

  export type WorkingHoursUpdateWithWhereUniqueWithoutEmployeeInput = {
    where: WorkingHoursWhereUniqueInput
    data: XOR<WorkingHoursUpdateWithoutEmployeeInput, WorkingHoursUncheckedUpdateWithoutEmployeeInput>
  }

  export type WorkingHoursUpdateManyWithWhereWithoutEmployeeInput = {
    where: WorkingHoursScalarWhereInput
    data: XOR<WorkingHoursUpdateManyMutationInput, WorkingHoursUncheckedUpdateManyWithoutEmployeeInput>
  }

  export type WorkingHoursScalarWhereInput = {
    AND?: WorkingHoursScalarWhereInput | WorkingHoursScalarWhereInput[]
    OR?: WorkingHoursScalarWhereInput[]
    NOT?: WorkingHoursScalarWhereInput | WorkingHoursScalarWhereInput[]
    id?: StringFilter<"WorkingHours"> | string
    dayOfWeek?: EnumDayOfWeekFilter<"WorkingHours"> | $Enums.DayOfWeek
    startTime?: StringFilter<"WorkingHours"> | string
    endTime?: StringFilter<"WorkingHours"> | string
    isActive?: BoolFilter<"WorkingHours"> | boolean
    createdAt?: DateTimeFilter<"WorkingHours"> | Date | string
    updatedAt?: DateTimeFilter<"WorkingHours"> | Date | string
    employeeId?: StringFilter<"WorkingHours"> | string
  }

  export type EmployeeAttachmentUpsertWithWhereUniqueWithoutEmployeeInput = {
    where: EmployeeAttachmentWhereUniqueInput
    update: XOR<EmployeeAttachmentUpdateWithoutEmployeeInput, EmployeeAttachmentUncheckedUpdateWithoutEmployeeInput>
    create: XOR<EmployeeAttachmentCreateWithoutEmployeeInput, EmployeeAttachmentUncheckedCreateWithoutEmployeeInput>
  }

  export type EmployeeAttachmentUpdateWithWhereUniqueWithoutEmployeeInput = {
    where: EmployeeAttachmentWhereUniqueInput
    data: XOR<EmployeeAttachmentUpdateWithoutEmployeeInput, EmployeeAttachmentUncheckedUpdateWithoutEmployeeInput>
  }

  export type EmployeeAttachmentUpdateManyWithWhereWithoutEmployeeInput = {
    where: EmployeeAttachmentScalarWhereInput
    data: XOR<EmployeeAttachmentUpdateManyMutationInput, EmployeeAttachmentUncheckedUpdateManyWithoutEmployeeInput>
  }

  export type EmployeeAttachmentScalarWhereInput = {
    AND?: EmployeeAttachmentScalarWhereInput | EmployeeAttachmentScalarWhereInput[]
    OR?: EmployeeAttachmentScalarWhereInput[]
    NOT?: EmployeeAttachmentScalarWhereInput | EmployeeAttachmentScalarWhereInput[]
    id?: StringFilter<"EmployeeAttachment"> | string
    type?: EnumEmployeeAttachmentTypeFilter<"EmployeeAttachment"> | $Enums.EmployeeAttachmentType
    employeeId?: StringFilter<"EmployeeAttachment"> | string
    attachmentId?: StringFilter<"EmployeeAttachment"> | string
    createdAt?: DateTimeFilter<"EmployeeAttachment"> | Date | string
    updatedAt?: DateTimeFilter<"EmployeeAttachment"> | Date | string
  }

  export type EmployeePermissionUpsertWithWhereUniqueWithoutEmployeeInput = {
    where: EmployeePermissionWhereUniqueInput
    update: XOR<EmployeePermissionUpdateWithoutEmployeeInput, EmployeePermissionUncheckedUpdateWithoutEmployeeInput>
    create: XOR<EmployeePermissionCreateWithoutEmployeeInput, EmployeePermissionUncheckedCreateWithoutEmployeeInput>
  }

  export type EmployeePermissionUpdateWithWhereUniqueWithoutEmployeeInput = {
    where: EmployeePermissionWhereUniqueInput
    data: XOR<EmployeePermissionUpdateWithoutEmployeeInput, EmployeePermissionUncheckedUpdateWithoutEmployeeInput>
  }

  export type EmployeePermissionUpdateManyWithWhereWithoutEmployeeInput = {
    where: EmployeePermissionScalarWhereInput
    data: XOR<EmployeePermissionUpdateManyMutationInput, EmployeePermissionUncheckedUpdateManyWithoutEmployeeInput>
  }

  export type AlertUpsertWithWhereUniqueWithoutEmployeeInput = {
    where: AlertWhereUniqueInput
    update: XOR<AlertUpdateWithoutEmployeeInput, AlertUncheckedUpdateWithoutEmployeeInput>
    create: XOR<AlertCreateWithoutEmployeeInput, AlertUncheckedCreateWithoutEmployeeInput>
  }

  export type AlertUpdateWithWhereUniqueWithoutEmployeeInput = {
    where: AlertWhereUniqueInput
    data: XOR<AlertUpdateWithoutEmployeeInput, AlertUncheckedUpdateWithoutEmployeeInput>
  }

  export type AlertUpdateManyWithWhereWithoutEmployeeInput = {
    where: AlertScalarWhereInput
    data: XOR<AlertUpdateManyMutationInput, AlertUncheckedUpdateManyWithoutEmployeeInput>
  }

  export type EmployeeAllowedDateUpsertWithWhereUniqueWithoutEmployeeInput = {
    where: EmployeeAllowedDateWhereUniqueInput
    update: XOR<EmployeeAllowedDateUpdateWithoutEmployeeInput, EmployeeAllowedDateUncheckedUpdateWithoutEmployeeInput>
    create: XOR<EmployeeAllowedDateCreateWithoutEmployeeInput, EmployeeAllowedDateUncheckedCreateWithoutEmployeeInput>
  }

  export type EmployeeAllowedDateUpdateWithWhereUniqueWithoutEmployeeInput = {
    where: EmployeeAllowedDateWhereUniqueInput
    data: XOR<EmployeeAllowedDateUpdateWithoutEmployeeInput, EmployeeAllowedDateUncheckedUpdateWithoutEmployeeInput>
  }

  export type EmployeeAllowedDateUpdateManyWithWhereWithoutEmployeeInput = {
    where: EmployeeAllowedDateScalarWhereInput
    data: XOR<EmployeeAllowedDateUpdateManyMutationInput, EmployeeAllowedDateUncheckedUpdateManyWithoutEmployeeInput>
  }

  export type EmployeeAllowedDateScalarWhereInput = {
    AND?: EmployeeAllowedDateScalarWhereInput | EmployeeAllowedDateScalarWhereInput[]
    OR?: EmployeeAllowedDateScalarWhereInput[]
    NOT?: EmployeeAllowedDateScalarWhereInput | EmployeeAllowedDateScalarWhereInput[]
    id?: StringFilter<"EmployeeAllowedDate"> | string
    employeeId?: StringFilter<"EmployeeAllowedDate"> | string
    date?: DateTimeFilter<"EmployeeAllowedDate"> | Date | string
    createdAt?: DateTimeFilter<"EmployeeAllowedDate"> | Date | string
    updatedAt?: DateTimeFilter<"EmployeeAllowedDate"> | Date | string
  }

  export type EmployeeCreateWithoutWorkingHoursInput = {
    id?: string
    identifier?: string
    name: string
    job: string
    nationalId: string
    version?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    status?: $Enums.EmployeeStatus
    vendor: VendorCreateNestedOneWithoutEmployeesInput
    gates?: EmployeeGateCreateNestedManyWithoutEmployeeInput
    zones?: EmployeeZoneCreateNestedManyWithoutEmployeeInput
    activities?: ActivityCreateNestedManyWithoutEmployeeInput
    employeeAttachments?: EmployeeAttachmentCreateNestedManyWithoutEmployeeInput
    employeePermissions?: EmployeePermissionCreateNestedManyWithoutEmployeeInput
    alerts?: AlertCreateNestedManyWithoutEmployeeInput
    allowedDates?: EmployeeAllowedDateCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutWorkingHoursInput = {
    id?: string
    identifier?: string
    name: string
    job: string
    nationalId: string
    version?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    status?: $Enums.EmployeeStatus
    vendorId: string
    gates?: EmployeeGateUncheckedCreateNestedManyWithoutEmployeeInput
    zones?: EmployeeZoneUncheckedCreateNestedManyWithoutEmployeeInput
    activities?: ActivityUncheckedCreateNestedManyWithoutEmployeeInput
    employeeAttachments?: EmployeeAttachmentUncheckedCreateNestedManyWithoutEmployeeInput
    employeePermissions?: EmployeePermissionUncheckedCreateNestedManyWithoutEmployeeInput
    alerts?: AlertUncheckedCreateNestedManyWithoutEmployeeInput
    allowedDates?: EmployeeAllowedDateUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeCreateOrConnectWithoutWorkingHoursInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutWorkingHoursInput, EmployeeUncheckedCreateWithoutWorkingHoursInput>
  }

  export type EmployeeUpsertWithoutWorkingHoursInput = {
    update: XOR<EmployeeUpdateWithoutWorkingHoursInput, EmployeeUncheckedUpdateWithoutWorkingHoursInput>
    create: XOR<EmployeeCreateWithoutWorkingHoursInput, EmployeeUncheckedCreateWithoutWorkingHoursInput>
    where?: EmployeeWhereInput
  }

  export type EmployeeUpdateToOneWithWhereWithoutWorkingHoursInput = {
    where?: EmployeeWhereInput
    data: XOR<EmployeeUpdateWithoutWorkingHoursInput, EmployeeUncheckedUpdateWithoutWorkingHoursInput>
  }

  export type EmployeeUpdateWithoutWorkingHoursInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    job?: StringFieldUpdateOperationsInput | string
    nationalId?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumEmployeeStatusFieldUpdateOperationsInput | $Enums.EmployeeStatus
    vendor?: VendorUpdateOneRequiredWithoutEmployeesNestedInput
    gates?: EmployeeGateUpdateManyWithoutEmployeeNestedInput
    zones?: EmployeeZoneUpdateManyWithoutEmployeeNestedInput
    activities?: ActivityUpdateManyWithoutEmployeeNestedInput
    employeeAttachments?: EmployeeAttachmentUpdateManyWithoutEmployeeNestedInput
    employeePermissions?: EmployeePermissionUpdateManyWithoutEmployeeNestedInput
    alerts?: AlertUpdateManyWithoutEmployeeNestedInput
    allowedDates?: EmployeeAllowedDateUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutWorkingHoursInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    job?: StringFieldUpdateOperationsInput | string
    nationalId?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumEmployeeStatusFieldUpdateOperationsInput | $Enums.EmployeeStatus
    vendorId?: StringFieldUpdateOperationsInput | string
    gates?: EmployeeGateUncheckedUpdateManyWithoutEmployeeNestedInput
    zones?: EmployeeZoneUncheckedUpdateManyWithoutEmployeeNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutEmployeeNestedInput
    employeeAttachments?: EmployeeAttachmentUncheckedUpdateManyWithoutEmployeeNestedInput
    employeePermissions?: EmployeePermissionUncheckedUpdateManyWithoutEmployeeNestedInput
    alerts?: AlertUncheckedUpdateManyWithoutEmployeeNestedInput
    allowedDates?: EmployeeAllowedDateUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeCreateWithoutAlertsInput = {
    id?: string
    identifier?: string
    name: string
    job: string
    nationalId: string
    version?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    status?: $Enums.EmployeeStatus
    vendor: VendorCreateNestedOneWithoutEmployeesInput
    gates?: EmployeeGateCreateNestedManyWithoutEmployeeInput
    zones?: EmployeeZoneCreateNestedManyWithoutEmployeeInput
    activities?: ActivityCreateNestedManyWithoutEmployeeInput
    workingHours?: WorkingHoursCreateNestedManyWithoutEmployeeInput
    employeeAttachments?: EmployeeAttachmentCreateNestedManyWithoutEmployeeInput
    employeePermissions?: EmployeePermissionCreateNestedManyWithoutEmployeeInput
    allowedDates?: EmployeeAllowedDateCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutAlertsInput = {
    id?: string
    identifier?: string
    name: string
    job: string
    nationalId: string
    version?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    status?: $Enums.EmployeeStatus
    vendorId: string
    gates?: EmployeeGateUncheckedCreateNestedManyWithoutEmployeeInput
    zones?: EmployeeZoneUncheckedCreateNestedManyWithoutEmployeeInput
    activities?: ActivityUncheckedCreateNestedManyWithoutEmployeeInput
    workingHours?: WorkingHoursUncheckedCreateNestedManyWithoutEmployeeInput
    employeeAttachments?: EmployeeAttachmentUncheckedCreateNestedManyWithoutEmployeeInput
    employeePermissions?: EmployeePermissionUncheckedCreateNestedManyWithoutEmployeeInput
    allowedDates?: EmployeeAllowedDateUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeCreateOrConnectWithoutAlertsInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutAlertsInput, EmployeeUncheckedCreateWithoutAlertsInput>
  }

  export type UserCreateWithoutAlertsInput = {
    id?: string
    name?: string | null
    username?: string | null
    email?: string | null
    role: $Enums.Role
    password?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    activities?: ActivityCreateNestedManyWithoutScannerInput
  }

  export type UserUncheckedCreateWithoutAlertsInput = {
    id?: string
    name?: string | null
    username?: string | null
    email?: string | null
    role: $Enums.Role
    password?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    activities?: ActivityUncheckedCreateNestedManyWithoutScannerInput
  }

  export type UserCreateOrConnectWithoutAlertsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAlertsInput, UserUncheckedCreateWithoutAlertsInput>
  }

  export type ActivityCreateWithoutAlertsInput = {
    id?: string
    type?: $Enums.ActivityType
    status: $Enums.AccessStatus
    denialReason?: string | null
    scannedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    employee: EmployeeCreateNestedOneWithoutActivitiesInput
    scanner?: UserCreateNestedOneWithoutActivitiesInput
    gate?: GateCreateNestedOneWithoutActivitiesInput
  }

  export type ActivityUncheckedCreateWithoutAlertsInput = {
    id?: string
    type?: $Enums.ActivityType
    status: $Enums.AccessStatus
    denialReason?: string | null
    scannedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    employeeId: string
    scannerId?: string | null
    gateId?: string | null
  }

  export type ActivityCreateOrConnectWithoutAlertsInput = {
    where: ActivityWhereUniqueInput
    create: XOR<ActivityCreateWithoutAlertsInput, ActivityUncheckedCreateWithoutAlertsInput>
  }

  export type EmployeeUpsertWithoutAlertsInput = {
    update: XOR<EmployeeUpdateWithoutAlertsInput, EmployeeUncheckedUpdateWithoutAlertsInput>
    create: XOR<EmployeeCreateWithoutAlertsInput, EmployeeUncheckedCreateWithoutAlertsInput>
    where?: EmployeeWhereInput
  }

  export type EmployeeUpdateToOneWithWhereWithoutAlertsInput = {
    where?: EmployeeWhereInput
    data: XOR<EmployeeUpdateWithoutAlertsInput, EmployeeUncheckedUpdateWithoutAlertsInput>
  }

  export type EmployeeUpdateWithoutAlertsInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    job?: StringFieldUpdateOperationsInput | string
    nationalId?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumEmployeeStatusFieldUpdateOperationsInput | $Enums.EmployeeStatus
    vendor?: VendorUpdateOneRequiredWithoutEmployeesNestedInput
    gates?: EmployeeGateUpdateManyWithoutEmployeeNestedInput
    zones?: EmployeeZoneUpdateManyWithoutEmployeeNestedInput
    activities?: ActivityUpdateManyWithoutEmployeeNestedInput
    workingHours?: WorkingHoursUpdateManyWithoutEmployeeNestedInput
    employeeAttachments?: EmployeeAttachmentUpdateManyWithoutEmployeeNestedInput
    employeePermissions?: EmployeePermissionUpdateManyWithoutEmployeeNestedInput
    allowedDates?: EmployeeAllowedDateUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutAlertsInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    job?: StringFieldUpdateOperationsInput | string
    nationalId?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumEmployeeStatusFieldUpdateOperationsInput | $Enums.EmployeeStatus
    vendorId?: StringFieldUpdateOperationsInput | string
    gates?: EmployeeGateUncheckedUpdateManyWithoutEmployeeNestedInput
    zones?: EmployeeZoneUncheckedUpdateManyWithoutEmployeeNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutEmployeeNestedInput
    workingHours?: WorkingHoursUncheckedUpdateManyWithoutEmployeeNestedInput
    employeeAttachments?: EmployeeAttachmentUncheckedUpdateManyWithoutEmployeeNestedInput
    employeePermissions?: EmployeePermissionUncheckedUpdateManyWithoutEmployeeNestedInput
    allowedDates?: EmployeeAllowedDateUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type UserUpsertWithoutAlertsInput = {
    update: XOR<UserUpdateWithoutAlertsInput, UserUncheckedUpdateWithoutAlertsInput>
    create: XOR<UserCreateWithoutAlertsInput, UserUncheckedCreateWithoutAlertsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAlertsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAlertsInput, UserUncheckedUpdateWithoutAlertsInput>
  }

  export type UserUpdateWithoutAlertsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    password?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activities?: ActivityUpdateManyWithoutScannerNestedInput
  }

  export type UserUncheckedUpdateWithoutAlertsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    password?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activities?: ActivityUncheckedUpdateManyWithoutScannerNestedInput
  }

  export type ActivityUpsertWithoutAlertsInput = {
    update: XOR<ActivityUpdateWithoutAlertsInput, ActivityUncheckedUpdateWithoutAlertsInput>
    create: XOR<ActivityCreateWithoutAlertsInput, ActivityUncheckedCreateWithoutAlertsInput>
    where?: ActivityWhereInput
  }

  export type ActivityUpdateToOneWithWhereWithoutAlertsInput = {
    where?: ActivityWhereInput
    data: XOR<ActivityUpdateWithoutAlertsInput, ActivityUncheckedUpdateWithoutAlertsInput>
  }

  export type ActivityUpdateWithoutAlertsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    status?: EnumAccessStatusFieldUpdateOperationsInput | $Enums.AccessStatus
    denialReason?: NullableStringFieldUpdateOperationsInput | string | null
    scannedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: EmployeeUpdateOneRequiredWithoutActivitiesNestedInput
    scanner?: UserUpdateOneWithoutActivitiesNestedInput
    gate?: GateUpdateOneWithoutActivitiesNestedInput
  }

  export type ActivityUncheckedUpdateWithoutAlertsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    status?: EnumAccessStatusFieldUpdateOperationsInput | $Enums.AccessStatus
    denialReason?: NullableStringFieldUpdateOperationsInput | string | null
    scannedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employeeId?: StringFieldUpdateOperationsInput | string
    scannerId?: NullableStringFieldUpdateOperationsInput | string | null
    gateId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EmployeeCreateWithoutActivitiesInput = {
    id?: string
    identifier?: string
    name: string
    job: string
    nationalId: string
    version?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    status?: $Enums.EmployeeStatus
    vendor: VendorCreateNestedOneWithoutEmployeesInput
    gates?: EmployeeGateCreateNestedManyWithoutEmployeeInput
    zones?: EmployeeZoneCreateNestedManyWithoutEmployeeInput
    workingHours?: WorkingHoursCreateNestedManyWithoutEmployeeInput
    employeeAttachments?: EmployeeAttachmentCreateNestedManyWithoutEmployeeInput
    employeePermissions?: EmployeePermissionCreateNestedManyWithoutEmployeeInput
    alerts?: AlertCreateNestedManyWithoutEmployeeInput
    allowedDates?: EmployeeAllowedDateCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutActivitiesInput = {
    id?: string
    identifier?: string
    name: string
    job: string
    nationalId: string
    version?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    status?: $Enums.EmployeeStatus
    vendorId: string
    gates?: EmployeeGateUncheckedCreateNestedManyWithoutEmployeeInput
    zones?: EmployeeZoneUncheckedCreateNestedManyWithoutEmployeeInput
    workingHours?: WorkingHoursUncheckedCreateNestedManyWithoutEmployeeInput
    employeeAttachments?: EmployeeAttachmentUncheckedCreateNestedManyWithoutEmployeeInput
    employeePermissions?: EmployeePermissionUncheckedCreateNestedManyWithoutEmployeeInput
    alerts?: AlertUncheckedCreateNestedManyWithoutEmployeeInput
    allowedDates?: EmployeeAllowedDateUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeCreateOrConnectWithoutActivitiesInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutActivitiesInput, EmployeeUncheckedCreateWithoutActivitiesInput>
  }

  export type UserCreateWithoutActivitiesInput = {
    id?: string
    name?: string | null
    username?: string | null
    email?: string | null
    role: $Enums.Role
    password?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    alerts?: AlertCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutActivitiesInput = {
    id?: string
    name?: string | null
    username?: string | null
    email?: string | null
    role: $Enums.Role
    password?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    alerts?: AlertUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutActivitiesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutActivitiesInput, UserUncheckedCreateWithoutActivitiesInput>
  }

  export type GateCreateWithoutActivitiesInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    vendors?: VendorGateCreateNestedManyWithoutGateInput
    employees?: EmployeeGateCreateNestedManyWithoutGateInput
  }

  export type GateUncheckedCreateWithoutActivitiesInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    vendors?: VendorGateUncheckedCreateNestedManyWithoutGateInput
    employees?: EmployeeGateUncheckedCreateNestedManyWithoutGateInput
  }

  export type GateCreateOrConnectWithoutActivitiesInput = {
    where: GateWhereUniqueInput
    create: XOR<GateCreateWithoutActivitiesInput, GateUncheckedCreateWithoutActivitiesInput>
  }

  export type AlertCreateWithoutActivityInput = {
    id?: string
    text: string
    severity?: string
    isResolved?: boolean
    resolvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    employee?: EmployeeCreateNestedOneWithoutAlertsInput
    user?: UserCreateNestedOneWithoutAlertsInput
  }

  export type AlertUncheckedCreateWithoutActivityInput = {
    id?: string
    text: string
    severity?: string
    isResolved?: boolean
    resolvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    employeeId?: string | null
    userId?: string | null
  }

  export type AlertCreateOrConnectWithoutActivityInput = {
    where: AlertWhereUniqueInput
    create: XOR<AlertCreateWithoutActivityInput, AlertUncheckedCreateWithoutActivityInput>
  }

  export type AlertCreateManyActivityInputEnvelope = {
    data: AlertCreateManyActivityInput | AlertCreateManyActivityInput[]
    skipDuplicates?: boolean
  }

  export type EmployeeUpsertWithoutActivitiesInput = {
    update: XOR<EmployeeUpdateWithoutActivitiesInput, EmployeeUncheckedUpdateWithoutActivitiesInput>
    create: XOR<EmployeeCreateWithoutActivitiesInput, EmployeeUncheckedCreateWithoutActivitiesInput>
    where?: EmployeeWhereInput
  }

  export type EmployeeUpdateToOneWithWhereWithoutActivitiesInput = {
    where?: EmployeeWhereInput
    data: XOR<EmployeeUpdateWithoutActivitiesInput, EmployeeUncheckedUpdateWithoutActivitiesInput>
  }

  export type EmployeeUpdateWithoutActivitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    job?: StringFieldUpdateOperationsInput | string
    nationalId?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumEmployeeStatusFieldUpdateOperationsInput | $Enums.EmployeeStatus
    vendor?: VendorUpdateOneRequiredWithoutEmployeesNestedInput
    gates?: EmployeeGateUpdateManyWithoutEmployeeNestedInput
    zones?: EmployeeZoneUpdateManyWithoutEmployeeNestedInput
    workingHours?: WorkingHoursUpdateManyWithoutEmployeeNestedInput
    employeeAttachments?: EmployeeAttachmentUpdateManyWithoutEmployeeNestedInput
    employeePermissions?: EmployeePermissionUpdateManyWithoutEmployeeNestedInput
    alerts?: AlertUpdateManyWithoutEmployeeNestedInput
    allowedDates?: EmployeeAllowedDateUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutActivitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    job?: StringFieldUpdateOperationsInput | string
    nationalId?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumEmployeeStatusFieldUpdateOperationsInput | $Enums.EmployeeStatus
    vendorId?: StringFieldUpdateOperationsInput | string
    gates?: EmployeeGateUncheckedUpdateManyWithoutEmployeeNestedInput
    zones?: EmployeeZoneUncheckedUpdateManyWithoutEmployeeNestedInput
    workingHours?: WorkingHoursUncheckedUpdateManyWithoutEmployeeNestedInput
    employeeAttachments?: EmployeeAttachmentUncheckedUpdateManyWithoutEmployeeNestedInput
    employeePermissions?: EmployeePermissionUncheckedUpdateManyWithoutEmployeeNestedInput
    alerts?: AlertUncheckedUpdateManyWithoutEmployeeNestedInput
    allowedDates?: EmployeeAllowedDateUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type UserUpsertWithoutActivitiesInput = {
    update: XOR<UserUpdateWithoutActivitiesInput, UserUncheckedUpdateWithoutActivitiesInput>
    create: XOR<UserCreateWithoutActivitiesInput, UserUncheckedCreateWithoutActivitiesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutActivitiesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutActivitiesInput, UserUncheckedUpdateWithoutActivitiesInput>
  }

  export type UserUpdateWithoutActivitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    password?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    alerts?: AlertUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutActivitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    password?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    alerts?: AlertUncheckedUpdateManyWithoutUserNestedInput
  }

  export type GateUpsertWithoutActivitiesInput = {
    update: XOR<GateUpdateWithoutActivitiesInput, GateUncheckedUpdateWithoutActivitiesInput>
    create: XOR<GateCreateWithoutActivitiesInput, GateUncheckedCreateWithoutActivitiesInput>
    where?: GateWhereInput
  }

  export type GateUpdateToOneWithWhereWithoutActivitiesInput = {
    where?: GateWhereInput
    data: XOR<GateUpdateWithoutActivitiesInput, GateUncheckedUpdateWithoutActivitiesInput>
  }

  export type GateUpdateWithoutActivitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vendors?: VendorGateUpdateManyWithoutGateNestedInput
    employees?: EmployeeGateUpdateManyWithoutGateNestedInput
  }

  export type GateUncheckedUpdateWithoutActivitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vendors?: VendorGateUncheckedUpdateManyWithoutGateNestedInput
    employees?: EmployeeGateUncheckedUpdateManyWithoutGateNestedInput
  }

  export type AlertUpsertWithWhereUniqueWithoutActivityInput = {
    where: AlertWhereUniqueInput
    update: XOR<AlertUpdateWithoutActivityInput, AlertUncheckedUpdateWithoutActivityInput>
    create: XOR<AlertCreateWithoutActivityInput, AlertUncheckedCreateWithoutActivityInput>
  }

  export type AlertUpdateWithWhereUniqueWithoutActivityInput = {
    where: AlertWhereUniqueInput
    data: XOR<AlertUpdateWithoutActivityInput, AlertUncheckedUpdateWithoutActivityInput>
  }

  export type AlertUpdateManyWithWhereWithoutActivityInput = {
    where: AlertScalarWhereInput
    data: XOR<AlertUpdateManyMutationInput, AlertUncheckedUpdateManyWithoutActivityInput>
  }

  export type VendorAttachmentCreateWithoutAttachmentInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    vendor: VendorCreateNestedOneWithoutVendorAttachmentsInput
  }

  export type VendorAttachmentUncheckedCreateWithoutAttachmentInput = {
    id?: string
    vendorId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VendorAttachmentCreateOrConnectWithoutAttachmentInput = {
    where: VendorAttachmentWhereUniqueInput
    create: XOR<VendorAttachmentCreateWithoutAttachmentInput, VendorAttachmentUncheckedCreateWithoutAttachmentInput>
  }

  export type VendorAttachmentCreateManyAttachmentInputEnvelope = {
    data: VendorAttachmentCreateManyAttachmentInput | VendorAttachmentCreateManyAttachmentInput[]
    skipDuplicates?: boolean
  }

  export type EmployeeAttachmentCreateWithoutAttachmentInput = {
    id?: string
    type: $Enums.EmployeeAttachmentType
    createdAt?: Date | string
    updatedAt?: Date | string
    employee: EmployeeCreateNestedOneWithoutEmployeeAttachmentsInput
  }

  export type EmployeeAttachmentUncheckedCreateWithoutAttachmentInput = {
    id?: string
    type: $Enums.EmployeeAttachmentType
    employeeId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmployeeAttachmentCreateOrConnectWithoutAttachmentInput = {
    where: EmployeeAttachmentWhereUniqueInput
    create: XOR<EmployeeAttachmentCreateWithoutAttachmentInput, EmployeeAttachmentUncheckedCreateWithoutAttachmentInput>
  }

  export type EmployeeAttachmentCreateManyAttachmentInputEnvelope = {
    data: EmployeeAttachmentCreateManyAttachmentInput | EmployeeAttachmentCreateManyAttachmentInput[]
    skipDuplicates?: boolean
  }

  export type VendorAttachmentUpsertWithWhereUniqueWithoutAttachmentInput = {
    where: VendorAttachmentWhereUniqueInput
    update: XOR<VendorAttachmentUpdateWithoutAttachmentInput, VendorAttachmentUncheckedUpdateWithoutAttachmentInput>
    create: XOR<VendorAttachmentCreateWithoutAttachmentInput, VendorAttachmentUncheckedCreateWithoutAttachmentInput>
  }

  export type VendorAttachmentUpdateWithWhereUniqueWithoutAttachmentInput = {
    where: VendorAttachmentWhereUniqueInput
    data: XOR<VendorAttachmentUpdateWithoutAttachmentInput, VendorAttachmentUncheckedUpdateWithoutAttachmentInput>
  }

  export type VendorAttachmentUpdateManyWithWhereWithoutAttachmentInput = {
    where: VendorAttachmentScalarWhereInput
    data: XOR<VendorAttachmentUpdateManyMutationInput, VendorAttachmentUncheckedUpdateManyWithoutAttachmentInput>
  }

  export type EmployeeAttachmentUpsertWithWhereUniqueWithoutAttachmentInput = {
    where: EmployeeAttachmentWhereUniqueInput
    update: XOR<EmployeeAttachmentUpdateWithoutAttachmentInput, EmployeeAttachmentUncheckedUpdateWithoutAttachmentInput>
    create: XOR<EmployeeAttachmentCreateWithoutAttachmentInput, EmployeeAttachmentUncheckedCreateWithoutAttachmentInput>
  }

  export type EmployeeAttachmentUpdateWithWhereUniqueWithoutAttachmentInput = {
    where: EmployeeAttachmentWhereUniqueInput
    data: XOR<EmployeeAttachmentUpdateWithoutAttachmentInput, EmployeeAttachmentUncheckedUpdateWithoutAttachmentInput>
  }

  export type EmployeeAttachmentUpdateManyWithWhereWithoutAttachmentInput = {
    where: EmployeeAttachmentScalarWhereInput
    data: XOR<EmployeeAttachmentUpdateManyMutationInput, EmployeeAttachmentUncheckedUpdateManyWithoutAttachmentInput>
  }

  export type VendorCreateWithoutVendorAttachmentsInput = {
    id?: string
    name: string
    description?: string | null
    phoneNumber?: string | null
    allowedStaffCount: number
    accessToken?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    employees?: EmployeeCreateNestedManyWithoutVendorInput
    gates?: VendorGateCreateNestedManyWithoutVendorInput
    zones?: VendorZoneCreateNestedManyWithoutVendorInput
  }

  export type VendorUncheckedCreateWithoutVendorAttachmentsInput = {
    id?: string
    name: string
    description?: string | null
    phoneNumber?: string | null
    allowedStaffCount: number
    accessToken?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    employees?: EmployeeUncheckedCreateNestedManyWithoutVendorInput
    gates?: VendorGateUncheckedCreateNestedManyWithoutVendorInput
    zones?: VendorZoneUncheckedCreateNestedManyWithoutVendorInput
  }

  export type VendorCreateOrConnectWithoutVendorAttachmentsInput = {
    where: VendorWhereUniqueInput
    create: XOR<VendorCreateWithoutVendorAttachmentsInput, VendorUncheckedCreateWithoutVendorAttachmentsInput>
  }

  export type AttachmentCreateWithoutVendorAttachmentsInput = {
    id?: string
    url: string
    key?: string | null
    name?: string | null
    mimeType?: string | null
    size?: number | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    employeeAttachments?: EmployeeAttachmentCreateNestedManyWithoutAttachmentInput
  }

  export type AttachmentUncheckedCreateWithoutVendorAttachmentsInput = {
    id?: string
    url: string
    key?: string | null
    name?: string | null
    mimeType?: string | null
    size?: number | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    employeeAttachments?: EmployeeAttachmentUncheckedCreateNestedManyWithoutAttachmentInput
  }

  export type AttachmentCreateOrConnectWithoutVendorAttachmentsInput = {
    where: AttachmentWhereUniqueInput
    create: XOR<AttachmentCreateWithoutVendorAttachmentsInput, AttachmentUncheckedCreateWithoutVendorAttachmentsInput>
  }

  export type VendorUpsertWithoutVendorAttachmentsInput = {
    update: XOR<VendorUpdateWithoutVendorAttachmentsInput, VendorUncheckedUpdateWithoutVendorAttachmentsInput>
    create: XOR<VendorCreateWithoutVendorAttachmentsInput, VendorUncheckedCreateWithoutVendorAttachmentsInput>
    where?: VendorWhereInput
  }

  export type VendorUpdateToOneWithWhereWithoutVendorAttachmentsInput = {
    where?: VendorWhereInput
    data: XOR<VendorUpdateWithoutVendorAttachmentsInput, VendorUncheckedUpdateWithoutVendorAttachmentsInput>
  }

  export type VendorUpdateWithoutVendorAttachmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    allowedStaffCount?: IntFieldUpdateOperationsInput | number
    accessToken?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employees?: EmployeeUpdateManyWithoutVendorNestedInput
    gates?: VendorGateUpdateManyWithoutVendorNestedInput
    zones?: VendorZoneUpdateManyWithoutVendorNestedInput
  }

  export type VendorUncheckedUpdateWithoutVendorAttachmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    allowedStaffCount?: IntFieldUpdateOperationsInput | number
    accessToken?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employees?: EmployeeUncheckedUpdateManyWithoutVendorNestedInput
    gates?: VendorGateUncheckedUpdateManyWithoutVendorNestedInput
    zones?: VendorZoneUncheckedUpdateManyWithoutVendorNestedInput
  }

  export type AttachmentUpsertWithoutVendorAttachmentsInput = {
    update: XOR<AttachmentUpdateWithoutVendorAttachmentsInput, AttachmentUncheckedUpdateWithoutVendorAttachmentsInput>
    create: XOR<AttachmentCreateWithoutVendorAttachmentsInput, AttachmentUncheckedCreateWithoutVendorAttachmentsInput>
    where?: AttachmentWhereInput
  }

  export type AttachmentUpdateToOneWithWhereWithoutVendorAttachmentsInput = {
    where?: AttachmentWhereInput
    data: XOR<AttachmentUpdateWithoutVendorAttachmentsInput, AttachmentUncheckedUpdateWithoutVendorAttachmentsInput>
  }

  export type AttachmentUpdateWithoutVendorAttachmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    key?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employeeAttachments?: EmployeeAttachmentUpdateManyWithoutAttachmentNestedInput
  }

  export type AttachmentUncheckedUpdateWithoutVendorAttachmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    key?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employeeAttachments?: EmployeeAttachmentUncheckedUpdateManyWithoutAttachmentNestedInput
  }

  export type EmployeeCreateWithoutEmployeeAttachmentsInput = {
    id?: string
    identifier?: string
    name: string
    job: string
    nationalId: string
    version?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    status?: $Enums.EmployeeStatus
    vendor: VendorCreateNestedOneWithoutEmployeesInput
    gates?: EmployeeGateCreateNestedManyWithoutEmployeeInput
    zones?: EmployeeZoneCreateNestedManyWithoutEmployeeInput
    activities?: ActivityCreateNestedManyWithoutEmployeeInput
    workingHours?: WorkingHoursCreateNestedManyWithoutEmployeeInput
    employeePermissions?: EmployeePermissionCreateNestedManyWithoutEmployeeInput
    alerts?: AlertCreateNestedManyWithoutEmployeeInput
    allowedDates?: EmployeeAllowedDateCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutEmployeeAttachmentsInput = {
    id?: string
    identifier?: string
    name: string
    job: string
    nationalId: string
    version?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    status?: $Enums.EmployeeStatus
    vendorId: string
    gates?: EmployeeGateUncheckedCreateNestedManyWithoutEmployeeInput
    zones?: EmployeeZoneUncheckedCreateNestedManyWithoutEmployeeInput
    activities?: ActivityUncheckedCreateNestedManyWithoutEmployeeInput
    workingHours?: WorkingHoursUncheckedCreateNestedManyWithoutEmployeeInput
    employeePermissions?: EmployeePermissionUncheckedCreateNestedManyWithoutEmployeeInput
    alerts?: AlertUncheckedCreateNestedManyWithoutEmployeeInput
    allowedDates?: EmployeeAllowedDateUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeCreateOrConnectWithoutEmployeeAttachmentsInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutEmployeeAttachmentsInput, EmployeeUncheckedCreateWithoutEmployeeAttachmentsInput>
  }

  export type AttachmentCreateWithoutEmployeeAttachmentsInput = {
    id?: string
    url: string
    key?: string | null
    name?: string | null
    mimeType?: string | null
    size?: number | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    vendorAttachments?: VendorAttachmentCreateNestedManyWithoutAttachmentInput
  }

  export type AttachmentUncheckedCreateWithoutEmployeeAttachmentsInput = {
    id?: string
    url: string
    key?: string | null
    name?: string | null
    mimeType?: string | null
    size?: number | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    vendorAttachments?: VendorAttachmentUncheckedCreateNestedManyWithoutAttachmentInput
  }

  export type AttachmentCreateOrConnectWithoutEmployeeAttachmentsInput = {
    where: AttachmentWhereUniqueInput
    create: XOR<AttachmentCreateWithoutEmployeeAttachmentsInput, AttachmentUncheckedCreateWithoutEmployeeAttachmentsInput>
  }

  export type EmployeeUpsertWithoutEmployeeAttachmentsInput = {
    update: XOR<EmployeeUpdateWithoutEmployeeAttachmentsInput, EmployeeUncheckedUpdateWithoutEmployeeAttachmentsInput>
    create: XOR<EmployeeCreateWithoutEmployeeAttachmentsInput, EmployeeUncheckedCreateWithoutEmployeeAttachmentsInput>
    where?: EmployeeWhereInput
  }

  export type EmployeeUpdateToOneWithWhereWithoutEmployeeAttachmentsInput = {
    where?: EmployeeWhereInput
    data: XOR<EmployeeUpdateWithoutEmployeeAttachmentsInput, EmployeeUncheckedUpdateWithoutEmployeeAttachmentsInput>
  }

  export type EmployeeUpdateWithoutEmployeeAttachmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    job?: StringFieldUpdateOperationsInput | string
    nationalId?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumEmployeeStatusFieldUpdateOperationsInput | $Enums.EmployeeStatus
    vendor?: VendorUpdateOneRequiredWithoutEmployeesNestedInput
    gates?: EmployeeGateUpdateManyWithoutEmployeeNestedInput
    zones?: EmployeeZoneUpdateManyWithoutEmployeeNestedInput
    activities?: ActivityUpdateManyWithoutEmployeeNestedInput
    workingHours?: WorkingHoursUpdateManyWithoutEmployeeNestedInput
    employeePermissions?: EmployeePermissionUpdateManyWithoutEmployeeNestedInput
    alerts?: AlertUpdateManyWithoutEmployeeNestedInput
    allowedDates?: EmployeeAllowedDateUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutEmployeeAttachmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    job?: StringFieldUpdateOperationsInput | string
    nationalId?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumEmployeeStatusFieldUpdateOperationsInput | $Enums.EmployeeStatus
    vendorId?: StringFieldUpdateOperationsInput | string
    gates?: EmployeeGateUncheckedUpdateManyWithoutEmployeeNestedInput
    zones?: EmployeeZoneUncheckedUpdateManyWithoutEmployeeNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutEmployeeNestedInput
    workingHours?: WorkingHoursUncheckedUpdateManyWithoutEmployeeNestedInput
    employeePermissions?: EmployeePermissionUncheckedUpdateManyWithoutEmployeeNestedInput
    alerts?: AlertUncheckedUpdateManyWithoutEmployeeNestedInput
    allowedDates?: EmployeeAllowedDateUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type AttachmentUpsertWithoutEmployeeAttachmentsInput = {
    update: XOR<AttachmentUpdateWithoutEmployeeAttachmentsInput, AttachmentUncheckedUpdateWithoutEmployeeAttachmentsInput>
    create: XOR<AttachmentCreateWithoutEmployeeAttachmentsInput, AttachmentUncheckedCreateWithoutEmployeeAttachmentsInput>
    where?: AttachmentWhereInput
  }

  export type AttachmentUpdateToOneWithWhereWithoutEmployeeAttachmentsInput = {
    where?: AttachmentWhereInput
    data: XOR<AttachmentUpdateWithoutEmployeeAttachmentsInput, AttachmentUncheckedUpdateWithoutEmployeeAttachmentsInput>
  }

  export type AttachmentUpdateWithoutEmployeeAttachmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    key?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vendorAttachments?: VendorAttachmentUpdateManyWithoutAttachmentNestedInput
  }

  export type AttachmentUncheckedUpdateWithoutEmployeeAttachmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    key?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vendorAttachments?: VendorAttachmentUncheckedUpdateManyWithoutAttachmentNestedInput
  }

  export type EmployeeCreateWithoutEmployeePermissionsInput = {
    id?: string
    identifier?: string
    name: string
    job: string
    nationalId: string
    version?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    status?: $Enums.EmployeeStatus
    vendor: VendorCreateNestedOneWithoutEmployeesInput
    gates?: EmployeeGateCreateNestedManyWithoutEmployeeInput
    zones?: EmployeeZoneCreateNestedManyWithoutEmployeeInput
    activities?: ActivityCreateNestedManyWithoutEmployeeInput
    workingHours?: WorkingHoursCreateNestedManyWithoutEmployeeInput
    employeeAttachments?: EmployeeAttachmentCreateNestedManyWithoutEmployeeInput
    alerts?: AlertCreateNestedManyWithoutEmployeeInput
    allowedDates?: EmployeeAllowedDateCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutEmployeePermissionsInput = {
    id?: string
    identifier?: string
    name: string
    job: string
    nationalId: string
    version?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    status?: $Enums.EmployeeStatus
    vendorId: string
    gates?: EmployeeGateUncheckedCreateNestedManyWithoutEmployeeInput
    zones?: EmployeeZoneUncheckedCreateNestedManyWithoutEmployeeInput
    activities?: ActivityUncheckedCreateNestedManyWithoutEmployeeInput
    workingHours?: WorkingHoursUncheckedCreateNestedManyWithoutEmployeeInput
    employeeAttachments?: EmployeeAttachmentUncheckedCreateNestedManyWithoutEmployeeInput
    alerts?: AlertUncheckedCreateNestedManyWithoutEmployeeInput
    allowedDates?: EmployeeAllowedDateUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeCreateOrConnectWithoutEmployeePermissionsInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutEmployeePermissionsInput, EmployeeUncheckedCreateWithoutEmployeePermissionsInput>
  }

  export type PermissionCreateWithoutEmployeePermissionsInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type PermissionUncheckedCreateWithoutEmployeePermissionsInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type PermissionCreateOrConnectWithoutEmployeePermissionsInput = {
    where: PermissionWhereUniqueInput
    create: XOR<PermissionCreateWithoutEmployeePermissionsInput, PermissionUncheckedCreateWithoutEmployeePermissionsInput>
  }

  export type EmployeeUpsertWithoutEmployeePermissionsInput = {
    update: XOR<EmployeeUpdateWithoutEmployeePermissionsInput, EmployeeUncheckedUpdateWithoutEmployeePermissionsInput>
    create: XOR<EmployeeCreateWithoutEmployeePermissionsInput, EmployeeUncheckedCreateWithoutEmployeePermissionsInput>
    where?: EmployeeWhereInput
  }

  export type EmployeeUpdateToOneWithWhereWithoutEmployeePermissionsInput = {
    where?: EmployeeWhereInput
    data: XOR<EmployeeUpdateWithoutEmployeePermissionsInput, EmployeeUncheckedUpdateWithoutEmployeePermissionsInput>
  }

  export type EmployeeUpdateWithoutEmployeePermissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    job?: StringFieldUpdateOperationsInput | string
    nationalId?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumEmployeeStatusFieldUpdateOperationsInput | $Enums.EmployeeStatus
    vendor?: VendorUpdateOneRequiredWithoutEmployeesNestedInput
    gates?: EmployeeGateUpdateManyWithoutEmployeeNestedInput
    zones?: EmployeeZoneUpdateManyWithoutEmployeeNestedInput
    activities?: ActivityUpdateManyWithoutEmployeeNestedInput
    workingHours?: WorkingHoursUpdateManyWithoutEmployeeNestedInput
    employeeAttachments?: EmployeeAttachmentUpdateManyWithoutEmployeeNestedInput
    alerts?: AlertUpdateManyWithoutEmployeeNestedInput
    allowedDates?: EmployeeAllowedDateUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutEmployeePermissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    job?: StringFieldUpdateOperationsInput | string
    nationalId?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumEmployeeStatusFieldUpdateOperationsInput | $Enums.EmployeeStatus
    vendorId?: StringFieldUpdateOperationsInput | string
    gates?: EmployeeGateUncheckedUpdateManyWithoutEmployeeNestedInput
    zones?: EmployeeZoneUncheckedUpdateManyWithoutEmployeeNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutEmployeeNestedInput
    workingHours?: WorkingHoursUncheckedUpdateManyWithoutEmployeeNestedInput
    employeeAttachments?: EmployeeAttachmentUncheckedUpdateManyWithoutEmployeeNestedInput
    alerts?: AlertUncheckedUpdateManyWithoutEmployeeNestedInput
    allowedDates?: EmployeeAllowedDateUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type PermissionUpsertWithoutEmployeePermissionsInput = {
    update: XOR<PermissionUpdateWithoutEmployeePermissionsInput, PermissionUncheckedUpdateWithoutEmployeePermissionsInput>
    create: XOR<PermissionCreateWithoutEmployeePermissionsInput, PermissionUncheckedCreateWithoutEmployeePermissionsInput>
    where?: PermissionWhereInput
  }

  export type PermissionUpdateToOneWithWhereWithoutEmployeePermissionsInput = {
    where?: PermissionWhereInput
    data: XOR<PermissionUpdateWithoutEmployeePermissionsInput, PermissionUncheckedUpdateWithoutEmployeePermissionsInput>
  }

  export type PermissionUpdateWithoutEmployeePermissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PermissionUncheckedUpdateWithoutEmployeePermissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type VendorCreateWithoutGatesInput = {
    id?: string
    name: string
    description?: string | null
    phoneNumber?: string | null
    allowedStaffCount: number
    accessToken?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    employees?: EmployeeCreateNestedManyWithoutVendorInput
    vendorAttachments?: VendorAttachmentCreateNestedManyWithoutVendorInput
    zones?: VendorZoneCreateNestedManyWithoutVendorInput
  }

  export type VendorUncheckedCreateWithoutGatesInput = {
    id?: string
    name: string
    description?: string | null
    phoneNumber?: string | null
    allowedStaffCount: number
    accessToken?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    employees?: EmployeeUncheckedCreateNestedManyWithoutVendorInput
    vendorAttachments?: VendorAttachmentUncheckedCreateNestedManyWithoutVendorInput
    zones?: VendorZoneUncheckedCreateNestedManyWithoutVendorInput
  }

  export type VendorCreateOrConnectWithoutGatesInput = {
    where: VendorWhereUniqueInput
    create: XOR<VendorCreateWithoutGatesInput, VendorUncheckedCreateWithoutGatesInput>
  }

  export type GateCreateWithoutVendorsInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    employees?: EmployeeGateCreateNestedManyWithoutGateInput
    activities?: ActivityCreateNestedManyWithoutGateInput
  }

  export type GateUncheckedCreateWithoutVendorsInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    employees?: EmployeeGateUncheckedCreateNestedManyWithoutGateInput
    activities?: ActivityUncheckedCreateNestedManyWithoutGateInput
  }

  export type GateCreateOrConnectWithoutVendorsInput = {
    where: GateWhereUniqueInput
    create: XOR<GateCreateWithoutVendorsInput, GateUncheckedCreateWithoutVendorsInput>
  }

  export type VendorUpsertWithoutGatesInput = {
    update: XOR<VendorUpdateWithoutGatesInput, VendorUncheckedUpdateWithoutGatesInput>
    create: XOR<VendorCreateWithoutGatesInput, VendorUncheckedCreateWithoutGatesInput>
    where?: VendorWhereInput
  }

  export type VendorUpdateToOneWithWhereWithoutGatesInput = {
    where?: VendorWhereInput
    data: XOR<VendorUpdateWithoutGatesInput, VendorUncheckedUpdateWithoutGatesInput>
  }

  export type VendorUpdateWithoutGatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    allowedStaffCount?: IntFieldUpdateOperationsInput | number
    accessToken?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employees?: EmployeeUpdateManyWithoutVendorNestedInput
    vendorAttachments?: VendorAttachmentUpdateManyWithoutVendorNestedInput
    zones?: VendorZoneUpdateManyWithoutVendorNestedInput
  }

  export type VendorUncheckedUpdateWithoutGatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    allowedStaffCount?: IntFieldUpdateOperationsInput | number
    accessToken?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employees?: EmployeeUncheckedUpdateManyWithoutVendorNestedInput
    vendorAttachments?: VendorAttachmentUncheckedUpdateManyWithoutVendorNestedInput
    zones?: VendorZoneUncheckedUpdateManyWithoutVendorNestedInput
  }

  export type GateUpsertWithoutVendorsInput = {
    update: XOR<GateUpdateWithoutVendorsInput, GateUncheckedUpdateWithoutVendorsInput>
    create: XOR<GateCreateWithoutVendorsInput, GateUncheckedCreateWithoutVendorsInput>
    where?: GateWhereInput
  }

  export type GateUpdateToOneWithWhereWithoutVendorsInput = {
    where?: GateWhereInput
    data: XOR<GateUpdateWithoutVendorsInput, GateUncheckedUpdateWithoutVendorsInput>
  }

  export type GateUpdateWithoutVendorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employees?: EmployeeGateUpdateManyWithoutGateNestedInput
    activities?: ActivityUpdateManyWithoutGateNestedInput
  }

  export type GateUncheckedUpdateWithoutVendorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employees?: EmployeeGateUncheckedUpdateManyWithoutGateNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutGateNestedInput
  }

  export type VendorCreateWithoutZonesInput = {
    id?: string
    name: string
    description?: string | null
    phoneNumber?: string | null
    allowedStaffCount: number
    accessToken?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    employees?: EmployeeCreateNestedManyWithoutVendorInput
    vendorAttachments?: VendorAttachmentCreateNestedManyWithoutVendorInput
    gates?: VendorGateCreateNestedManyWithoutVendorInput
  }

  export type VendorUncheckedCreateWithoutZonesInput = {
    id?: string
    name: string
    description?: string | null
    phoneNumber?: string | null
    allowedStaffCount: number
    accessToken?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    employees?: EmployeeUncheckedCreateNestedManyWithoutVendorInput
    vendorAttachments?: VendorAttachmentUncheckedCreateNestedManyWithoutVendorInput
    gates?: VendorGateUncheckedCreateNestedManyWithoutVendorInput
  }

  export type VendorCreateOrConnectWithoutZonesInput = {
    where: VendorWhereUniqueInput
    create: XOR<VendorCreateWithoutZonesInput, VendorUncheckedCreateWithoutZonesInput>
  }

  export type ZoneCreateWithoutVendorsInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    employees?: EmployeeZoneCreateNestedManyWithoutZoneInput
  }

  export type ZoneUncheckedCreateWithoutVendorsInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    employees?: EmployeeZoneUncheckedCreateNestedManyWithoutZoneInput
  }

  export type ZoneCreateOrConnectWithoutVendorsInput = {
    where: ZoneWhereUniqueInput
    create: XOR<ZoneCreateWithoutVendorsInput, ZoneUncheckedCreateWithoutVendorsInput>
  }

  export type VendorUpsertWithoutZonesInput = {
    update: XOR<VendorUpdateWithoutZonesInput, VendorUncheckedUpdateWithoutZonesInput>
    create: XOR<VendorCreateWithoutZonesInput, VendorUncheckedCreateWithoutZonesInput>
    where?: VendorWhereInput
  }

  export type VendorUpdateToOneWithWhereWithoutZonesInput = {
    where?: VendorWhereInput
    data: XOR<VendorUpdateWithoutZonesInput, VendorUncheckedUpdateWithoutZonesInput>
  }

  export type VendorUpdateWithoutZonesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    allowedStaffCount?: IntFieldUpdateOperationsInput | number
    accessToken?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employees?: EmployeeUpdateManyWithoutVendorNestedInput
    vendorAttachments?: VendorAttachmentUpdateManyWithoutVendorNestedInput
    gates?: VendorGateUpdateManyWithoutVendorNestedInput
  }

  export type VendorUncheckedUpdateWithoutZonesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    allowedStaffCount?: IntFieldUpdateOperationsInput | number
    accessToken?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employees?: EmployeeUncheckedUpdateManyWithoutVendorNestedInput
    vendorAttachments?: VendorAttachmentUncheckedUpdateManyWithoutVendorNestedInput
    gates?: VendorGateUncheckedUpdateManyWithoutVendorNestedInput
  }

  export type ZoneUpsertWithoutVendorsInput = {
    update: XOR<ZoneUpdateWithoutVendorsInput, ZoneUncheckedUpdateWithoutVendorsInput>
    create: XOR<ZoneCreateWithoutVendorsInput, ZoneUncheckedCreateWithoutVendorsInput>
    where?: ZoneWhereInput
  }

  export type ZoneUpdateToOneWithWhereWithoutVendorsInput = {
    where?: ZoneWhereInput
    data: XOR<ZoneUpdateWithoutVendorsInput, ZoneUncheckedUpdateWithoutVendorsInput>
  }

  export type ZoneUpdateWithoutVendorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employees?: EmployeeZoneUpdateManyWithoutZoneNestedInput
  }

  export type ZoneUncheckedUpdateWithoutVendorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employees?: EmployeeZoneUncheckedUpdateManyWithoutZoneNestedInput
  }

  export type EmployeeCreateWithoutGatesInput = {
    id?: string
    identifier?: string
    name: string
    job: string
    nationalId: string
    version?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    status?: $Enums.EmployeeStatus
    vendor: VendorCreateNestedOneWithoutEmployeesInput
    zones?: EmployeeZoneCreateNestedManyWithoutEmployeeInput
    activities?: ActivityCreateNestedManyWithoutEmployeeInput
    workingHours?: WorkingHoursCreateNestedManyWithoutEmployeeInput
    employeeAttachments?: EmployeeAttachmentCreateNestedManyWithoutEmployeeInput
    employeePermissions?: EmployeePermissionCreateNestedManyWithoutEmployeeInput
    alerts?: AlertCreateNestedManyWithoutEmployeeInput
    allowedDates?: EmployeeAllowedDateCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutGatesInput = {
    id?: string
    identifier?: string
    name: string
    job: string
    nationalId: string
    version?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    status?: $Enums.EmployeeStatus
    vendorId: string
    zones?: EmployeeZoneUncheckedCreateNestedManyWithoutEmployeeInput
    activities?: ActivityUncheckedCreateNestedManyWithoutEmployeeInput
    workingHours?: WorkingHoursUncheckedCreateNestedManyWithoutEmployeeInput
    employeeAttachments?: EmployeeAttachmentUncheckedCreateNestedManyWithoutEmployeeInput
    employeePermissions?: EmployeePermissionUncheckedCreateNestedManyWithoutEmployeeInput
    alerts?: AlertUncheckedCreateNestedManyWithoutEmployeeInput
    allowedDates?: EmployeeAllowedDateUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeCreateOrConnectWithoutGatesInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutGatesInput, EmployeeUncheckedCreateWithoutGatesInput>
  }

  export type GateCreateWithoutEmployeesInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    vendors?: VendorGateCreateNestedManyWithoutGateInput
    activities?: ActivityCreateNestedManyWithoutGateInput
  }

  export type GateUncheckedCreateWithoutEmployeesInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    vendors?: VendorGateUncheckedCreateNestedManyWithoutGateInput
    activities?: ActivityUncheckedCreateNestedManyWithoutGateInput
  }

  export type GateCreateOrConnectWithoutEmployeesInput = {
    where: GateWhereUniqueInput
    create: XOR<GateCreateWithoutEmployeesInput, GateUncheckedCreateWithoutEmployeesInput>
  }

  export type EmployeeUpsertWithoutGatesInput = {
    update: XOR<EmployeeUpdateWithoutGatesInput, EmployeeUncheckedUpdateWithoutGatesInput>
    create: XOR<EmployeeCreateWithoutGatesInput, EmployeeUncheckedCreateWithoutGatesInput>
    where?: EmployeeWhereInput
  }

  export type EmployeeUpdateToOneWithWhereWithoutGatesInput = {
    where?: EmployeeWhereInput
    data: XOR<EmployeeUpdateWithoutGatesInput, EmployeeUncheckedUpdateWithoutGatesInput>
  }

  export type EmployeeUpdateWithoutGatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    job?: StringFieldUpdateOperationsInput | string
    nationalId?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumEmployeeStatusFieldUpdateOperationsInput | $Enums.EmployeeStatus
    vendor?: VendorUpdateOneRequiredWithoutEmployeesNestedInput
    zones?: EmployeeZoneUpdateManyWithoutEmployeeNestedInput
    activities?: ActivityUpdateManyWithoutEmployeeNestedInput
    workingHours?: WorkingHoursUpdateManyWithoutEmployeeNestedInput
    employeeAttachments?: EmployeeAttachmentUpdateManyWithoutEmployeeNestedInput
    employeePermissions?: EmployeePermissionUpdateManyWithoutEmployeeNestedInput
    alerts?: AlertUpdateManyWithoutEmployeeNestedInput
    allowedDates?: EmployeeAllowedDateUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutGatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    job?: StringFieldUpdateOperationsInput | string
    nationalId?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumEmployeeStatusFieldUpdateOperationsInput | $Enums.EmployeeStatus
    vendorId?: StringFieldUpdateOperationsInput | string
    zones?: EmployeeZoneUncheckedUpdateManyWithoutEmployeeNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutEmployeeNestedInput
    workingHours?: WorkingHoursUncheckedUpdateManyWithoutEmployeeNestedInput
    employeeAttachments?: EmployeeAttachmentUncheckedUpdateManyWithoutEmployeeNestedInput
    employeePermissions?: EmployeePermissionUncheckedUpdateManyWithoutEmployeeNestedInput
    alerts?: AlertUncheckedUpdateManyWithoutEmployeeNestedInput
    allowedDates?: EmployeeAllowedDateUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type GateUpsertWithoutEmployeesInput = {
    update: XOR<GateUpdateWithoutEmployeesInput, GateUncheckedUpdateWithoutEmployeesInput>
    create: XOR<GateCreateWithoutEmployeesInput, GateUncheckedCreateWithoutEmployeesInput>
    where?: GateWhereInput
  }

  export type GateUpdateToOneWithWhereWithoutEmployeesInput = {
    where?: GateWhereInput
    data: XOR<GateUpdateWithoutEmployeesInput, GateUncheckedUpdateWithoutEmployeesInput>
  }

  export type GateUpdateWithoutEmployeesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vendors?: VendorGateUpdateManyWithoutGateNestedInput
    activities?: ActivityUpdateManyWithoutGateNestedInput
  }

  export type GateUncheckedUpdateWithoutEmployeesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vendors?: VendorGateUncheckedUpdateManyWithoutGateNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutGateNestedInput
  }

  export type EmployeeCreateWithoutZonesInput = {
    id?: string
    identifier?: string
    name: string
    job: string
    nationalId: string
    version?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    status?: $Enums.EmployeeStatus
    vendor: VendorCreateNestedOneWithoutEmployeesInput
    gates?: EmployeeGateCreateNestedManyWithoutEmployeeInput
    activities?: ActivityCreateNestedManyWithoutEmployeeInput
    workingHours?: WorkingHoursCreateNestedManyWithoutEmployeeInput
    employeeAttachments?: EmployeeAttachmentCreateNestedManyWithoutEmployeeInput
    employeePermissions?: EmployeePermissionCreateNestedManyWithoutEmployeeInput
    alerts?: AlertCreateNestedManyWithoutEmployeeInput
    allowedDates?: EmployeeAllowedDateCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutZonesInput = {
    id?: string
    identifier?: string
    name: string
    job: string
    nationalId: string
    version?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    status?: $Enums.EmployeeStatus
    vendorId: string
    gates?: EmployeeGateUncheckedCreateNestedManyWithoutEmployeeInput
    activities?: ActivityUncheckedCreateNestedManyWithoutEmployeeInput
    workingHours?: WorkingHoursUncheckedCreateNestedManyWithoutEmployeeInput
    employeeAttachments?: EmployeeAttachmentUncheckedCreateNestedManyWithoutEmployeeInput
    employeePermissions?: EmployeePermissionUncheckedCreateNestedManyWithoutEmployeeInput
    alerts?: AlertUncheckedCreateNestedManyWithoutEmployeeInput
    allowedDates?: EmployeeAllowedDateUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeCreateOrConnectWithoutZonesInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutZonesInput, EmployeeUncheckedCreateWithoutZonesInput>
  }

  export type ZoneCreateWithoutEmployeesInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    vendors?: VendorZoneCreateNestedManyWithoutZoneInput
  }

  export type ZoneUncheckedCreateWithoutEmployeesInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    vendors?: VendorZoneUncheckedCreateNestedManyWithoutZoneInput
  }

  export type ZoneCreateOrConnectWithoutEmployeesInput = {
    where: ZoneWhereUniqueInput
    create: XOR<ZoneCreateWithoutEmployeesInput, ZoneUncheckedCreateWithoutEmployeesInput>
  }

  export type EmployeeUpsertWithoutZonesInput = {
    update: XOR<EmployeeUpdateWithoutZonesInput, EmployeeUncheckedUpdateWithoutZonesInput>
    create: XOR<EmployeeCreateWithoutZonesInput, EmployeeUncheckedCreateWithoutZonesInput>
    where?: EmployeeWhereInput
  }

  export type EmployeeUpdateToOneWithWhereWithoutZonesInput = {
    where?: EmployeeWhereInput
    data: XOR<EmployeeUpdateWithoutZonesInput, EmployeeUncheckedUpdateWithoutZonesInput>
  }

  export type EmployeeUpdateWithoutZonesInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    job?: StringFieldUpdateOperationsInput | string
    nationalId?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumEmployeeStatusFieldUpdateOperationsInput | $Enums.EmployeeStatus
    vendor?: VendorUpdateOneRequiredWithoutEmployeesNestedInput
    gates?: EmployeeGateUpdateManyWithoutEmployeeNestedInput
    activities?: ActivityUpdateManyWithoutEmployeeNestedInput
    workingHours?: WorkingHoursUpdateManyWithoutEmployeeNestedInput
    employeeAttachments?: EmployeeAttachmentUpdateManyWithoutEmployeeNestedInput
    employeePermissions?: EmployeePermissionUpdateManyWithoutEmployeeNestedInput
    alerts?: AlertUpdateManyWithoutEmployeeNestedInput
    allowedDates?: EmployeeAllowedDateUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutZonesInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    job?: StringFieldUpdateOperationsInput | string
    nationalId?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumEmployeeStatusFieldUpdateOperationsInput | $Enums.EmployeeStatus
    vendorId?: StringFieldUpdateOperationsInput | string
    gates?: EmployeeGateUncheckedUpdateManyWithoutEmployeeNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutEmployeeNestedInput
    workingHours?: WorkingHoursUncheckedUpdateManyWithoutEmployeeNestedInput
    employeeAttachments?: EmployeeAttachmentUncheckedUpdateManyWithoutEmployeeNestedInput
    employeePermissions?: EmployeePermissionUncheckedUpdateManyWithoutEmployeeNestedInput
    alerts?: AlertUncheckedUpdateManyWithoutEmployeeNestedInput
    allowedDates?: EmployeeAllowedDateUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type ZoneUpsertWithoutEmployeesInput = {
    update: XOR<ZoneUpdateWithoutEmployeesInput, ZoneUncheckedUpdateWithoutEmployeesInput>
    create: XOR<ZoneCreateWithoutEmployeesInput, ZoneUncheckedCreateWithoutEmployeesInput>
    where?: ZoneWhereInput
  }

  export type ZoneUpdateToOneWithWhereWithoutEmployeesInput = {
    where?: ZoneWhereInput
    data: XOR<ZoneUpdateWithoutEmployeesInput, ZoneUncheckedUpdateWithoutEmployeesInput>
  }

  export type ZoneUpdateWithoutEmployeesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vendors?: VendorZoneUpdateManyWithoutZoneNestedInput
  }

  export type ZoneUncheckedUpdateWithoutEmployeesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vendors?: VendorZoneUncheckedUpdateManyWithoutZoneNestedInput
  }

  export type EmployeeCreateWithoutAllowedDatesInput = {
    id?: string
    identifier?: string
    name: string
    job: string
    nationalId: string
    version?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    status?: $Enums.EmployeeStatus
    vendor: VendorCreateNestedOneWithoutEmployeesInput
    gates?: EmployeeGateCreateNestedManyWithoutEmployeeInput
    zones?: EmployeeZoneCreateNestedManyWithoutEmployeeInput
    activities?: ActivityCreateNestedManyWithoutEmployeeInput
    workingHours?: WorkingHoursCreateNestedManyWithoutEmployeeInput
    employeeAttachments?: EmployeeAttachmentCreateNestedManyWithoutEmployeeInput
    employeePermissions?: EmployeePermissionCreateNestedManyWithoutEmployeeInput
    alerts?: AlertCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutAllowedDatesInput = {
    id?: string
    identifier?: string
    name: string
    job: string
    nationalId: string
    version?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    status?: $Enums.EmployeeStatus
    vendorId: string
    gates?: EmployeeGateUncheckedCreateNestedManyWithoutEmployeeInput
    zones?: EmployeeZoneUncheckedCreateNestedManyWithoutEmployeeInput
    activities?: ActivityUncheckedCreateNestedManyWithoutEmployeeInput
    workingHours?: WorkingHoursUncheckedCreateNestedManyWithoutEmployeeInput
    employeeAttachments?: EmployeeAttachmentUncheckedCreateNestedManyWithoutEmployeeInput
    employeePermissions?: EmployeePermissionUncheckedCreateNestedManyWithoutEmployeeInput
    alerts?: AlertUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeCreateOrConnectWithoutAllowedDatesInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutAllowedDatesInput, EmployeeUncheckedCreateWithoutAllowedDatesInput>
  }

  export type EmployeeUpsertWithoutAllowedDatesInput = {
    update: XOR<EmployeeUpdateWithoutAllowedDatesInput, EmployeeUncheckedUpdateWithoutAllowedDatesInput>
    create: XOR<EmployeeCreateWithoutAllowedDatesInput, EmployeeUncheckedCreateWithoutAllowedDatesInput>
    where?: EmployeeWhereInput
  }

  export type EmployeeUpdateToOneWithWhereWithoutAllowedDatesInput = {
    where?: EmployeeWhereInput
    data: XOR<EmployeeUpdateWithoutAllowedDatesInput, EmployeeUncheckedUpdateWithoutAllowedDatesInput>
  }

  export type EmployeeUpdateWithoutAllowedDatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    job?: StringFieldUpdateOperationsInput | string
    nationalId?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumEmployeeStatusFieldUpdateOperationsInput | $Enums.EmployeeStatus
    vendor?: VendorUpdateOneRequiredWithoutEmployeesNestedInput
    gates?: EmployeeGateUpdateManyWithoutEmployeeNestedInput
    zones?: EmployeeZoneUpdateManyWithoutEmployeeNestedInput
    activities?: ActivityUpdateManyWithoutEmployeeNestedInput
    workingHours?: WorkingHoursUpdateManyWithoutEmployeeNestedInput
    employeeAttachments?: EmployeeAttachmentUpdateManyWithoutEmployeeNestedInput
    employeePermissions?: EmployeePermissionUpdateManyWithoutEmployeeNestedInput
    alerts?: AlertUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutAllowedDatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    job?: StringFieldUpdateOperationsInput | string
    nationalId?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumEmployeeStatusFieldUpdateOperationsInput | $Enums.EmployeeStatus
    vendorId?: StringFieldUpdateOperationsInput | string
    gates?: EmployeeGateUncheckedUpdateManyWithoutEmployeeNestedInput
    zones?: EmployeeZoneUncheckedUpdateManyWithoutEmployeeNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutEmployeeNestedInput
    workingHours?: WorkingHoursUncheckedUpdateManyWithoutEmployeeNestedInput
    employeeAttachments?: EmployeeAttachmentUncheckedUpdateManyWithoutEmployeeNestedInput
    employeePermissions?: EmployeePermissionUncheckedUpdateManyWithoutEmployeeNestedInput
    alerts?: AlertUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type ActivityCreateManyScannerInput = {
    id?: string
    type?: $Enums.ActivityType
    status: $Enums.AccessStatus
    denialReason?: string | null
    scannedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    employeeId: string
    gateId?: string | null
  }

  export type AlertCreateManyUserInput = {
    id?: string
    text: string
    severity?: string
    isResolved?: boolean
    resolvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    employeeId?: string | null
    activityId?: string | null
  }

  export type ActivityUpdateWithoutScannerInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    status?: EnumAccessStatusFieldUpdateOperationsInput | $Enums.AccessStatus
    denialReason?: NullableStringFieldUpdateOperationsInput | string | null
    scannedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: EmployeeUpdateOneRequiredWithoutActivitiesNestedInput
    gate?: GateUpdateOneWithoutActivitiesNestedInput
    alerts?: AlertUpdateManyWithoutActivityNestedInput
  }

  export type ActivityUncheckedUpdateWithoutScannerInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    status?: EnumAccessStatusFieldUpdateOperationsInput | $Enums.AccessStatus
    denialReason?: NullableStringFieldUpdateOperationsInput | string | null
    scannedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employeeId?: StringFieldUpdateOperationsInput | string
    gateId?: NullableStringFieldUpdateOperationsInput | string | null
    alerts?: AlertUncheckedUpdateManyWithoutActivityNestedInput
  }

  export type ActivityUncheckedUpdateManyWithoutScannerInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    status?: EnumAccessStatusFieldUpdateOperationsInput | $Enums.AccessStatus
    denialReason?: NullableStringFieldUpdateOperationsInput | string | null
    scannedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employeeId?: StringFieldUpdateOperationsInput | string
    gateId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AlertUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    isResolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: EmployeeUpdateOneWithoutAlertsNestedInput
    activity?: ActivityUpdateOneWithoutAlertsNestedInput
  }

  export type AlertUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    isResolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    activityId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AlertUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    isResolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    activityId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EmployeeCreateManyVendorInput = {
    id?: string
    identifier?: string
    name: string
    job: string
    nationalId: string
    version?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    status?: $Enums.EmployeeStatus
  }

  export type VendorAttachmentCreateManyVendorInput = {
    id?: string
    attachmentId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VendorGateCreateManyVendorInput = {
    id?: string
    gateId: string
    createdAt?: Date | string
  }

  export type VendorZoneCreateManyVendorInput = {
    id?: string
    zoneId: string
    createdAt?: Date | string
  }

  export type EmployeeUpdateWithoutVendorInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    job?: StringFieldUpdateOperationsInput | string
    nationalId?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumEmployeeStatusFieldUpdateOperationsInput | $Enums.EmployeeStatus
    gates?: EmployeeGateUpdateManyWithoutEmployeeNestedInput
    zones?: EmployeeZoneUpdateManyWithoutEmployeeNestedInput
    activities?: ActivityUpdateManyWithoutEmployeeNestedInput
    workingHours?: WorkingHoursUpdateManyWithoutEmployeeNestedInput
    employeeAttachments?: EmployeeAttachmentUpdateManyWithoutEmployeeNestedInput
    employeePermissions?: EmployeePermissionUpdateManyWithoutEmployeeNestedInput
    alerts?: AlertUpdateManyWithoutEmployeeNestedInput
    allowedDates?: EmployeeAllowedDateUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutVendorInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    job?: StringFieldUpdateOperationsInput | string
    nationalId?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumEmployeeStatusFieldUpdateOperationsInput | $Enums.EmployeeStatus
    gates?: EmployeeGateUncheckedUpdateManyWithoutEmployeeNestedInput
    zones?: EmployeeZoneUncheckedUpdateManyWithoutEmployeeNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutEmployeeNestedInput
    workingHours?: WorkingHoursUncheckedUpdateManyWithoutEmployeeNestedInput
    employeeAttachments?: EmployeeAttachmentUncheckedUpdateManyWithoutEmployeeNestedInput
    employeePermissions?: EmployeePermissionUncheckedUpdateManyWithoutEmployeeNestedInput
    alerts?: AlertUncheckedUpdateManyWithoutEmployeeNestedInput
    allowedDates?: EmployeeAllowedDateUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateManyWithoutVendorInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    job?: StringFieldUpdateOperationsInput | string
    nationalId?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumEmployeeStatusFieldUpdateOperationsInput | $Enums.EmployeeStatus
  }

  export type VendorAttachmentUpdateWithoutVendorInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attachment?: AttachmentUpdateOneRequiredWithoutVendorAttachmentsNestedInput
  }

  export type VendorAttachmentUncheckedUpdateWithoutVendorInput = {
    id?: StringFieldUpdateOperationsInput | string
    attachmentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorAttachmentUncheckedUpdateManyWithoutVendorInput = {
    id?: StringFieldUpdateOperationsInput | string
    attachmentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorGateUpdateWithoutVendorInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gate?: GateUpdateOneRequiredWithoutVendorsNestedInput
  }

  export type VendorGateUncheckedUpdateWithoutVendorInput = {
    id?: StringFieldUpdateOperationsInput | string
    gateId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorGateUncheckedUpdateManyWithoutVendorInput = {
    id?: StringFieldUpdateOperationsInput | string
    gateId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorZoneUpdateWithoutVendorInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    zone?: ZoneUpdateOneRequiredWithoutVendorsNestedInput
  }

  export type VendorZoneUncheckedUpdateWithoutVendorInput = {
    id?: StringFieldUpdateOperationsInput | string
    zoneId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorZoneUncheckedUpdateManyWithoutVendorInput = {
    id?: StringFieldUpdateOperationsInput | string
    zoneId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorZoneCreateManyZoneInput = {
    id?: string
    vendorId: string
    createdAt?: Date | string
  }

  export type EmployeeZoneCreateManyZoneInput = {
    id?: string
    employeeId: string
    createdAt?: Date | string
  }

  export type VendorZoneUpdateWithoutZoneInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vendor?: VendorUpdateOneRequiredWithoutZonesNestedInput
  }

  export type VendorZoneUncheckedUpdateWithoutZoneInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendorId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorZoneUncheckedUpdateManyWithoutZoneInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendorId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeZoneUpdateWithoutZoneInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: EmployeeUpdateOneRequiredWithoutZonesNestedInput
  }

  export type EmployeeZoneUncheckedUpdateWithoutZoneInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeZoneUncheckedUpdateManyWithoutZoneInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorGateCreateManyGateInput = {
    id?: string
    vendorId: string
    createdAt?: Date | string
  }

  export type EmployeeGateCreateManyGateInput = {
    id?: string
    employeeId: string
    createdAt?: Date | string
  }

  export type ActivityCreateManyGateInput = {
    id?: string
    type?: $Enums.ActivityType
    status: $Enums.AccessStatus
    denialReason?: string | null
    scannedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    employeeId: string
    scannerId?: string | null
  }

  export type VendorGateUpdateWithoutGateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vendor?: VendorUpdateOneRequiredWithoutGatesNestedInput
  }

  export type VendorGateUncheckedUpdateWithoutGateInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendorId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorGateUncheckedUpdateManyWithoutGateInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendorId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeGateUpdateWithoutGateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: EmployeeUpdateOneRequiredWithoutGatesNestedInput
  }

  export type EmployeeGateUncheckedUpdateWithoutGateInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeGateUncheckedUpdateManyWithoutGateInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityUpdateWithoutGateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    status?: EnumAccessStatusFieldUpdateOperationsInput | $Enums.AccessStatus
    denialReason?: NullableStringFieldUpdateOperationsInput | string | null
    scannedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: EmployeeUpdateOneRequiredWithoutActivitiesNestedInput
    scanner?: UserUpdateOneWithoutActivitiesNestedInput
    alerts?: AlertUpdateManyWithoutActivityNestedInput
  }

  export type ActivityUncheckedUpdateWithoutGateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    status?: EnumAccessStatusFieldUpdateOperationsInput | $Enums.AccessStatus
    denialReason?: NullableStringFieldUpdateOperationsInput | string | null
    scannedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employeeId?: StringFieldUpdateOperationsInput | string
    scannerId?: NullableStringFieldUpdateOperationsInput | string | null
    alerts?: AlertUncheckedUpdateManyWithoutActivityNestedInput
  }

  export type ActivityUncheckedUpdateManyWithoutGateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    status?: EnumAccessStatusFieldUpdateOperationsInput | $Enums.AccessStatus
    denialReason?: NullableStringFieldUpdateOperationsInput | string | null
    scannedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employeeId?: StringFieldUpdateOperationsInput | string
    scannerId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EmployeePermissionCreateManyPermissionInput = {
    id?: string
    employeeId: string
    grantedAt?: Date | string
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmployeePermissionUpdateWithoutPermissionInput = {
    id?: StringFieldUpdateOperationsInput | string
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: EmployeeUpdateOneRequiredWithoutEmployeePermissionsNestedInput
  }

  export type EmployeePermissionUncheckedUpdateWithoutPermissionInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeePermissionUncheckedUpdateManyWithoutPermissionInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeGateCreateManyEmployeeInput = {
    id?: string
    gateId: string
    createdAt?: Date | string
  }

  export type EmployeeZoneCreateManyEmployeeInput = {
    id?: string
    zoneId: string
    createdAt?: Date | string
  }

  export type ActivityCreateManyEmployeeInput = {
    id?: string
    type?: $Enums.ActivityType
    status: $Enums.AccessStatus
    denialReason?: string | null
    scannedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    scannerId?: string | null
    gateId?: string | null
  }

  export type WorkingHoursCreateManyEmployeeInput = {
    id?: string
    dayOfWeek: $Enums.DayOfWeek
    startTime: string
    endTime: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmployeeAttachmentCreateManyEmployeeInput = {
    id?: string
    type: $Enums.EmployeeAttachmentType
    attachmentId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmployeePermissionCreateManyEmployeeInput = {
    id?: string
    permissionId: string
    grantedAt?: Date | string
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AlertCreateManyEmployeeInput = {
    id?: string
    text: string
    severity?: string
    isResolved?: boolean
    resolvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userId?: string | null
    activityId?: string | null
  }

  export type EmployeeAllowedDateCreateManyEmployeeInput = {
    id?: string
    date: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmployeeGateUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gate?: GateUpdateOneRequiredWithoutEmployeesNestedInput
  }

  export type EmployeeGateUncheckedUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    gateId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeGateUncheckedUpdateManyWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    gateId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeZoneUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    zone?: ZoneUpdateOneRequiredWithoutEmployeesNestedInput
  }

  export type EmployeeZoneUncheckedUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    zoneId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeZoneUncheckedUpdateManyWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    zoneId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    status?: EnumAccessStatusFieldUpdateOperationsInput | $Enums.AccessStatus
    denialReason?: NullableStringFieldUpdateOperationsInput | string | null
    scannedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    scanner?: UserUpdateOneWithoutActivitiesNestedInput
    gate?: GateUpdateOneWithoutActivitiesNestedInput
    alerts?: AlertUpdateManyWithoutActivityNestedInput
  }

  export type ActivityUncheckedUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    status?: EnumAccessStatusFieldUpdateOperationsInput | $Enums.AccessStatus
    denialReason?: NullableStringFieldUpdateOperationsInput | string | null
    scannedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    scannerId?: NullableStringFieldUpdateOperationsInput | string | null
    gateId?: NullableStringFieldUpdateOperationsInput | string | null
    alerts?: AlertUncheckedUpdateManyWithoutActivityNestedInput
  }

  export type ActivityUncheckedUpdateManyWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    status?: EnumAccessStatusFieldUpdateOperationsInput | $Enums.AccessStatus
    denialReason?: NullableStringFieldUpdateOperationsInput | string | null
    scannedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    scannerId?: NullableStringFieldUpdateOperationsInput | string | null
    gateId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WorkingHoursUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: EnumDayOfWeekFieldUpdateOperationsInput | $Enums.DayOfWeek
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkingHoursUncheckedUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: EnumDayOfWeekFieldUpdateOperationsInput | $Enums.DayOfWeek
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkingHoursUncheckedUpdateManyWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: EnumDayOfWeekFieldUpdateOperationsInput | $Enums.DayOfWeek
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeAttachmentUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumEmployeeAttachmentTypeFieldUpdateOperationsInput | $Enums.EmployeeAttachmentType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attachment?: AttachmentUpdateOneRequiredWithoutEmployeeAttachmentsNestedInput
  }

  export type EmployeeAttachmentUncheckedUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumEmployeeAttachmentTypeFieldUpdateOperationsInput | $Enums.EmployeeAttachmentType
    attachmentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeAttachmentUncheckedUpdateManyWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumEmployeeAttachmentTypeFieldUpdateOperationsInput | $Enums.EmployeeAttachmentType
    attachmentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeePermissionUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permission?: PermissionUpdateOneRequiredWithoutEmployeePermissionsNestedInput
  }

  export type EmployeePermissionUncheckedUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    permissionId?: StringFieldUpdateOperationsInput | string
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeePermissionUncheckedUpdateManyWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    permissionId?: StringFieldUpdateOperationsInput | string
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AlertUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    isResolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutAlertsNestedInput
    activity?: ActivityUpdateOneWithoutAlertsNestedInput
  }

  export type AlertUncheckedUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    isResolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    activityId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AlertUncheckedUpdateManyWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    isResolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    activityId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EmployeeAllowedDateUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeAllowedDateUncheckedUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeAllowedDateUncheckedUpdateManyWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AlertCreateManyActivityInput = {
    id?: string
    text: string
    severity?: string
    isResolved?: boolean
    resolvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    employeeId?: string | null
    userId?: string | null
  }

  export type AlertUpdateWithoutActivityInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    isResolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: EmployeeUpdateOneWithoutAlertsNestedInput
    user?: UserUpdateOneWithoutAlertsNestedInput
  }

  export type AlertUncheckedUpdateWithoutActivityInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    isResolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AlertUncheckedUpdateManyWithoutActivityInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    isResolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type VendorAttachmentCreateManyAttachmentInput = {
    id?: string
    vendorId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmployeeAttachmentCreateManyAttachmentInput = {
    id?: string
    type: $Enums.EmployeeAttachmentType
    employeeId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VendorAttachmentUpdateWithoutAttachmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vendor?: VendorUpdateOneRequiredWithoutVendorAttachmentsNestedInput
  }

  export type VendorAttachmentUncheckedUpdateWithoutAttachmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendorId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorAttachmentUncheckedUpdateManyWithoutAttachmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendorId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeAttachmentUpdateWithoutAttachmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumEmployeeAttachmentTypeFieldUpdateOperationsInput | $Enums.EmployeeAttachmentType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: EmployeeUpdateOneRequiredWithoutEmployeeAttachmentsNestedInput
  }

  export type EmployeeAttachmentUncheckedUpdateWithoutAttachmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumEmployeeAttachmentTypeFieldUpdateOperationsInput | $Enums.EmployeeAttachmentType
    employeeId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeAttachmentUncheckedUpdateManyWithoutAttachmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumEmployeeAttachmentTypeFieldUpdateOperationsInput | $Enums.EmployeeAttachmentType
    employeeId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}